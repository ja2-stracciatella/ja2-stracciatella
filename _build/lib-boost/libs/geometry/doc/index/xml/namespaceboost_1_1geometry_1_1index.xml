<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="namespaceboost_1_1geometry_1_1index" kind="namespace">
    <compoundname>boost::geometry::index</compoundname>
    <innerclass refid="structboost_1_1geometry_1_1index_1_1equal__to" prot="public">boost::geometry::index::equal_to</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1index_1_1indexable" prot="public">boost::geometry::index::indexable</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1index_1_1insert__iterator" prot="public">boost::geometry::index::insert_iterator</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1index_1_1linear" prot="public">boost::geometry::index::linear</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1index_1_1quadratic" prot="public">boost::geometry::index::quadratic</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1index_1_1rstar" prot="public">boost::geometry::index::rstar</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1index_1_1dynamic__linear" prot="public">boost::geometry::index::dynamic_linear</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1index_1_1dynamic__quadratic" prot="public">boost::geometry::index::dynamic_quadratic</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1index_1_1dynamic__rstar" prot="public">boost::geometry::index::dynamic_rstar</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1index_1_1rtree" prot="public">boost::geometry::index::rtree</innerclass>
    <innernamespace refid="namespaceboost_1_1geometry_1_1index_1_1adaptors">boost::geometry::index::adaptors</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1index_1_1detail">boost::geometry::index::detail</innernamespace>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__inserters_1gab22c33d31b9805250e54ee6d6d240a47" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Container</type>
          </param>
        </templateparamlist>
        <type>insert_iterator&lt; Container &gt;</type>
        <definition>insert_iterator&lt;Container&gt; boost::geometry::index::inserter</definition>
        <argsstring>(Container &amp;c)</argsstring>
        <name>inserter</name>
        <param>
          <type>Container &amp;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Insert iterator generator. </para>        </briefdescription>
        <detaileddescription>
<para>Returns insert iterator capable to insert values to the container (spatial index) which has member function insert(value_type const&amp;) defined.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>The reference to the container (spatial index) to which values will be inserted.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The insert iterator inserting values to the container. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/inserter.hpp" line="72" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/inserter.hpp" bodystart="71" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1gac52a6557110425d4ece53fbd6f9ff866" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::contains_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::contains_tag, false&gt; boost::geometry::index::contains</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>contains</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1gac52a6557110425d4ece53fbd6f9ff866" kindref="member">contains()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::within(Geometry, Indexable)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::contains(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="48" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="47" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga02dbb7cca47de0b921ef96af464d9590" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::covered_by_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::covered_by_tag, false&gt; boost::geometry::index::covered_by</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>covered_by</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1ga02dbb7cca47de0b921ef96af464d9590" kindref="member">covered_by()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::covered_by(Indexable, Geometry)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::covered_by(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="78" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="77" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga0e92e4a20dd19185584fe85847439108" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::covers_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::covers_tag, false&gt; boost::geometry::index::covers</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>covers</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1ga0e92e4a20dd19185584fe85847439108" kindref="member">covers()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::covered_by(Geometry, Indexable)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::covers(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="108" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="107" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga0aa114ab16f40c8caeb3338adba5d6da" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::disjoint_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::disjoint_tag, false&gt; boost::geometry::index::disjoint</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>disjoint</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1ga0aa114ab16f40c8caeb3338adba5d6da" kindref="member">disjoint()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::disjoint(Indexable, Geometry)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::disjoint(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="138" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="137" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga78cb2ef221b951867c591ffb51b7d8c5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::intersects_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::intersects_tag, false&gt; boost::geometry::index::intersects</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>intersects</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1ga78cb2ef221b951867c591ffb51b7d8c5" kindref="member">intersects()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::intersects(Indexable, Geometry)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::intersects(box), std::back_inserter(result));
bgi::query(spatial_index, bgi::intersects(ring), std::back_inserter(result));
bgi::query(spatial_index, bgi::intersects(polygon), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="170" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="169" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga4a6d33e6f61ad5bff3bdee50a972d54b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::overlaps_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::overlaps_tag, false&gt; boost::geometry::index::overlaps</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>overlaps</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1ga4a6d33e6f61ad5bff3bdee50a972d54b" kindref="member">overlaps()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::overlaps(Indexable, Geometry)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::overlaps(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="200" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="199" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1gaabce901b82af2aab10ebbd0dda12f4d5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::within_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::within_tag, false&gt; boost::geometry::index::within</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>within</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1gaabce901b82af2aab10ebbd0dda12f4d5" kindref="member">within()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::within(Indexable, Geometry)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::within(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="259" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="258" bodyend="266"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga3213772dd3e54ad03340c2ca66b4f58c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename UnaryPredicate</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::satisfies&lt; UnaryPredicate, false &gt;</type>
        <definition>detail::predicates::satisfies&lt;UnaryPredicate, false&gt; boost::geometry::index::satisfies</definition>
        <argsstring>(UnaryPredicate const &amp;pred)</argsstring>
        <name>satisfies</name>
        <param>
          <type>UnaryPredicate const &amp;</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Generate <ref refid="group__predicates_1ga3213772dd3e54ad03340c2ca66b4f58c" kindref="member">satisfies()</ref> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>A wrapper around user-defined UnaryPredicate checking if Value should be returned by spatial query.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bool is_red(Value const&amp; v) { return v.is_red(); }

struct is_red_o {
template &lt;typename Value&gt; bool operator()(Value const&amp; v) { return v.is_red(); }
}

// ...

rt.query(index::intersects(box) &amp;&amp; index::satisfies(is_red),
std::back_inserter(result));

rt.query(index::intersects(box) &amp;&amp; index::satisfies(is_red_o()),
std::back_inserter(result));

#ifndef BOOST_NO_CXX11_LAMBDAS
rt.query(index::intersects(box) &amp;&amp; index::satisfies([](Value const&amp; v) { return v.is_red(); }),
std::back_inserter(result));
#endif
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>UnaryPredicate</parametername>
</parameternamelist>
<parameterdescription>
<para>A type of unary predicate function or function object.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The unary predicate function or function object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="304" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="303" bodyend="306"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga8772d9d3e5b12b3292f7d94d47310e3e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::nearest&lt; Geometry &gt;</type>
        <definition>detail::predicates::nearest&lt;Geometry&gt; boost::geometry::index::nearest</definition>
        <argsstring>(Geometry const &amp;geometry, unsigned k)</argsstring>
        <name>nearest</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>k</declname>
        </param>
        <briefdescription>
<para>Generate <ref refid="group__predicates_1ga8772d9d3e5b12b3292f7d94d47310e3e" kindref="member">nearest()</ref> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>When nearest predicate is passed to the query, k-nearest neighbour search will be performed. <computeroutput><ref refid="group__predicates_1ga8772d9d3e5b12b3292f7d94d47310e3e" kindref="member">nearest()</ref></computeroutput> predicate takes a <computeroutput>Geometry</computeroutput> from which distances to <computeroutput>Values</computeroutput> are calculated and the maximum number of <computeroutput>Values</computeroutput> that should be returned. Internally boost::geometry::comparable_distance() is used to perform the calculation.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::nearest(pt, 5), std::back_inserter(result));
bgi::query(spatial_index, bgi::nearest(pt, 5) &amp;&amp; bgi::intersects(box), std::back_inserter(result));
bgi::query(spatial_index, bgi::nearest(box, 5), std::back_inserter(result));
</verbatim></para></simplesect>
<simplesect kind="warning"><para>Only one <computeroutput><ref refid="group__predicates_1ga8772d9d3e5b12b3292f7d94d47310e3e" kindref="member">nearest()</ref></computeroutput> predicate may be used in a query.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The geometry from which distance is calculated. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum number of values to return. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="334" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="333" bodyend="336"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1gada4f62111ed22eb2860ea30995c1ce60" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::index::insert</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;tree, Value const &amp;v)</argsstring>
        <name>insert</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;</type>
          <declname>tree</declname>
        </param>
        <param>
          <type>Value const &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Insert a value to the index. </para>        </briefdescription>
        <detaileddescription>
<para>It calls <computeroutput><ref refid="classboost_1_1geometry_1_1index_1_1rtree_1ad47980467e66b8644df18a480dbf9d86" kindref="member">rtree::insert(value_type const&amp;)</ref></computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The spatial index. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The value which will be stored in the index. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="1789" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="1787" bodyend="1791"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1ga056469ea699e609e67762fe1b789997f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
          <param>
            <type>typename Iterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::index::insert</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;tree, Iterator first, Iterator last)</argsstring>
        <name>insert</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;</type>
          <declname>tree</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Insert a range of values to the index. </para>        </briefdescription>
        <detaileddescription>
<para>It calls <computeroutput><ref refid="classboost_1_1geometry_1_1index_1_1rtree_1a60d4c8790fd8810ff8b57f049e6bed8d" kindref="member">rtree::insert(Iterator, Iterator)</ref></computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The spatial index. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>The beginning of the range of values. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>The end of the range of values. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="1808" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="1806" bodyend="1810"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1gab4edad000d63eb103f2dad3813ceb2b3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
          <param>
            <type>typename ConvertibleOrRange</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::index::insert</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;tree, ConvertibleOrRange const &amp;conv_or_rng)</argsstring>
        <name>insert</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;</type>
          <declname>tree</declname>
        </param>
        <param>
          <type>ConvertibleOrRange const &amp;</type>
          <declname>conv_or_rng</declname>
        </param>
        <briefdescription>
<para>Insert a value created using convertible object or a range of values to the index. </para>        </briefdescription>
        <detaileddescription>
<para>It calls <computeroutput><ref refid="classboost_1_1geometry_1_1index_1_1rtree_1a5db294b14ebf1319edcfc92e78c8167e" kindref="member">rtree::insert(ConvertibleOrRange const&amp;)</ref></computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The spatial index. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>conv_or_rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The object of type convertible to value_type or a range of values. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="1826" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="1824" bodyend="1828"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1gaf353d90fd933e6110b031f63166fb45a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::size_type</type>
        <definition>rtree&lt;Value, Parameters, IndexableGetter, EqualTo, Allocator&gt;::size_type boost::geometry::index::remove</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;tree, Value const &amp;v)</argsstring>
        <name>remove</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;</type>
          <declname>tree</declname>
        </param>
        <param>
          <type>Value const &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Remove a value from the container. </para>        </briefdescription>
        <detaileddescription>
<para>Remove a value from the container. In contrast to the <computeroutput>std::set</computeroutput> or <computeroutput>std::map erase()</computeroutput> method this function removes only one value from the container.</para><para>It calls <computeroutput><ref refid="classboost_1_1geometry_1_1index_1_1rtree_1a1ce933b0b833faec5349bfc27bde15d4" kindref="member">rtree::remove(value_type const&amp;)</ref></computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The spatial index. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The value which will be removed from the index.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if value was removed, 0 otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="1849" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="1847" bodyend="1851"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1gaa460a8985496cf133f63f245527ac6e7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
          <param>
            <type>typename Iterator</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::size_type</type>
        <definition>rtree&lt;Value, Parameters, IndexableGetter, EqualTo, Allocator&gt;::size_type boost::geometry::index::remove</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;tree, Iterator first, Iterator last)</argsstring>
        <name>remove</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;</type>
          <declname>tree</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Remove a range of values from the container. </para>        </briefdescription>
        <detaileddescription>
<para>Remove a range of values from the container. In contrast to the <computeroutput>std::set</computeroutput> or <computeroutput>std::map erase()</computeroutput> method it doesn&apos;t take iterators pointing to values stored in this container. It removes values equal to these passed as a range. Furthermore this function removes only one value for each one passed in the range, not all equal values.</para><para>It calls <computeroutput><ref refid="classboost_1_1geometry_1_1index_1_1rtree_1aa97084231d17564a94f0142d095cecaa" kindref="member">rtree::remove(Iterator, Iterator)</ref></computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The spatial index. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>The beginning of the range of values. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>The end of the range of values.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of removed values. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="1876" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="1874" bodyend="1878"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1ga700c922f8b4d5ebd073e999e12b55249" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
          <param>
            <type>typename ConvertibleOrRange</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::size_type</type>
        <definition>rtree&lt;Value, Parameters, IndexableGetter, EqualTo, Allocator&gt;::size_type boost::geometry::index::remove</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;tree, ConvertibleOrRange const &amp;conv_or_rng)</argsstring>
        <name>remove</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;</type>
          <declname>tree</declname>
        </param>
        <param>
          <type>ConvertibleOrRange const &amp;</type>
          <declname>conv_or_rng</declname>
        </param>
        <briefdescription>
<para>Remove a value corresponding to an object convertible to it or a range of values from the container. </para>        </briefdescription>
        <detaileddescription>
<para>Remove a value corresponding to an object convertible to it or a range of values from the container. In contrast to the <computeroutput>std::set</computeroutput> or <computeroutput>std::map erase()</computeroutput> method it removes values equal to these passed as a range. Furthermore this method removes only one value for each one passed in the range, not all equal values.</para><para>It calls <computeroutput><ref refid="classboost_1_1geometry_1_1index_1_1rtree_1a320cd1861ba7b43364ed53e1f93a4411" kindref="member">rtree::remove(ConvertibleOrRange const&amp;)</ref></computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The spatial index. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>conv_or_rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The object of type convertible to value_type or the range of values.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of removed values. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="1902" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="1900" bodyend="1904"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1gadb43b211d5d743ebe2ef256328286e95" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
          <param>
            <type>typename Predicates</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::size_type</type>
        <definition>rtree&lt;Value, Parameters, IndexableGetter, EqualTo, Allocator&gt;::size_type boost::geometry::index::query</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;tree, Predicates const &amp;predicates, OutIter out_it)</argsstring>
        <name>query</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;</type>
          <declname>tree</declname>
        </param>
        <param>
          <type>Predicates const &amp;</type>
          <declname>predicates</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>out_it</declname>
        </param>
        <briefdescription>
<para>Finds values meeting passed predicates e.g. nearest to some Point and/or intersecting some Box. </para>        </briefdescription>
        <detaileddescription>
<para>This query function performs spatial and k-nearest neighbor searches. It allows to pass a set of predicates. Values will be returned only if all predicates are met.</para><para><bold>Spatial predicates</bold></para><para>Spatial predicates may be generated by one of the functions listed below: <itemizedlist>
<listitem><para><computeroutput><ref refid="group__predicates_1gac52a6557110425d4ece53fbd6f9ff866" kindref="member">boost::geometry::index::contains()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput><ref refid="group__predicates_1ga02dbb7cca47de0b921ef96af464d9590" kindref="member">boost::geometry::index::covered_by()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput><ref refid="group__predicates_1ga0e92e4a20dd19185584fe85847439108" kindref="member">boost::geometry::index::covers()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput><ref refid="group__predicates_1ga0aa114ab16f40c8caeb3338adba5d6da" kindref="member">boost::geometry::index::disjoint()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput><ref refid="group__predicates_1ga78cb2ef221b951867c591ffb51b7d8c5" kindref="member">boost::geometry::index::intersects()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput><ref refid="group__predicates_1ga4a6d33e6f61ad5bff3bdee50a972d54b" kindref="member">boost::geometry::index::overlaps()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput><ref refid="group__predicates_1gaabce901b82af2aab10ebbd0dda12f4d5" kindref="member">boost::geometry::index::within()</ref></computeroutput>,</para></listitem>
</itemizedlist>
It is possible to negate spatial predicates: <itemizedlist>
<listitem><para><computeroutput>! <ref refid="group__predicates_1gac52a6557110425d4ece53fbd6f9ff866" kindref="member">boost::geometry::index::contains()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput>! <ref refid="group__predicates_1ga02dbb7cca47de0b921ef96af464d9590" kindref="member">boost::geometry::index::covered_by()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput>! <ref refid="group__predicates_1ga0e92e4a20dd19185584fe85847439108" kindref="member">boost::geometry::index::covers()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput>! <ref refid="group__predicates_1ga0aa114ab16f40c8caeb3338adba5d6da" kindref="member">boost::geometry::index::disjoint()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput>! <ref refid="group__predicates_1ga78cb2ef221b951867c591ffb51b7d8c5" kindref="member">boost::geometry::index::intersects()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput>! <ref refid="group__predicates_1ga4a6d33e6f61ad5bff3bdee50a972d54b" kindref="member">boost::geometry::index::overlaps()</ref></computeroutput>, </para></listitem>
<listitem><para><computeroutput>! <ref refid="group__predicates_1gaabce901b82af2aab10ebbd0dda12f4d5" kindref="member">boost::geometry::index::within()</ref></computeroutput></para></listitem>
</itemizedlist>
<bold>Satisfies predicate</bold></para><para>This is a special kind of predicate which allows to pass a user-defined function or function object which checks if Value should be returned by the query. It&apos;s generated by: <itemizedlist>
<listitem><para><computeroutput><ref refid="group__predicates_1ga3213772dd3e54ad03340c2ca66b4f58c" kindref="member">boost::geometry::index::satisfies()</ref></computeroutput>.</para></listitem>
</itemizedlist>
<bold>Nearest predicate</bold></para><para>If the nearest predicate is passed a k-nearest neighbor search will be performed. This query will result in returning k values to the output iterator. Only one nearest predicate may be passed to the query. It may be generated by: <itemizedlist>
<listitem><para><computeroutput><ref refid="group__predicates_1ga8772d9d3e5b12b3292f7d94d47310e3e" kindref="member">boost::geometry::index::nearest()</ref></computeroutput>.</para></listitem>
</itemizedlist>
<bold>Connecting predicates</bold></para><para>Predicates may be passed together connected with <computeroutput>operator&amp;&amp;()</computeroutput>.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
// return elements intersecting box
bgi::query(tree, bgi::intersects(box), std::back_inserter(result));
// return elements intersecting poly but not within box
bgi::query(tree, bgi::intersects(poly) &amp;&amp; !bgi::within(box), std::back_inserter(result));
// return elements overlapping box and meeting my_fun value predicate
bgi::query(tree, bgi::overlaps(box) &amp;&amp; bgi::satisfies(my_fun), std::back_inserter(result));
// return 5 elements nearest to pt and elements are intersecting box
bgi::query(tree, bgi::nearest(pt, 5) &amp;&amp; bgi::intersects(box), std::back_inserter(result));

// For each found value do_something (it is a type of function object)
tree.query(bgi::intersects(box),
           boost::make_function_output_iterator(do_something()));
</verbatim></para></simplesect>
<simplesect kind="par"><title>Throws</title><para>If Value copy constructor or copy assignment throws.</para></simplesect>
<simplesect kind="warning"><para>Only one <computeroutput><ref refid="group__predicates_1ga8772d9d3e5b12b3292f7d94d47310e3e" kindref="member">nearest()</ref></computeroutput> perdicate may be passed to the query. Passing more of them results in compile-time error.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The rtree. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>predicates</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicates. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out_it</parametername>
</parameternamelist>
<parameterdescription>
<para>The output iterator, e.g. generated by std::back_inserter().</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of values found. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="1985" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="1982" bodyend="1987"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1ga45c2b7b112bf730d10367e10df62aa3c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
          <param>
            <type>typename Predicates</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::const_query_iterator</type>
        <definition>rtree&lt;Value, Parameters, IndexableGetter, EqualTo, Allocator&gt;::const_query_iterator boost::geometry::index::qbegin</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;tree, Predicates const &amp;predicates)</argsstring>
        <name>qbegin</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;</type>
          <declname>tree</declname>
        </param>
        <param>
          <type>Predicates const &amp;</type>
          <declname>predicates</declname>
        </param>
        <briefdescription>
<para>Returns the query iterator pointing at the begin of the query range. </para>        </briefdescription>
        <detaileddescription>
<para>This method returns the iterator which may be used to perform iterative queries. For the information about the predicates which may be passed to this method see <ref refid="group__rtree__functions_1gadb43b211d5d743ebe2ef256328286e95" kindref="member">query()</ref>.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
std::for_each(bgi::qbegin(tree, bgi::nearest(pt, 3)), bgi::qend(tree), do_something());
</verbatim></para></simplesect>
<simplesect kind="par"><title>Iterator category</title><para>ForwardIterator</para></simplesect>
<simplesect kind="par"><title>Throws</title><para>If predicates copy throws. If allocation throws.</para></simplesect>
<simplesect kind="warning"><para>The modification of the rtree may invalidate the iterators.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The rtree. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>predicates</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicates.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The iterator pointing at the begin of the query range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="2022" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="2020" bodyend="2024"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1ga5c9a1eb0421bf2c702392247d48143e5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::const_query_iterator</type>
        <definition>rtree&lt;Value, Parameters, IndexableGetter, EqualTo, Allocator&gt;::const_query_iterator boost::geometry::index::qend</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;tree)</argsstring>
        <name>qend</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;</type>
          <declname>tree</declname>
        </param>
        <briefdescription>
<para>Returns the query iterator pointing at the end of the query range. </para>        </briefdescription>
        <detaileddescription>
<para>This method returns the iterator which may be used to check if the query has ended.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
std::for_each(bgi::qbegin(tree, bgi::nearest(pt, 3)), bgi::qend(tree), do_something());
</verbatim></para></simplesect>
<simplesect kind="par"><title>Iterator category</title><para>ForwardIterator</para></simplesect>
<simplesect kind="par"><title>Throws</title><para>Nothing</para></simplesect>
<simplesect kind="warning"><para>The modification of the rtree may invalidate the iterators.</para></simplesect>
<simplesect kind="return"><para>The iterator pointing at the end of the query range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="2052" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="2051" bodyend="2054"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1ga2467dc6ac90303496abd6ebd136eba18" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::const_iterator</type>
        <definition>rtree&lt;Value, Parameters, IndexableGetter, EqualTo, Allocator&gt;::const_iterator boost::geometry::index::begin</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;tree)</argsstring>
        <name>begin</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;</type>
          <declname>tree</declname>
        </param>
        <briefdescription>
<para>Returns the iterator pointing at the begin of the rtree values range. </para>        </briefdescription>
        <detaileddescription>
<para>This method returns the iterator which may be used to iterate over all values stored in the rtree.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
std::for_each(bgi::begin(tree), bgi::end(tree), do_something());
// the same as
std::for_each(boost::begin(tree), boost::end(tree), do_something());
</verbatim></para></simplesect>
<simplesect kind="par"><title>Iterator category</title><para>ForwardIterator</para></simplesect>
<simplesect kind="par"><title>Throws</title><para>If allocation throws.</para></simplesect>
<simplesect kind="warning"><para>The modification of the rtree may invalidate the iterators.</para></simplesect>
<simplesect kind="return"><para>The iterator pointing at the begin of the range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="2085" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="2084" bodyend="2087"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1ga8fd1e53d8492643cbc9840ff715bb736" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::const_iterator</type>
        <definition>rtree&lt;Value, Parameters, IndexableGetter, EqualTo, Allocator&gt;::const_iterator boost::geometry::index::end</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;tree)</argsstring>
        <name>end</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;</type>
          <declname>tree</declname>
        </param>
        <briefdescription>
<para>Returns the iterator pointing at the end of the rtree values range. </para>        </briefdescription>
        <detaileddescription>
<para>This method returns the iterator which may be compared with the iterator returned by <ref refid="group__rtree__functions_1ga2467dc6ac90303496abd6ebd136eba18" kindref="member">begin()</ref> in order to check if the iteration has ended.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
std::for_each(bgi::begin(tree), bgi::end(tree), do_something());
// the same as
std::for_each(boost::begin(tree), boost::end(tree), do_something());
</verbatim></para></simplesect>
<simplesect kind="par"><title>Iterator category</title><para>ForwardIterator</para></simplesect>
<simplesect kind="par"><title>Throws</title><para>Nothing.</para></simplesect>
<simplesect kind="warning"><para>The modification of the rtree may invalidate the iterators.</para></simplesect>
<simplesect kind="return"><para>The iterator pointing at the end of the range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="2118" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="2117" bodyend="2120"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1gabaca6c24c3838a8164aa3700c459e7a4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::index::clear</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;tree)</argsstring>
        <name>clear</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;</type>
          <declname>tree</declname>
        </param>
        <briefdescription>
<para>Remove all values from the index. </para>        </briefdescription>
        <detaileddescription>
<para>It calls <computeroutput><ref refid="classboost_1_1geometry_1_1index_1_1rtree_1a1bec40977c175983f585c4488cf8fe3c" kindref="member">rtree::clear()</ref></computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The spatial index. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="2133" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="2132" bodyend="2135"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1gaa19a09e7b5f0a86a4b74ef2342de1d68" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t boost::geometry::index::size</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;tree)</argsstring>
        <name>size</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;</type>
          <declname>tree</declname>
        </param>
        <briefdescription>
<para>Get the number of values stored in the index. </para>        </briefdescription>
        <detaileddescription>
<para>It calls <computeroutput><ref refid="classboost_1_1geometry_1_1index_1_1rtree_1ac9f152c8c96525e3735b81635d8171b1" kindref="member">rtree::size()</ref></computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The spatial index.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of values stored in the index. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="2150" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="2149" bodyend="2152"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1gaba44e2fb12fdc7b528bfee56a88e0844" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::index::empty</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;tree)</argsstring>
        <name>empty</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;</type>
          <declname>tree</declname>
        </param>
        <briefdescription>
<para>Query if there are no values stored in the index. </para>        </briefdescription>
        <detaileddescription>
<para>It calls <computeroutput><ref refid="classboost_1_1geometry_1_1index_1_1rtree_1aa5302ce1c26105d722aac20793e83f0e" kindref="member">rtree::empty()</ref></computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The spatial index.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if there are no values in the index. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="2167" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="2166" bodyend="2169"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1ga4e43e7720c66e88959ff511a7462a3ff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::bounds_type</type>
        <definition>rtree&lt;Value, Parameters, IndexableGetter, EqualTo, Allocator&gt;::bounds_type boost::geometry::index::bounds</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;tree)</argsstring>
        <name>bounds</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;</type>
          <declname>tree</declname>
        </param>
        <briefdescription>
<para>Get the box containing all stored values or an invalid box if the index has no values. </para>        </briefdescription>
        <detaileddescription>
<para>It calls <computeroutput>rtree::envelope()</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tree</parametername>
</parameternamelist>
<parameterdescription>
<para>The spatial index.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The box containing all stored values or an invalid box. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="2185" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="2184" bodyend="2187"/>
      </memberdef>
      <memberdef kind="function" id="group__rtree__functions_1gaa1250318a78d7e27ba8f3537eb0ddb3f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Parameters</type>
          </param>
          <param>
            <type>typename IndexableGetter</type>
          </param>
          <param>
            <type>typename EqualTo</type>
          </param>
          <param>
            <type>typename Allocator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::index::swap</definition>
        <argsstring>(rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;l, rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;r)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;</type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="classboost_1_1geometry_1_1index_1_1rtree" kindref="compound">rtree</ref>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>Exchanges the contents of the container with those of other. </para>        </briefdescription>
        <detaileddescription>
<para>It calls <computeroutput><ref refid="classboost_1_1geometry_1_1index_1_1rtree_1aedb719dfece91d298e9ee56878524c9b" kindref="member">rtree::swap()</ref></computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>l</parametername>
</parameternamelist>
<parameterdescription>
<para>The first rtree. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>The second rtree. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" line="2202" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/rtree.hpp" bodystart="2200" bodyend="2204"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/travis/build/boostorg/boost/boost/geometry/index/distance_predicates.hpp" line="20"/>
  </compounddef>
</doxygen>
