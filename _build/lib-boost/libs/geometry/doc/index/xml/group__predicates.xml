<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="group__predicates" kind="group">
    <compoundname>predicates</compoundname>
    <title>Predicates (boost::geometry::index::)</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__predicates_1gac52a6557110425d4ece53fbd6f9ff866" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::contains_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::contains_tag, false&gt; boost::geometry::index::contains</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>contains</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1gac52a6557110425d4ece53fbd6f9ff866" kindref="member">contains()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::within(Geometry, Indexable)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::contains(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="48" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="47" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga02dbb7cca47de0b921ef96af464d9590" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::covered_by_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::covered_by_tag, false&gt; boost::geometry::index::covered_by</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>covered_by</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1ga02dbb7cca47de0b921ef96af464d9590" kindref="member">covered_by()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::covered_by(Indexable, Geometry)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::covered_by(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="78" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="77" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga0e92e4a20dd19185584fe85847439108" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::covers_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::covers_tag, false&gt; boost::geometry::index::covers</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>covers</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1ga0e92e4a20dd19185584fe85847439108" kindref="member">covers()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::covered_by(Geometry, Indexable)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::covers(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="108" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="107" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga0aa114ab16f40c8caeb3338adba5d6da" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::disjoint_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::disjoint_tag, false&gt; boost::geometry::index::disjoint</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>disjoint</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1ga0aa114ab16f40c8caeb3338adba5d6da" kindref="member">disjoint()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::disjoint(Indexable, Geometry)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::disjoint(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="138" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="137" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga78cb2ef221b951867c591ffb51b7d8c5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::intersects_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::intersects_tag, false&gt; boost::geometry::index::intersects</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>intersects</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1ga78cb2ef221b951867c591ffb51b7d8c5" kindref="member">intersects()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::intersects(Indexable, Geometry)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::intersects(box), std::back_inserter(result));
bgi::query(spatial_index, bgi::intersects(ring), std::back_inserter(result));
bgi::query(spatial_index, bgi::intersects(polygon), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="170" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="169" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga4a6d33e6f61ad5bff3bdee50a972d54b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::overlaps_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::overlaps_tag, false&gt; boost::geometry::index::overlaps</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>overlaps</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1ga4a6d33e6f61ad5bff3bdee50a972d54b" kindref="member">overlaps()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::overlaps(Indexable, Geometry)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::overlaps(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="200" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="199" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1gaabce901b82af2aab10ebbd0dda12f4d5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::spatial_predicate&lt; Geometry, detail::predicates::within_tag, false &gt;</type>
        <definition>detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::within_tag, false&gt; boost::geometry::index::within</definition>
        <argsstring>(Geometry const &amp;g)</argsstring>
        <name>within</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Generate <computeroutput><ref refid="group__predicates_1gaabce901b82af2aab10ebbd0dda12f4d5" kindref="member">within()</ref></computeroutput> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <computeroutput>bg::within(Indexable, Geometry)</computeroutput> returns true.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::within(box), std::back_inserter(result));
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry type.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>The Geometry object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="259" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="258" bodyend="266"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga3213772dd3e54ad03340c2ca66b4f58c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename UnaryPredicate</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::satisfies&lt; UnaryPredicate, false &gt;</type>
        <definition>detail::predicates::satisfies&lt;UnaryPredicate, false&gt; boost::geometry::index::satisfies</definition>
        <argsstring>(UnaryPredicate const &amp;pred)</argsstring>
        <name>satisfies</name>
        <param>
          <type>UnaryPredicate const &amp;</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Generate <ref refid="group__predicates_1ga3213772dd3e54ad03340c2ca66b4f58c" kindref="member">satisfies()</ref> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>A wrapper around user-defined UnaryPredicate checking if Value should be returned by spatial query.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bool is_red(Value const&amp; v) { return v.is_red(); }

struct is_red_o {
template &lt;typename Value&gt; bool operator()(Value const&amp; v) { return v.is_red(); }
}

// ...

rt.query(index::intersects(box) &amp;&amp; index::satisfies(is_red),
std::back_inserter(result));

rt.query(index::intersects(box) &amp;&amp; index::satisfies(is_red_o()),
std::back_inserter(result));

#ifndef BOOST_NO_CXX11_LAMBDAS
rt.query(index::intersects(box) &amp;&amp; index::satisfies([](Value const&amp; v) { return v.is_red(); }),
std::back_inserter(result));
#endif
</verbatim></para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>UnaryPredicate</parametername>
</parameternamelist>
<parameterdescription>
<para>A type of unary predicate function or function object.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The unary predicate function or function object. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="304" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="303" bodyend="306"/>
      </memberdef>
      <memberdef kind="function" id="group__predicates_1ga8772d9d3e5b12b3292f7d94d47310e3e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>detail::predicates::nearest&lt; Geometry &gt;</type>
        <definition>detail::predicates::nearest&lt;Geometry&gt; boost::geometry::index::nearest</definition>
        <argsstring>(Geometry const &amp;geometry, unsigned k)</argsstring>
        <name>nearest</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>k</declname>
        </param>
        <briefdescription>
<para>Generate <ref refid="group__predicates_1ga8772d9d3e5b12b3292f7d94d47310e3e" kindref="member">nearest()</ref> predicate. </para>        </briefdescription>
        <detaileddescription>
<para>When nearest predicate is passed to the query, k-nearest neighbour search will be performed. <computeroutput><ref refid="group__predicates_1ga8772d9d3e5b12b3292f7d94d47310e3e" kindref="member">nearest()</ref></computeroutput> predicate takes a <computeroutput>Geometry</computeroutput> from which distances to <computeroutput>Values</computeroutput> are calculated and the maximum number of <computeroutput>Values</computeroutput> that should be returned. Internally boost::geometry::comparable_distance() is used to perform the calculation.</para><para><simplesect kind="par"><title>Example</title><para><verbatim>
bgi::query(spatial_index, bgi::nearest(pt, 5), std::back_inserter(result));
bgi::query(spatial_index, bgi::nearest(pt, 5) &amp;&amp; bgi::intersects(box), std::back_inserter(result));
bgi::query(spatial_index, bgi::nearest(box, 5), std::back_inserter(result));
</verbatim></para></simplesect>
<simplesect kind="warning"><para>Only one <computeroutput><ref refid="group__predicates_1ga8772d9d3e5b12b3292f7d94d47310e3e" kindref="member">nearest()</ref></computeroutput> predicate may be used in a query.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>The geometry from which distance is calculated. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum number of values to return. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" line="334" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/index/predicates.hpp" bodystart="333" bodyend="336"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
