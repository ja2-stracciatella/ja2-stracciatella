<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Boost.Geometry.Index: boost::geometry::index::rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Geometry.Index
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>boost</b>      </li>
      <li class="navelem"><b>geometry</b>      </li>
      <li class="navelem"><b>index</b>      </li>
      <li class="navelem"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">boost::geometry::index::rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="boost::geometry::index::rtree" -->
<p>The R-tree spatial index.  
 <a href="classboost_1_1geometry_1_1index_1_1rtree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rtree_8hpp_source.html">rtree.hpp</a>&gt;</code></p>

<p><a href="classboost_1_1geometry_1_1index_1_1rtree-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5761a41d87b93d4fd548ecb6600ae757"></a><!-- doxytag: member="boost::geometry::index::rtree::value_type" ref="a5761a41d87b93d4fd548ecb6600ae757" args="" -->
typedef Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a5761a41d87b93d4fd548ecb6600ae757">value_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of Value stored in the container. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80db5532eb59f7a809bd44ded265eb17"></a><!-- doxytag: member="boost::geometry::index::rtree::parameters_type" ref="a80db5532eb59f7a809bd44ded265eb17" args="" -->
typedef Parameters&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">R-tree parameters type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43a7adb311cafc08e23010ccb4e97fb5"></a><!-- doxytag: member="boost::geometry::index::rtree::indexable_getter" ref="a43a7adb311cafc08e23010ccb4e97fb5" args="" -->
typedef IndexableGetter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The function object extracting Indexable from Value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8fe544de514014a1bd87ea1b881ff9b"></a><!-- doxytag: member="boost::geometry::index::rtree::value_equal" ref="ad8fe544de514014a1bd87ea1b881ff9b" args="" -->
typedef EqualTo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The function object comparing objects of type Value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6618b5c7e88ed70533233fbac0f5b2e"></a><!-- doxytag: member="boost::geometry::index::rtree::allocator_type" ref="ab6618b5c7e88ed70533233fbac0f5b2e" args="" -->
typedef Allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of allocator used by the container. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28e88e55d260a454688fe1bd5e5af96b"></a><!-- doxytag: member="boost::geometry::index::rtree::indexable_type" ref="a28e88e55d260a454688fe1bd5e5af96b" args="" -->
typedef <br class="typebreak"/>
index::detail::indexable_type<br class="typebreak"/>
&lt; detail::translator<br class="typebreak"/>
&lt; IndexableGetter, EqualTo &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a28e88e55d260a454688fe1bd5e5af96b">indexable_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Indexable type to which Value is translated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12e80f9da4c68e0e687f1c2012321147"></a><!-- doxytag: member="boost::geometry::index::rtree::bounds_type" ref="a12e80f9da4c68e0e687f1c2012321147" args="" -->
typedef geometry::model::box<br class="typebreak"/>
&lt; geometry::model::point<br class="typebreak"/>
&lt; typename coordinate_type<br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a28e88e55d260a454688fe1bd5e5af96b">indexable_type</a> &gt;::type, <br class="typebreak"/>
dimension&lt; <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a28e88e55d260a454688fe1bd5e5af96b">indexable_type</a> &gt;<br class="typebreak"/>
::value, typename <br class="typebreak"/>
coordinate_system<br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a28e88e55d260a454688fe1bd5e5af96b">indexable_type</a> &gt;::type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a12e80f9da4c68e0e687f1c2012321147">bounds_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Box type used by the R-tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5301c3d7ee3589751579e0573a9e8165"></a><!-- doxytag: member="boost::geometry::index::rtree::reference" ref="a5301c3d7ee3589751579e0573a9e8165" args="" -->
typedef allocators_type::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a5301c3d7ee3589751579e0573a9e8165">reference</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of reference to Value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a615e622930be97ab1f3b8ceee641feaf"></a><!-- doxytag: member="boost::geometry::index::rtree::const_reference" ref="a615e622930be97ab1f3b8ceee641feaf" args="" -->
typedef <br class="typebreak"/>
allocators_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a615e622930be97ab1f3b8ceee641feaf">const_reference</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of reference to const Value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a762ced6b98d2cc6503e2b00549c6a89a"></a><!-- doxytag: member="boost::geometry::index::rtree::pointer" ref="a762ced6b98d2cc6503e2b00549c6a89a" args="" -->
typedef allocators_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a762ced6b98d2cc6503e2b00549c6a89a">pointer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointer to Value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abad30462044d5d8fb607c24a05e8c9c2"></a><!-- doxytag: member="boost::geometry::index::rtree::const_pointer" ref="abad30462044d5d8fb607c24a05e8c9c2" args="" -->
typedef <br class="typebreak"/>
allocators_type::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#abad30462044d5d8fb607c24a05e8c9c2">const_pointer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointer to const Value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac256168e9371a070515fc61f29c691ed"></a><!-- doxytag: member="boost::geometry::index::rtree::difference_type" ref="ac256168e9371a070515fc61f29c691ed" args="" -->
typedef <br class="typebreak"/>
allocators_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ac256168e9371a070515fc61f29c691ed">difference_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of difference type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc1f90d7b70afebc58107c523ece5cd5"></a><!-- doxytag: member="boost::geometry::index::rtree::size_type" ref="acc1f90d7b70afebc58107c523ece5cd5" args="" -->
typedef allocators_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integral type used by the container. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a701f65f0d6cf2e8b7be7f1c4b8fb7fde"></a><!-- doxytag: member="boost::geometry::index::rtree::const_iterator" ref="a701f65f0d6cf2e8b7be7f1c4b8fb7fde" args="" -->
typedef <br class="typebreak"/>
index::detail::rtree::iterators::iterator<br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a5761a41d87b93d4fd548ecb6600ae757">value_type</a>, options_type, <br class="typebreak"/>
translator_type, box_type, <br class="typebreak"/>
allocators_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a701f65f0d6cf2e8b7be7f1c4b8fb7fde">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of const iterator, category ForwardIterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad144a7704ad878caaa84cda79b140855"></a><!-- doxytag: member="boost::geometry::index::rtree::const_query_iterator" ref="ad144a7704ad878caaa84cda79b140855" args="" -->
typedef <br class="typebreak"/>
index::detail::rtree::iterators::query_iterator<br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a5761a41d87b93d4fd548ecb6600ae757">value_type</a>, allocators_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad144a7704ad878caaa84cda79b140855">const_query_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of const query iterator, category ForwardIterator. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a55d5fd5d205df08db5267253689ccf0c">rtree</a> (<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a> const &amp;<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a9076baef90a3a9c6018871fa25115a73">parameters</a>=<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a>(), <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a> const &amp;getter=<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a>(), <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a> const &amp;equal=<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor.  <a href="#a55d5fd5d205df08db5267253689ccf0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a1a6b696d4855cbf1866196fe058c3a87">rtree</a> (<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a> const &amp;<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a9076baef90a3a9c6018871fa25115a73">parameters</a>, <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a> const &amp;getter, <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a> const &amp;equal, <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a> const &amp;allocator)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor.  <a href="#a1a6b696d4855cbf1866196fe058c3a87"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a037f17d8a1dfa4a818ff471dec61c912">rtree</a> (Iterator first, Iterator last, <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a> const &amp;<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a9076baef90a3a9c6018871fa25115a73">parameters</a>=<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a>(), <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a> const &amp;getter=<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a>(), <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a> const &amp;equal=<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a>(), <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a> const &amp;allocator=<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor.  <a href="#a037f17d8a1dfa4a818ff471dec61c912"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a7b96b715c52ddc13d7a81db344825848">rtree</a> (Range const &amp;rng, <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a> const &amp;<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a9076baef90a3a9c6018871fa25115a73">parameters</a>=<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a>(), <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a> const &amp;getter=<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a>(), <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a> const &amp;equal=<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a>(), <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a> const &amp;allocator=<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor.  <a href="#a7b96b715c52ddc13d7a81db344825848"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#af8db72811d2be53c409240204e63fb5a">~rtree</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor.  <a href="#af8db72811d2be53c409240204e63fb5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a826fc3236e181ad718d5283e95d7866f">rtree</a> (<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> const &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor.  <a href="#a826fc3236e181ad718d5283e95d7866f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a72b6b75e083eea2ed26f54d4a2265375">rtree</a> (<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> const &amp;src, <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a> const &amp;allocator)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor.  <a href="#a72b6b75e083eea2ed26f54d4a2265375"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#aa8b27db8cb783282ab5274e6769da26a">rtree</a> (<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> &amp;&amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The moving constructor.  <a href="#aa8b27db8cb783282ab5274e6769da26a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a8508c4236d17ff39a1caef058aac8486">rtree</a> (<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> &amp;&amp;src, <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a> const &amp;allocator)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The moving constructor.  <a href="#a8508c4236d17ff39a1caef058aac8486"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad0db5e9e41e1553f944b7e740dbbb883">operator=</a> (<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> const &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The assignment operator.  <a href="#ad0db5e9e41e1553f944b7e740dbbb883"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#af0bf9622ed3e901580b73ed39b746fb7">operator=</a> (<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> &amp;&amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The moving assignment.  <a href="#af0bf9622ed3e901580b73ed39b746fb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#aedb719dfece91d298e9ee56878524c9b">swap</a> (<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps contents of two rtrees.  <a href="#aedb719dfece91d298e9ee56878524c9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad47980467e66b8644df18a480dbf9d86">insert</a> (<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a5761a41d87b93d4fd548ecb6600ae757">value_type</a> const &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value to the index.  <a href="#ad47980467e66b8644df18a480dbf9d86"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a60d4c8790fd8810ff8b57f049e6bed8d">insert</a> (Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a range of values to the index.  <a href="#a60d4c8790fd8810ff8b57f049e6bed8d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ConvertibleOrRange &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a5db294b14ebf1319edcfc92e78c8167e">insert</a> (ConvertibleOrRange const &amp;conv_or_rng)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value created using convertible object or a range of values to the index.  <a href="#a5db294b14ebf1319edcfc92e78c8167e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a1ce933b0b833faec5349bfc27bde15d4">remove</a> (<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a5761a41d87b93d4fd548ecb6600ae757">value_type</a> const &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a value from the container.  <a href="#a1ce933b0b833faec5349bfc27bde15d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#aa97084231d17564a94f0142d095cecaa">remove</a> (Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a range of values from the container.  <a href="#aa97084231d17564a94f0142d095cecaa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ConvertibleOrRange &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a320cd1861ba7b43364ed53e1f93a4411">remove</a> (ConvertibleOrRange const &amp;conv_or_rng)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove value corresponding to an object convertible to it or a range of values from the container.  <a href="#a320cd1861ba7b43364ed53e1f93a4411"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Predicates , typename OutIter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a7baa88eb4e7a5c640ab847513de45b3e">query</a> (Predicates const &amp;predicates, OutIter out_it) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds values meeting passed predicates e.g. nearest to some Point and/or intersecting some Box.  <a href="#a7baa88eb4e7a5c640ab847513de45b3e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Predicates &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad144a7704ad878caaa84cda79b140855">const_query_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a63d15f3b5b157a47045fcac3fec3b7a0">qbegin</a> (Predicates const &amp;predicates) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a query iterator pointing at the begin of the query range.  <a href="#a63d15f3b5b157a47045fcac3fec3b7a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad144a7704ad878caaa84cda79b140855">const_query_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#af3b16f4732fa8113c0b2187005182513">qend</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a query iterator pointing at the end of the query range.  <a href="#af3b16f4732fa8113c0b2187005182513"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a701f65f0d6cf2e8b7be7f1c4b8fb7fde">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a23219a7705ac491862c67be8baa34f0d">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator pointing at the begin of the rtree values range.  <a href="#a23219a7705ac491862c67be8baa34f0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a701f65f0d6cf2e8b7be7f1c4b8fb7fde">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a513f1bd9dfcd022acb208e62115b29b1">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator pointing at the end of the rtree values range.  <a href="#a513f1bd9dfcd022acb208e62115b29b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ac9f152c8c96525e3735b81635d8171b1">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of stored values.  <a href="#ac9f152c8c96525e3735b81635d8171b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#aa5302ce1c26105d722aac20793e83f0e">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the container is empty.  <a href="#aa5302ce1c26105d722aac20793e83f0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a1bec40977c175983f585c4488cf8fe3c">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all values stored in the container.  <a href="#a1bec40977c175983f585c4488cf8fe3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a12e80f9da4c68e0e687f1c2012321147">bounds_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a0dad06d0f117f45ed54b5c123cb41d6e">bounds</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the box able to contain all values stored in the container.  <a href="#a0dad06d0f117f45ed54b5c123cb41d6e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ValueOrIndexable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#aaa834c241c191ac9de67f134564f36fa">count</a> (ValueOrIndexable const &amp;vori) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count Values or Indexables stored in the container.  <a href="#aaa834c241c191ac9de67f134564f36fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a9076baef90a3a9c6018871fa25115a73">parameters</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns parameters.  <a href="#a9076baef90a3a9c6018871fa25115a73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#af391fd642a218c5fb10fc68d643a62b5">indexable_get</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns function retrieving Indexable from Value.  <a href="#af391fd642a218c5fb10fc68d643a62b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a16424563d0973960ac01f7a1969eeebe">value_eq</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns function comparing Values.  <a href="#a16424563d0973960ac01f7a1969eeebe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a17d9cef211feb7f674a5b4602f4cc81e">get_allocator</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns allocator used by the rtree.  <a href="#a17d9cef211feb7f674a5b4602f4cc81e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt;<br/>
class boost::geometry::index::rtree&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;</h3>

<p>The R-tree spatial index. </p>
<p>This is self-balancing spatial index capable to store various types of Values and balancing algorithms.</p>
<dl class="user"><dt><b>Parameters</b></dt><dd>The user must pass a type defining the Parameters which will be used in rtree creation process. This type is used e.g. to specify balancing algorithm with specific parameters like min and max number of elements in node.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Predefined algorithms with compile-time parameters are: <ul>
<li><code><a class="el" href="structboost_1_1geometry_1_1index_1_1linear.html" title="Linear r-tree creation algorithm parameters.">boost::geometry::index::linear</a></code>, </li>
<li><code><a class="el" href="structboost_1_1geometry_1_1index_1_1quadratic.html" title="Quadratic r-tree creation algorithm parameters.">boost::geometry::index::quadratic</a></code>, </li>
<li><code><a class="el" href="structboost_1_1geometry_1_1index_1_1rstar.html" title="R*-tree creation algorithm parameters.">boost::geometry::index::rstar</a></code>.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Predefined algorithms with run-time parameters are: <ul>
<li><code><a class="el" href="classboost_1_1geometry_1_1index_1_1dynamic__linear.html" title="Linear r-tree creation algorithm parameters - run-time version.">boost::geometry::index::dynamic_linear</a></code>, </li>
<li><code><a class="el" href="classboost_1_1geometry_1_1index_1_1dynamic__quadratic.html" title="Quadratic r-tree creation algorithm parameters - run-time version.">boost::geometry::index::dynamic_quadratic</a></code>, </li>
<li><code><a class="el" href="classboost_1_1geometry_1_1index_1_1dynamic__rstar.html" title="R*-tree creation algorithm parameters - run-time version.">boost::geometry::index::dynamic_rstar</a></code>.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>IndexableGetter</b></dt><dd>The object of IndexableGetter type translates from Value to Indexable each time r-tree requires it. This means that this operation is done for each Value access. Therefore the IndexableGetter should return the Indexable by a reference type. The Indexable should not be calculated since it could harm the performance. The default IndexableGetter can translate all types adapted to Point, Box or Segment concepts (called Indexables). Furthermore, it can handle <code>std::pair&lt;Indexable, T&gt;</code>, <code>boost::tuple&lt;Indexable, ...&gt;</code> and <code>std::tuple&lt;Indexable, ...&gt;</code> when possible. For example, for Value of type <code>std::pair&lt;Box, int&gt;</code>, the default IndexableGetter translates from <code>std::pair&lt;Box, int&gt; const&amp;</code> to <code>Box const&amp;</code>.</dd></dl>
<dl class="user"><dt><b>EqualTo</b></dt><dd>The object of EqualTo type compares Values and returns <code>true</code> if they are equal. It's similar to <code>std::equal_to&lt;&gt;</code>. The default EqualTo returns the result of <code>boost::geometry::equals()</code> for types adapted to some Geometry concept defined in Boost.Geometry and the result of <code>operator==</code> for other types. Components of Pairs and Tuples are compared left-to-right.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Value</td><td>The type of objects stored in the container. </td></tr>
    <tr><td class="paramname">Parameters</td><td>Compile-time parameters. </td></tr>
    <tr><td class="paramname">IndexableGetter</td><td>The function object extracting Indexable from Value. </td></tr>
    <tr><td class="paramname">EqualTo</td><td>The function object comparing objects of type Value. </td></tr>
    <tr><td class="paramname">Allocator</td><td>The allocator used to allocate/deallocate memory, construct/destroy nodes and Values. </td></tr>
  </table>
  </dd>
</dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a55d5fd5d205df08db5267253689ccf0c"></a><!-- doxytag: member="boost::geometry::index::rtree::rtree" ref="a55d5fd5d205df08db5267253689ccf0c" args="(parameters_type const &amp;parameters=parameters_type(), indexable_getter const &amp;getter=indexable_getter(), value_equal const &amp;equal=value_equal())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>parameters</em> = <code><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a> const &amp;&#160;</td>
          <td class="paramname"><em>getter</em> = <code><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a> const &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The parameters object. </td></tr>
    <tr><td class="paramname">getter</td><td>The function object extracting Indexable from Value. </td></tr>
    <tr><td class="paramname">equal</td><td>The function object comparing Values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd>If allocator default constructor throws. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a6b696d4855cbf1866196fe058c3a87"></a><!-- doxytag: member="boost::geometry::index::rtree::rtree" ref="a1a6b696d4855cbf1866196fe058c3a87" args="(parameters_type const &amp;parameters, indexable_getter const &amp;getter, value_equal const &amp;equal, allocator_type const &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a> const &amp;&#160;</td>
          <td class="paramname"><em>getter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a> const &amp;&#160;</td>
          <td class="paramname"><em>equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The parameters object. </td></tr>
    <tr><td class="paramname">getter</td><td>The function object extracting Indexable from Value. </td></tr>
    <tr><td class="paramname">equal</td><td>The function object comparing Values. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd>If allocator copy constructor throws. </dd></dl>

</div>
</div>
<a class="anchor" id="a037f17d8a1dfa4a818ff471dec61c912"></a><!-- doxytag: member="boost::geometry::index::rtree::rtree" ref="a037f17d8a1dfa4a818ff471dec61c912" args="(Iterator first, Iterator last, parameters_type const &amp;parameters=parameters_type(), indexable_getter const &amp;getter=indexable_getter(), value_equal const &amp;equal=value_equal(), allocator_type const &amp;allocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>parameters</em> = <code><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a> const &amp;&#160;</td>
          <td class="paramname"><em>getter</em> = <code><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a> const &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The constructor. </p>
<p>The tree is created using packing algorithm.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of Values. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of Values. </td></tr>
    <tr><td class="paramname">parameters</td><td>The parameters object. </td></tr>
    <tr><td class="paramname">getter</td><td>The function object extracting Indexable from Value. </td></tr>
    <tr><td class="paramname">equal</td><td>The function object comparing Values. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If allocator copy constructor throws. </li>
<li>If Value copy constructor or copy assignment throws. </li>
<li>If allocation throws or returns invalid value. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7b96b715c52ddc13d7a81db344825848"></a><!-- doxytag: member="boost::geometry::index::rtree::rtree" ref="a7b96b715c52ddc13d7a81db344825848" args="(Range const &amp;rng, parameters_type const &amp;parameters=parameters_type(), indexable_getter const &amp;getter=indexable_getter(), value_equal const &amp;equal=value_equal(), allocator_type const &amp;allocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> </td>
          <td>(</td>
          <td class="paramtype">Range const &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>parameters</em> = <code><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a> const &amp;&#160;</td>
          <td class="paramname"><em>getter</em> = <code><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a> const &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The constructor. </p>
<p>The tree is created using packing algorithm.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>The range of Values. </td></tr>
    <tr><td class="paramname">parameters</td><td>The parameters object. </td></tr>
    <tr><td class="paramname">getter</td><td>The function object extracting Indexable from Value. </td></tr>
    <tr><td class="paramname">equal</td><td>The function object comparing Values. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If allocator copy constructor throws. </li>
<li>If Value copy constructor or copy assignment throws. </li>
<li>If allocation throws or returns invalid value. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af8db72811d2be53c409240204e63fb5a"></a><!-- doxytag: member="boost::geometry::index::rtree::~rtree" ref="af8db72811d2be53c409240204e63fb5a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::~<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The destructor. </p>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a826fc3236e181ad718d5283e95d7866f"></a><!-- doxytag: member="boost::geometry::index::rtree::rtree" ref="a826fc3236e181ad718d5283e95d7866f" args="(rtree const &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The copy constructor. </p>
<p>It uses parameters, translator and allocator from the source tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The rtree which content will be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If allocator copy constructor throws. </li>
<li>If Value copy constructor throws. </li>
<li>If allocation throws or returns invalid value. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a72b6b75e083eea2ed26f54d4a2265375"></a><!-- doxytag: member="boost::geometry::index::rtree::rtree" ref="a72b6b75e083eea2ed26f54d4a2265375" args="(rtree const &amp;src, allocator_type const &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The copy constructor. </p>
<p>It uses Parameters and translator from the source tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The rtree which content will be copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator which will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If allocator copy constructor throws. </li>
<li>If Value copy constructor throws. </li>
<li>If allocation throws or returns invalid value. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa8b27db8cb783282ab5274e6769da26a"></a><!-- doxytag: member="boost::geometry::index::rtree::rtree" ref="aa8b27db8cb783282ab5274e6769da26a" args="(rtree &amp;&amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The moving constructor. </p>
<p>It uses parameters, translator and allocator from the source tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The rtree which content will be moved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a8508c4236d17ff39a1caef058aac8486"></a><!-- doxytag: member="boost::geometry::index::rtree::rtree" ref="a8508c4236d17ff39a1caef058aac8486" args="(rtree &amp;&amp;src, allocator_type const &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The moving constructor. </p>
<p>It uses parameters and translator from the source tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The rtree which content will be moved. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If allocator copy constructor throws. </li>
<li>If Value copy constructor throws (only if allocators aren't equal). </li>
<li>If allocation throws or returns invalid value (only if allocators aren't equal). </li>
</ul>
</dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a23219a7705ac491862c67be8baa34f0d"></a><!-- doxytag: member="boost::geometry::index::rtree::begin" ref="a23219a7705ac491862c67be8baa34f0d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a701f65f0d6cf2e8b7be7f1c4b8fb7fde">const_iterator</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a23219a7705ac491862c67be8baa34f0d">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the iterator pointing at the begin of the rtree values range. </p>
<p>This method returns the iterator which may be used to iterate over all values stored in the rtree.</p>
<dl class="user"><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">
    // Copy all values into the vector
    std::copy(tree.begin(), tree.end(), std::back_inserter(vec));

    for ( Rtree::const_iterator it = tree.begin() ; it != tree.end() ; ++it )
    {
        // do something with value
    }

    // C++11 (auto)
    for ( auto it = tree.begin() ; it != tree.end() ; ++it )
    {
        // do something with value
    }

    // C++14 (generic lambda expression)
    std::for_each(tree.begin(), tree.end(), [](auto const&amp; val){
        // do something with value
    })
    </pre></div></dd></dl>
<dl class="user"><dt><b>Iterator category</b></dt><dd>ForwardIterator</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>If allocation throws.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The modification of the rtree may invalidate the iterators.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The iterator pointing at the begin of the range. </dd></dl>

</div>
</div>
<a class="anchor" id="a0dad06d0f117f45ed54b5c123cb41d6e"></a><!-- doxytag: member="boost::geometry::index::rtree::bounds" ref="a0dad06d0f117f45ed54b5c123cb41d6e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a12e80f9da4c68e0e687f1c2012321147">bounds_type</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a0dad06d0f117f45ed54b5c123cb41d6e">bounds</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the box able to contain all values stored in the container. </p>
<p>Returns the box able to contain all values stored in the container. If the container is empty the result of <code>geometry::assign_inverse()</code> is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The box able to contain all values stored in the container or an invalid box if there are no values in the container.</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bec40977c175983f585c4488cf8fe3c"></a><!-- doxytag: member="boost::geometry::index::rtree::clear" ref="a1bec40977c175983f585c4488cf8fe3c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a1bec40977c175983f585c4488cf8fe3c">clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all values stored in the container. </p>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa834c241c191ac9de67f134564f36fa"></a><!-- doxytag: member="boost::geometry::index::rtree::count" ref="aaa834c241c191ac9de67f134564f36fa" args="(ValueOrIndexable const &amp;vori) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueOrIndexable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#aaa834c241c191ac9de67f134564f36fa">count</a> </td>
          <td>(</td>
          <td class="paramtype">ValueOrIndexable const &amp;&#160;</td>
          <td class="paramname"><em>vori</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count Values or Indexables stored in the container. </p>
<p>For indexable_type it returns the number of values which indexables equals the parameter. For value_type it returns the number of values which equals the parameter.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vori</td><td>The value or indexable which will be counted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of values found.</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5302ce1c26105d722aac20793e83f0e"></a><!-- doxytag: member="boost::geometry::index::rtree::empty" ref="aa5302ce1c26105d722aac20793e83f0e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#aa5302ce1c26105d722aac20793e83f0e">empty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query if the container is empty. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the container is empty.</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a513f1bd9dfcd022acb208e62115b29b1"></a><!-- doxytag: member="boost::geometry::index::rtree::end" ref="a513f1bd9dfcd022acb208e62115b29b1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a701f65f0d6cf2e8b7be7f1c4b8fb7fde">const_iterator</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a513f1bd9dfcd022acb208e62115b29b1">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the iterator pointing at the end of the rtree values range. </p>
<p>This method returns the iterator which may be compared with the iterator returned by <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a23219a7705ac491862c67be8baa34f0d" title="Returns the iterator pointing at the begin of the rtree values range.">begin()</a> in order to check if the iteration has ended.</p>
<dl class="user"><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">
    for ( Rtree::const_iterator it = tree.begin() ; it != tree.end() ; ++it )
    {
        // do something with value
    }

    // C++11 (lambda expression)
    std::for_each(tree.begin(), tree.end(), [](value_type const&amp; val){
        // do something with value
    })
    </pre></div></dd></dl>
<dl class="user"><dt><b>Iterator category</b></dt><dd>ForwardIterator</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The modification of the rtree may invalidate the iterators.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The iterator pointing at the end of the range. </dd></dl>

</div>
</div>
<a class="anchor" id="a17d9cef211feb7f674a5b4602f4cc81e"></a><!-- doxytag: member="boost::geometry::index::rtree::get_allocator" ref="a17d9cef211feb7f674a5b4602f4cc81e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ab6618b5c7e88ed70533233fbac0f5b2e">allocator_type</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a17d9cef211feb7f674a5b4602f4cc81e">get_allocator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns allocator used by the rtree. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocator.</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>If allocator copy constructor throws. </dd></dl>

</div>
</div>
<a class="anchor" id="af391fd642a218c5fb10fc68d643a62b5"></a><!-- doxytag: member="boost::geometry::index::rtree::indexable_get" ref="af391fd642a218c5fb10fc68d643a62b5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a43a7adb311cafc08e23010ccb4e97fb5">indexable_getter</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#af391fd642a218c5fb10fc68d643a62b5">indexable_get</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns function retrieving Indexable from Value. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The indexable_getter object.</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="ad47980467e66b8644df18a480dbf9d86"></a><!-- doxytag: member="boost::geometry::index::rtree::insert" ref="ad47980467e66b8644df18a480dbf9d86" args="(value_type const &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad47980467e66b8644df18a480dbf9d86">insert</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a5761a41d87b93d4fd548ecb6600ae757">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a value to the index. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value which will be stored in the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If Value copy constructor or copy assignment throws. </li>
<li>If allocation throws or returns invalid value.</li>
</ul>
</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. </dd></dl>

</div>
</div>
<a class="anchor" id="a60d4c8790fd8810ff8b57f049e6bed8d"></a><!-- doxytag: member="boost::geometry::index::rtree::insert" ref="a60d4c8790fd8810ff8b57f049e6bed8d" args="(Iterator first, Iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad47980467e66b8644df18a480dbf9d86">insert</a> </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a range of values to the index. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of values. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If Value copy constructor or copy assignment throws. </li>
<li>If allocation throws or returns invalid value.</li>
</ul>
</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. </dd></dl>

</div>
</div>
<a class="anchor" id="a5db294b14ebf1319edcfc92e78c8167e"></a><!-- doxytag: member="boost::geometry::index::rtree::insert" ref="a5db294b14ebf1319edcfc92e78c8167e" args="(ConvertibleOrRange const &amp;conv_or_rng)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConvertibleOrRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad47980467e66b8644df18a480dbf9d86">insert</a> </td>
          <td>(</td>
          <td class="paramtype">ConvertibleOrRange const &amp;&#160;</td>
          <td class="paramname"><em>conv_or_rng</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a value created using convertible object or a range of values to the index. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conv_or_rng</td><td>An object of type convertible to value_type or a range of values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If Value copy constructor or copy assignment throws. </li>
<li>If allocation throws or returns invalid value.</li>
</ul>
</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0db5e9e41e1553f944b7e740dbbb883"></a><!-- doxytag: member="boost::geometry::index::rtree::operator=" ref="ad0db5e9e41e1553f944b7e740dbbb883" args="(rtree const &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a>&amp; <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The assignment operator. </p>
<p>It uses parameters and translator from the source tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The rtree which content will be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If Value copy constructor throws. </li>
<li>If allocation throws. </li>
<li>If allocation throws or returns invalid value. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af0bf9622ed3e901580b73ed39b746fb7"></a><!-- doxytag: member="boost::geometry::index::rtree::operator=" ref="af0bf9622ed3e901580b73ed39b746fb7" args="(rtree &amp;&amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a>&amp; <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The moving assignment. </p>
<p>It uses parameters and translator from the source tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The rtree which content will be moved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd>Only if allocators aren't equal. <ul>
<li>If Value copy constructor throws. </li>
<li>If allocation throws or returns invalid value. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9076baef90a3a9c6018871fa25115a73"></a><!-- doxytag: member="boost::geometry::index::rtree::parameters" ref="a9076baef90a3a9c6018871fa25115a73" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a80db5532eb59f7a809bd44ded265eb17">parameters_type</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a9076baef90a3a9c6018871fa25115a73">parameters</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns parameters. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The parameters object.</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a63d15f3b5b157a47045fcac3fec3b7a0"></a><!-- doxytag: member="boost::geometry::index::rtree::qbegin" ref="a63d15f3b5b157a47045fcac3fec3b7a0" args="(Predicates const &amp;predicates) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Predicates &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad144a7704ad878caaa84cda79b140855">const_query_iterator</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a63d15f3b5b157a47045fcac3fec3b7a0">qbegin</a> </td>
          <td>(</td>
          <td class="paramtype">Predicates const &amp;&#160;</td>
          <td class="paramname"><em>predicates</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a query iterator pointing at the begin of the query range. </p>
<p>This method returns an iterator which may be used to perform iterative queries. For the information about predicates which may be passed to this method see <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a7baa88eb4e7a5c640ab847513de45b3e" title="Finds values meeting passed predicates e.g. nearest to some Point and/or intersecting some Box...">query()</a>.</p>
<dl class="user"><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">
    for ( Rtree::const_query_iterator it = tree.qbegin(bgi::nearest(pt, 10000)) ;
          it != tree.qend() ; ++it )
    {
        // do something with value
        if ( has_enough_nearest_values() )
            break;
    }

    // C++11 (auto)
    for ( auto it = tree.qbegin(bgi::nearest(pt, 3)) ; it != tree.qend() ; ++it )
    {
        // do something with value
    }

    // C++14 (generic lambda expression)
    std::for_each(tree.qbegin(bgi::nearest(pt, 3)), tree.qend(), [](auto const&amp; val){
        // do something with value
    });
    </pre></div></dd></dl>
<dl class="user"><dt><b>Iterator category</b></dt><dd>ForwardIterator</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>If predicates copy throws. If allocation throws.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The modification of the rtree may invalidate the iterators.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">predicates</td><td>Predicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The iterator pointing at the begin of the query range. </dd></dl>

</div>
</div>
<a class="anchor" id="af3b16f4732fa8113c0b2187005182513"></a><!-- doxytag: member="boost::geometry::index::rtree::qend" ref="af3b16f4732fa8113c0b2187005182513" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad144a7704ad878caaa84cda79b140855">const_query_iterator</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#af3b16f4732fa8113c0b2187005182513">qend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a query iterator pointing at the end of the query range. </p>
<p>This method returns an iterator which may be used to check if the query has ended.</p>
<dl class="user"><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">
    for ( Rtree::const_query_iterator it = tree.qbegin(bgi::nearest(pt, 10000)) ;
          it != tree.qend() ; ++it )
    {
        // do something with value
        if ( has_enough_nearest_values() )
            break;
    }

    // C++11 (auto)
    for ( auto it = tree.qbegin(bgi::nearest(pt, 3)) ; it != tree.qend() ; ++it )
    {
        // do something with value
    }

    // C++14 (generic lambda expression)
    std::for_each(tree.qbegin(bgi::nearest(pt, 3)), tree.qend(), [](auto const&amp; val){
        // do something with value
    });
    </pre></div></dd></dl>
<dl class="user"><dt><b>Iterator category</b></dt><dd>ForwardIterator</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The modification of the rtree may invalidate the iterators.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The iterator pointing at the end of the query range. </dd></dl>

</div>
</div>
<a class="anchor" id="a7baa88eb4e7a5c640ab847513de45b3e"></a><!-- doxytag: member="boost::geometry::index::rtree::query" ref="a7baa88eb4e7a5c640ab847513de45b3e" args="(Predicates const &amp;predicates, OutIter out_it) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Predicates , typename OutIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a7baa88eb4e7a5c640ab847513de45b3e">query</a> </td>
          <td>(</td>
          <td class="paramtype">Predicates const &amp;&#160;</td>
          <td class="paramname"><em>predicates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutIter&#160;</td>
          <td class="paramname"><em>out_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds values meeting passed predicates e.g. nearest to some Point and/or intersecting some Box. </p>
<p>This query function performs spatial and k-nearest neighbor searches. It allows to pass a set of predicates. Values will be returned only if all predicates are met.</p>
<p><b>Spatial predicates</b></p>
<p>Spatial predicates may be generated by one of the functions listed below: </p>
<ul>
<li><code><a class="el" href="group__predicates.html#gac52a6557110425d4ece53fbd6f9ff866" title="Generate contains() predicate.">boost::geometry::index::contains()</a></code>, </li>
<li><code><a class="el" href="group__predicates.html#ga02dbb7cca47de0b921ef96af464d9590" title="Generate covered_by() predicate.">boost::geometry::index::covered_by()</a></code>, </li>
<li><code><a class="el" href="group__predicates.html#ga0e92e4a20dd19185584fe85847439108" title="Generate covers() predicate.">boost::geometry::index::covers()</a></code>, </li>
<li><code><a class="el" href="group__predicates.html#ga0aa114ab16f40c8caeb3338adba5d6da" title="Generate disjoint() predicate.">boost::geometry::index::disjoint()</a></code>, </li>
<li><code><a class="el" href="group__predicates.html#ga78cb2ef221b951867c591ffb51b7d8c5" title="Generate intersects() predicate.">boost::geometry::index::intersects()</a></code>, </li>
<li><code><a class="el" href="group__predicates.html#ga4a6d33e6f61ad5bff3bdee50a972d54b" title="Generate overlaps() predicate.">boost::geometry::index::overlaps()</a></code>, </li>
<li><code><a class="el" href="group__predicates.html#gaabce901b82af2aab10ebbd0dda12f4d5" title="Generate within() predicate.">boost::geometry::index::within()</a></code>,</li>
</ul>
<p>It is possible to negate spatial predicates: </p>
<ul>
<li><code>! <a class="el" href="group__predicates.html#gac52a6557110425d4ece53fbd6f9ff866" title="Generate contains() predicate.">boost::geometry::index::contains()</a></code>, </li>
<li><code>! <a class="el" href="group__predicates.html#ga02dbb7cca47de0b921ef96af464d9590" title="Generate covered_by() predicate.">boost::geometry::index::covered_by()</a></code>, </li>
<li><code>! <a class="el" href="group__predicates.html#ga0e92e4a20dd19185584fe85847439108" title="Generate covers() predicate.">boost::geometry::index::covers()</a></code>, </li>
<li><code>! <a class="el" href="group__predicates.html#ga0aa114ab16f40c8caeb3338adba5d6da" title="Generate disjoint() predicate.">boost::geometry::index::disjoint()</a></code>, </li>
<li><code>! <a class="el" href="group__predicates.html#ga78cb2ef221b951867c591ffb51b7d8c5" title="Generate intersects() predicate.">boost::geometry::index::intersects()</a></code>, </li>
<li><code>! <a class="el" href="group__predicates.html#ga4a6d33e6f61ad5bff3bdee50a972d54b" title="Generate overlaps() predicate.">boost::geometry::index::overlaps()</a></code>, </li>
<li><code>! <a class="el" href="group__predicates.html#gaabce901b82af2aab10ebbd0dda12f4d5" title="Generate within() predicate.">boost::geometry::index::within()</a></code></li>
</ul>
<p><b>Satisfies predicate</b></p>
<p>This is a special kind of predicate which allows to pass a user-defined function or function object which checks if Value should be returned by the query. It's generated by: </p>
<ul>
<li><code><a class="el" href="group__predicates.html#ga3213772dd3e54ad03340c2ca66b4f58c" title="Generate satisfies() predicate.">boost::geometry::index::satisfies()</a></code>.</li>
</ul>
<p><b>Nearest predicate</b></p>
<p>If the nearest predicate is passed a k-nearest neighbor search will be performed. This query will result in returning k values to the output iterator. Only one nearest predicate may be passed to the query. It may be generated by: </p>
<ul>
<li><code><a class="el" href="group__predicates.html#ga8772d9d3e5b12b3292f7d94d47310e3e" title="Generate nearest() predicate.">boost::geometry::index::nearest()</a></code>.</li>
</ul>
<p><b>Connecting predicates</b></p>
<p>Predicates may be passed together connected with <code>operator&amp;&amp;()</code>.</p>
<dl class="user"><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment">
    // return elements intersecting box
    tree.query(bgi::intersects(box), std::back_inserter(result));
    // return elements intersecting poly but not within box
    tree.query(bgi::intersects(poly) &amp;&amp; !bgi::within(box), std::back_inserter(result));
    // return elements overlapping box and meeting my_fun unary predicate
    tree.query(bgi::overlaps(box) &amp;&amp; bgi::satisfies(my_fun), std::back_inserter(result));
    // return 5 elements nearest to pt and elements are intersecting box
    tree.query(bgi::nearest(pt, 5) &amp;&amp; bgi::intersects(box), std::back_inserter(result));

    // For each found value do_something (it is a type of function object)
    tree.query(bgi::intersects(box),
               boost::make_function_output_iterator(do_something()));

    // For each value stored in the rtree do_something
    // always_true is a type of function object always returning true
    tree.query(bgi::satisfies(always_true()),
               boost::make_function_output_iterator(do_something()));

    // C++11 (lambda expression)
    tree.query(bgi::intersects(box),
               boost::make_function_output_iterator([](value_type const&amp; val){
                   // do something
               }));

    // C++14 (generic lambda expression)
    tree.query(bgi::intersects(box),
               boost::make_function_output_iterator([](auto const&amp; val){
                   // do something
               }));
    </pre></div></dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>If Value copy constructor or copy assignment throws. If predicates copy throws.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Only one <code><a class="el" href="group__predicates.html#ga8772d9d3e5b12b3292f7d94d47310e3e" title="Generate nearest() predicate.">nearest()</a></code> perdicate may be passed to the query. Passing more of them results in compile-time error.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">predicates</td><td>Predicates. </td></tr>
    <tr><td class="paramname">out_it</td><td>The output iterator, e.g. generated by std::back_inserter().</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of values found. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ce933b0b833faec5349bfc27bde15d4"></a><!-- doxytag: member="boost::geometry::index::rtree::remove" ref="a1ce933b0b833faec5349bfc27bde15d4" args="(value_type const &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a1ce933b0b833faec5349bfc27bde15d4">remove</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a5761a41d87b93d4fd548ecb6600ae757">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a value from the container. </p>
<p>In contrast to the <code>std::set</code> or <code>std::map erase()</code> method this method removes only one value from the container.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value which will be removed from the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the value was removed, 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If Value copy constructor or copy assignment throws. </li>
<li>If allocation throws or returns invalid value.</li>
</ul>
</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. </dd></dl>

</div>
</div>
<a class="anchor" id="aa97084231d17564a94f0142d095cecaa"></a><!-- doxytag: member="boost::geometry::index::rtree::remove" ref="aa97084231d17564a94f0142d095cecaa" args="(Iterator first, Iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a1ce933b0b833faec5349bfc27bde15d4">remove</a> </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a range of values from the container. </p>
<p>In contrast to the <code>std::set</code> or <code>std::map erase()</code> method it doesn't take iterators pointing to values stored in this container. It removes values equal to these passed as a range. Furthermore this method removes only one value for each one passed in the range, not all equal values.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of values. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of removed values.</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If Value copy constructor or copy assignment throws. </li>
<li>If allocation throws or returns invalid value.</li>
</ul>
</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. </dd></dl>

</div>
</div>
<a class="anchor" id="a320cd1861ba7b43364ed53e1f93a4411"></a><!-- doxytag: member="boost::geometry::index::rtree::remove" ref="a320cd1861ba7b43364ed53e1f93a4411" args="(ConvertibleOrRange const &amp;conv_or_rng)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConvertibleOrRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a1ce933b0b833faec5349bfc27bde15d4">remove</a> </td>
          <td>(</td>
          <td class="paramtype">ConvertibleOrRange const &amp;&#160;</td>
          <td class="paramname"><em>conv_or_rng</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove value corresponding to an object convertible to it or a range of values from the container. </p>
<p>In contrast to the <code>std::set</code> or <code>std::map erase()</code> method it removes values equal to these passed as a range. Furthermore, this method removes only one value for each one passed in the range, not all equal values.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conv_or_rng</td><td>The object of type convertible to value_type or a range of values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of removed values.</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd><ul>
<li>If Value copy constructor or copy assignment throws. </li>
<li>If allocation throws or returns invalid value.</li>
</ul>
</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9f152c8c96525e3735b81635d8171b1"></a><!-- doxytag: member="boost::geometry::index::rtree::size" ref="ac9f152c8c96525e3735b81635d8171b1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#acc1f90d7b70afebc58107c523ece5cd5">size_type</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ac9f152c8c96525e3735b81635d8171b1">size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of stored values. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of stored values.</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="aedb719dfece91d298e9ee56878524c9b"></a><!-- doxytag: member="boost::geometry::index::rtree::swap" ref="aedb719dfece91d298e9ee56878524c9b" args="(rtree &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#aedb719dfece91d298e9ee56878524c9b">swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps contents of two rtrees. </p>
<p>Parameters, translator and allocators are swapped as well.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The rtree which content will be swapped with this rtree content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Throws</b></dt><dd>If allocators swap throws. </dd></dl>

</div>
</div>
<a class="anchor" id="a16424563d0973960ac01f7a1969eeebe"></a><!-- doxytag: member="boost::geometry::index::rtree::value_eq" ref="a16424563d0973960ac01f7a1969eeebe" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename Parameters, typename IndexableGetter = index::indexable&lt;Value&gt;, typename EqualTo = index::equal_to&lt;Value&gt;, typename Allocator = std::allocator&lt;Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#ad8fe544de514014a1bd87ea1b881ff9b">value_equal</a> <a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html">boost::geometry::index::rtree</a>&lt; Value, Parameters, IndexableGetter, EqualTo, Allocator &gt;::<a class="el" href="classboost_1_1geometry_1_1index_1_1rtree.html#a16424563d0973960ac01f7a1969eeebe">value_eq</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns function comparing Values. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value_equal function.</dd></dl>
<dl class="user"><dt><b>Throws</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/boostorg/boost/boost/geometry/index/<a class="el" href="rtree_8hpp_source.html">rtree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Thu May 5 2016 21:18:04 for Boost.Geometry.Index by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
