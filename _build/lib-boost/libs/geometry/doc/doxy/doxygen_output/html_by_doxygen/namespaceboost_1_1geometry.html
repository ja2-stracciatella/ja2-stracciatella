<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.Geometry (aka GGL, Generic Geometry Library)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.Geometry" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceboost.html">boost</a>      </li>
      <li class="navelem"><a class="el" href="namespaceboost_1_1geometry.html">geometry</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">boost::geometry Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1traits.html">traits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1cs.html">cs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1srs.html">srs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1resolve__variant.html">resolve_variant</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1resolve__strategy.html">resolve_strategy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1info.html">info</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1nyi.html">nyi</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1detail.html">detail</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1core__dispatch.html">core_dispatch</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1dispatch.html">dispatch</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1strategy.html">strategy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1de9im.html">de9im</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1concept.html">concept</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1model.html">model</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1detail__dispatch.html">detail_dispatch</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1fusion__adapt__detail.html">fusion_adapt_detail</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1policies.html">policies</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1util.html">util</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1math.html">math</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry_1_1range.html">range</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1add__const__if__c.html">add_const_if_c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function to define a const or non const type.  <a href="structboost_1_1geometry_1_1add__const__if__c.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1areal__tag.html">areal_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For areal types (polygon, multi_polygon, box, ring)  <a href="structboost_1_1geometry_1_1areal__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1box__tag.html">box_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience 2D or 3D box (mbr / aabb) identifying tag.  <a href="structboost_1_1geometry_1_1box__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1box__view.html">box_view</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a box behave like a ring or a range.  <a href="structboost_1_1geometry_1_1box__view.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1cartesian__tag.html">cartesian_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag indicating Cartesian coordinate system family (cartesian,epsg)  <a href="structboost_1_1geometry_1_1cartesian__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1centroid__exception.html">centroid_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Centroid Exception.  <a href="classboost_1_1geometry_1_1centroid__exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1closeable__view.html">closeable_view</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">View on a range, either closing it or leaving it as it is.  <a href="structboost_1_1geometry_1_1closeable__view.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1closing__iterator.html">closing_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator which iterates through a range, but adds first element at end of the range.  <a href="structboost_1_1geometry_1_1closing__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1closure.html">closure</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction defining [*value] as the closure (clockwise, counterclockwise) of the \3.  <a href="structboost_1_1geometry_1_1closure.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1closure__as__bool.html">closure_as_bool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1closure__as__bool_3_01closed_01_4.html">closure_as_bool&lt; closed &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1closure__as__bool_3_01open_01_4.html">closure_as_bool&lt; open &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1collected__vector.html">collected_vector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1comparable__distance__result.html">comparable_distance_result</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function defining return type of comparable_distance function.  <a href="structboost_1_1geometry_1_1comparable__distance__result.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1comparable__distance__result_3_01_geometry1_00_01_geometry2_00_01void_01_4.html">comparable_distance_result&lt; Geometry1, Geometry2, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1compress__variant.html">compress_variant</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that takes a boost::variant type and tries to minimize it by doing the following:  <a href="structboost_1_1geometry_1_1compress__variant.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1concatenate__iterator.html">concatenate_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1coordinate__system.html">coordinate_system</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction defining [*type] as the coordinate system (cartesian, spherical, etc) of the \3.  <a href="structboost_1_1geometry_1_1coordinate__system.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1coordinate__type.html">coordinate_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction defining [*type] as the coordinate type (int, float, double, etc) of the \3.  <a href="structboost_1_1geometry_1_1coordinate__type.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1cs__tag.html">cs_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function returning coordinate system tag (cs family) of any geometry.  <a href="structboost_1_1geometry_1_1cs__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1default__area__result.html">default_area_result</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function defining return type of area function, using the default strategy.  <a href="structboost_1_1geometry_1_1default__area__result.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1default__comparable__distance__result.html">default_comparable_distance_result</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function defining return type of comparable_distance function.  <a href="structboost_1_1geometry_1_1default__comparable__distance__result.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1default__distance__result.html">default_distance_result</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function defining return type of distance function.  <a href="structboost_1_1geometry_1_1default__distance__result.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1default__length__result.html">default_length_result</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function defining return type of length function.  <a href="structboost_1_1geometry_1_1default__length__result.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1default__strategy.html">default_strategy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1degree.html">degree</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit of plane angle: Degrees.  <a href="structboost_1_1geometry_1_1degree.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1dimension.html">dimension</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction defining [*value] as the number of coordinates (the number of axes of any geometry) of the \3.  <a href="structboost_1_1geometry_1_1dimension.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1distance__result.html">distance_result</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function defining return type of distance function.  <a href="structboost_1_1geometry_1_1distance__result.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1distance__result_3_01_geometry1_00_01_geometry2_00_01void_01_4.html">distance_result&lt; Geometry1, Geometry2, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1empty__input__exception.html">empty_input_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty Input Exception.  <a href="classboost_1_1geometry_1_1empty__input__exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1equal__to.html">equal_to</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal To functor, to compare if points are equal.  <a href="structboost_1_1geometry_1_1equal__to.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1ever__circling__iterator.html">ever_circling_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator which ever circles through a range.  <a href="structboost_1_1geometry_1_1ever__circling__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1ever__circling__range__iterator.html">ever_circling_range_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1exception.html">exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base exception class for Boost.Geometry algorithms.  <a href="classboost_1_1geometry_1_1exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1flatten__iterator.html">flatten_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1fp__coordinate__type.html">fp_coordinate_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1fraction__type.html">fraction_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1geographic__tag.html">geographic_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag indicating Geographic coordinate system family (geographic)  <a href="structboost_1_1geometry_1_1geographic__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1geometry__collection__tag.html">geometry_collection_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">OGC Geometry Collection identifying tag.  <a href="structboost_1_1geometry_1_1geometry__collection__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1geometry__id.html">geometry_id</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function returning the id of a geometry type.  <a href="structboost_1_1geometry_1_1geometry__id.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1geometry__not__recognized__tag.html">geometry_not_recognized_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"default" tag  <a href="structboost_1_1geometry_1_1geometry__not__recognized__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1greater.html">greater</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater functor.  <a href="structboost_1_1geometry_1_1greater.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1helper__geometry.html">helper_geometry</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1identity__view.html">identity_view</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">View on a range, not modifying anything.  <a href="structboost_1_1geometry_1_1identity__view.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1inconsistent__turns__exception.html">inconsistent_turns_exception</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1interior__return__type.html">interior_return_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1interior__type.html">interior_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction defining [*type] as the <a class="el" href="structboost_1_1geometry_1_1interior__type.html" title="Metafunction defining [*type] as the interior_type (container type of inner rings) of the \3...">interior_type</a> (container type of inner rings) of the \3.  <a href="structboost_1_1geometry_1_1interior__type.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1invalid__input__exception.html">invalid_input_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid Input Exception.  <a href="classboost_1_1geometry_1_1invalid__input__exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1is__areal.html">is_areal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function defining "true" for areal types (box, (multi)polygon, ring),.  <a href="structboost_1_1geometry_1_1is__areal.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1is__radian.html">is_radian</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function to verify if a coordinate system is radian.  <a href="structboost_1_1geometry_1_1is__radian.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1less.html">less</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Less functor, to sort points in ascending order.  <a href="structboost_1_1geometry_1_1less.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1linear__tag.html">linear_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For linear types (linestring, multi-linestring, segment)  <a href="structboost_1_1geometry_1_1linear__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1linestring__tag.html">linestring_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">OGC Linestring identifying tag.  <a href="structboost_1_1geometry_1_1linestring__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1multi__linestring__tag.html">multi_linestring_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">OGC Multi linestring identifying tag.  <a href="structboost_1_1geometry_1_1multi__linestring__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1multi__point__tag.html">multi_point_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">OGC Multi point identifying tag.  <a href="structboost_1_1geometry_1_1multi__point__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1multi__polygon__tag.html">multi_polygon_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">OGC Multi polygon identifying tag.  <a href="structboost_1_1geometry_1_1multi__polygon__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1multi__tag.html">multi_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For multiple-geometries (multi_point, multi_linestring, multi_polygon)  <a href="structboost_1_1geometry_1_1multi__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1not__implemented.html">not_implemented</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1order__as__direction.html">order_as_direction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1order__as__direction_3_01clockwise_01_4.html">order_as_direction&lt; clockwise &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1order__as__direction_3_01counterclockwise_01_4.html">order_as_direction&lt; counterclockwise &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1overlay__invalid__input__exception.html">overlay_invalid_input_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overlay Invalid Input Exception.  <a href="classboost_1_1geometry_1_1overlay__invalid__input__exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1parameter__type__of.html">parameter_type_of</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function selecting a parameter type of a (member) function, by index.  <a href="structboost_1_1geometry_1_1parameter__type__of.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1partition.html">partition</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1point__iterator.html">point_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1point__order.html">point_order</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction defining [*value] as the point order (clockwise, counterclockwise) of the \3.  <a href="structboost_1_1geometry_1_1point__order.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1point__reverse__iterator.html">point_reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1point__tag.html">point_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">OGC Point identifying tag.  <a href="structboost_1_1geometry_1_1point__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1point__type.html">point_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction defining [*type] as the <a class="el" href="structboost_1_1geometry_1_1point__type.html" title="Metafunction defining [*type] as the point_type of the \3.">point_type</a> of the \3.  <a href="structboost_1_1geometry_1_1point__type.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1point__type_3_01boost_1_1variant_3_01_b_o_o_s_t___v_a_r_i_a_n_t___e_ne779fef8428519fc7733ab4259a48372.html">point_type&lt; boost::variant&lt; BOOST_VARIANT_ENUM_PARAMS(T)&gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1pointlike__tag.html">pointlike_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For point-like types (point, multi_point)  <a href="structboost_1_1geometry_1_1pointlike__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1polygon__tag.html">polygon_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">OGC Polygon identifying tag.  <a href="structboost_1_1geometry_1_1polygon__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1polygonal__tag.html">polygonal_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1promote__floating__point.html">promote_floating_point</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function converting, if necessary, to "a floating point" type.  <a href="structboost_1_1geometry_1_1promote__floating__point.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1promote__integral.html">promote_integral</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function to define an integral type with size than is (roughly) twice the bit size of T.  <a href="classboost_1_1geometry_1_1promote__integral.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1promote__integral_3_01_t_00_01_promote_unsigned_to_unsigned_00_01_use_checked_integer_00_01false_01_4.html">promote_integral&lt; T, PromoteUnsignedToUnsigned, UseCheckedInteger, false &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1radian.html">radian</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit of plane angle: Radians.  <a href="structboost_1_1geometry_1_1radian.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1radius__type.html">radius_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to get the type of radius of a circle / sphere / ellipse / etc.  <a href="structboost_1_1geometry_1_1radius__type.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1read__wkt__exception.html">read_wkt_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception showing things wrong with WKT parsing.  <a href="structboost_1_1geometry_1_1read__wkt__exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1reverse__dispatch.html">reverse_dispatch</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1reversible__view.html">reversible_view</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">View on a range, reversing direction if necessary.  <a href="structboost_1_1geometry_1_1reversible__view.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1ring__identifier.html">ring_identifier</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1ring__return__type.html">ring_return_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1ring__tag.html">ring_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience (linear) ring identifying tag.  <a href="structboost_1_1geometry_1_1ring__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1ring__type.html">ring_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction defining [*type] as the <a class="el" href="structboost_1_1geometry_1_1ring__type.html" title="Metafunction defining [*type] as the ring_type of the \3.">ring_type</a> of the \3.  <a href="structboost_1_1geometry_1_1ring__type.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1section.html">section</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing section information.  <a href="structboost_1_1geometry_1_1section.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1sections.html">sections</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing a collection of sections.  <a href="structboost_1_1geometry_1_1sections.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1segment__identifier.html">segment_identifier</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1segment__intersection__info.html">segment_intersection_info</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1segment__intersection__points.html">segment_intersection_points</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return-type for segment-intersection  <a href="structboost_1_1geometry_1_1segment__intersection__points.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1segment__iterator.html">segment_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1segment__tag.html">segment_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience segment (2-points) identifying tag.  <a href="structboost_1_1geometry_1_1segment__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1segment__view.html">segment_view</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a segment behave like a linestring or a range.  <a href="structboost_1_1geometry_1_1segment__view.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1select__calculation__type.html">select_calculation_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function selecting the "calculation" type.  <a href="structboost_1_1geometry_1_1select__calculation__type.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1select__calculation__type__alt.html">select_calculation_type_alt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1select__coordinate__type.html">select_coordinate_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function selecting the most precise coordinate type of two geometries.  <a href="structboost_1_1geometry_1_1select__coordinate__type.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1select__coordinate__type_3_01_t1_00_01_t2_00_01void_01_4.html">select_coordinate_type&lt; T1, T2, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1select__coordinate__type_3_01_t1_00_01void_00_01void_01_4.html">select_coordinate_type&lt; T1, void, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1select__most__precise.html">select_most_precise</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function to select, of two types, the most accurate type for calculations.  <a href="structboost_1_1geometry_1_1select__most__precise.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1select__most__precise_3_01boost_1_1rational_3_01_t_01_4_00_01double_01_4.html">select_most_precise&lt; boost::rational&lt; T &gt;, double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1select__most__precise_3_01boost_1_1rational_3_01_t1_01_4_00_01boost_1_1rational_3_01_t2_01_4_01_4.html">select_most_precise&lt; boost::rational&lt; T1 &gt;, boost::rational&lt; T2 &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1select__most__precise_3_01_t1_00_01_t2_00_01void_01_4.html">select_most_precise&lt; T1, T2, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1select__most__precise_3_01_t1_00_01void_00_01void_01_4.html">select_most_precise&lt; T1, void, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1side__info.html">side_info</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classboost_1_1geometry_1_1side__info.html" title="Class side_info: small class wrapping for sides (-1,0,1)">side_info</a>: small class wrapping for sides (-1,0,1)  <a href="classboost_1_1geometry_1_1side__info.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1single__tag.html">single_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For single-geometries (point, linestring, polygon, box, ring, segment)  <a href="structboost_1_1geometry_1_1single__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1single__tag__of.html">single_tag_of</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function to get for a tag of a multi-geometry the tag of the corresponding single-geometry.  <a href="structboost_1_1geometry_1_1single__tag__of.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1single__tag__of_3_01detail_1_1buffer_1_1buffered__ring__collection__tag_01_4.html">single_tag_of&lt; detail::buffer::buffered_ring_collection_tag &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1spherical__equatorial__tag.html">spherical_equatorial_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag indicating Spherical equatorial coordinate system family.  <a href="structboost_1_1geometry_1_1spherical__equatorial__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1spherical__polar__tag.html">spherical_polar_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag indicating Spherical polar coordinate system family.  <a href="structboost_1_1geometry_1_1spherical__polar__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1spherical__tag.html">spherical_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag used for casting spherical/geographic coordinate systems.  <a href="structboost_1_1geometry_1_1spherical__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1srs__sphere__tag.html">srs_sphere_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For reference sphere defining parameters of spherical coordinate system.  <a href="structboost_1_1geometry_1_1srs__sphere__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1srs__spheroid__tag.html">srs_spheroid_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For reference spheroid defining parameters of geographical coordinate system.  <a href="structboost_1_1geometry_1_1srs__spheroid__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy__compare.html">strategy_compare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class binding a comparing strategy to a coordinate system.  <a href="structboost_1_1geometry_1_1strategy__compare.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy__convex__hull.html">strategy_convex_hull</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class binding a convex hull calculation strategy to a coordinate system.  <a href="structboost_1_1geometry_1_1strategy__convex__hull.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy__intersection.html">strategy_intersection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"compound strategy", containing a segment-intersection-strategy and a side-strategy  <a href="structboost_1_1geometry_1_1strategy__intersection.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy__intersection__empty.html">strategy_intersection_empty</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy__tag__distance__box__box.html">strategy_tag_distance_box_box</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy__tag__distance__point__box.html">strategy_tag_distance_point_box</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy__tag__distance__point__point.html">strategy_tag_distance_point_point</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy__tag__distance__point__segment.html">strategy_tag_distance_point_segment</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1svg__manipulator.html">svg_manipulator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic geometry template manipulator class, takes corresponding output class from traits class.  <a href="classboost_1_1geometry_1_1svg__manipulator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1svg__mapper.html">svg_mapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to create SVG maps.  <a href="classboost_1_1geometry_1_1svg__mapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1tag.html">tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction defining [*type] as the tag of the \3.  <a href="structboost_1_1geometry_1_1tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1tag__cast.html">tag_cast</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction defining a type being either the specified tag, or one of the specified basetags if the type inherits from them.  <a href="structboost_1_1geometry_1_1tag__cast.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1topological__dimension.html">topological_dimension</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function returning the topological dimension of a geometry.  <a href="structboost_1_1geometry_1_1topological__dimension.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1transform__variant.html">transform_variant</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that takes a Sequence type, an MPL lambda expression and an optional Inserter and returns a variant type over the same types as the initial variant type, each transformed using the lambda expression.  <a href="structboost_1_1geometry_1_1transform__variant.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1transform__variant_3_01variant_3_01_b_o_o_s_t___v_a_r_i_a_n_t___e_n_uf4ac33b8d803230c1237c41fa1e5e7a2.html">transform_variant&lt; variant&lt; BOOST_VARIANT_ENUM_PARAMS(T)&gt;, Op, boost::mpl::na &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-function that takes a boost::variant type and an MPL lambda expression and returns a variant type over the same types as the initial variant type, each transformed using the lambda expression.  <a href="structboost_1_1geometry_1_1transform__variant_3_01variant_3_01_b_o_o_s_t___v_a_r_i_a_n_t___e_n_uf4ac33b8d803230c1237c41fa1e5e7a2.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1turn__info__exception.html">turn_info_exception</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1volumetric__tag.html">volumetric_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For volume types (also box (?), polyhedron)  <a href="structboost_1_1geometry_1_1volumetric__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1geometry_1_1wkt__manipulator.html">wkt_manipulator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic geometry template manipulator class, takes corresponding output class from traits class.  <a href="classboost_1_1geometry_1_1wkt__manipulator.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::make_signed<br class="typebreak"/>
&lt; std::size_t &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#af0c576f82145cf6a02dcbf48b675a0c2">signed_size_type</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enum.html#ga7d33eca9a5389952bdf719972eb802b6">closure_selector</a> { <a class="el" href="group__enum.html#gga7d33eca9a5389952bdf719972eb802b6a684591bd018092efa79ef4b7731b7b05">open</a> =  0, 
<a class="el" href="group__enum.html#gga7d33eca9a5389952bdf719972eb802b6a17768d8af3fcc199a847d70965cbf9c5">closed</a> =  1, 
<a class="el" href="group__enum.html#gga7d33eca9a5389952bdf719972eb802b6a6dc65ac8f2b1a2fe71d912b634955510">closure_undertermined</a> =  -1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates options for defining if polygons are open or closed.  <a href="group__enum.html#ga7d33eca9a5389952bdf719972eb802b6">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a6424afc319f6cc4d4276a3900e966d3f">iterate_direction</a> { <a class="el" href="namespaceboost_1_1geometry.html#a6424afc319f6cc4d4276a3900e966d3fa8d759d0a3695aa617e26a1b3e101de29">iterate_forward</a>, 
<a class="el" href="namespaceboost_1_1geometry.html#a6424afc319f6cc4d4276a3900e966d3fa37daa24e30befa9d690d75fb5439718a">iterate_reverse</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for iterating a reversible_view in forward or reverse direction.  <a href="namespaceboost_1_1geometry.html#a6424afc319f6cc4d4276a3900e966d3f">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enum.html#ga0af1c124acb76f0892024d6d4ab2bc8c">order_selector</a> { <a class="el" href="group__enum.html#gga0af1c124acb76f0892024d6d4ab2bc8ca29458b1c5c6f01e41bc529cff7cdbec2">clockwise</a> =  1, 
<a class="el" href="group__enum.html#gga0af1c124acb76f0892024d6d4ab2bc8ca3a0efd1027a55cf48cfc5f9b57391468">counterclockwise</a> =  2, 
<a class="el" href="group__enum.html#gga0af1c124acb76f0892024d6d4ab2bc8ca0525b242b4e6519d79366300eca9f8da">order_undetermined</a> =  0
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates options for the order of points within polygons.  <a href="group__enum.html#ga0af1c124acb76f0892024d6d4ab2bc8c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a6b49ba0dbb14c37e57127f78a74e4921">overlay_type</a> { <a class="el" href="namespaceboost_1_1geometry.html#a6b49ba0dbb14c37e57127f78a74e4921a3742a61a84923702bd74f7a9461e2811">overlay_union</a>, 
<a class="el" href="namespaceboost_1_1geometry.html#a6b49ba0dbb14c37e57127f78a74e4921a12c38cf5208fc177a356826347ce494b">overlay_intersection</a>, 
<a class="el" href="namespaceboost_1_1geometry.html#a6b49ba0dbb14c37e57127f78a74e4921a08b4b940b7639685de488dd45589f020">overlay_difference</a>, 
<a class="el" href="namespaceboost_1_1geometry.html#a6b49ba0dbb14c37e57127f78a74e4921aef2f937a8d3cc99675b292b3508334ec">overlay_dissolve</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enum.html#ga8f93f0b6945c2ebb9f8a4bb53019a0d8">validity_failure_type</a> { <br/>
&#160;&#160;<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8ad799abcd8ac589c3e2500b7bbd1e6334">no_failure</a> =  0, 
<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8a9b7cd8df6dac3078c1dee47e7cbd0709">failure_few_points</a> =  10, 
<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8a73b19bdd2d80e479bfd6eeee2222da56">failure_wrong_topological_dimension</a> =  11, 
<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8a316c3e4c46e746c679525750e1050224">failure_spikes</a> =  12, 
<br/>
&#160;&#160;<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8a8af5f9ddd5eb89d21a7b27c7a182fceb">failure_duplicate_points</a> =  13, 
<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8ae58e4a68b24407dfba4145cd31dac494">failure_not_closed</a> =  20, 
<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8a15a1c5e9922f20f1b1e9bd12ab26e4bc">failure_self_intersections</a> =  21, 
<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8a4869614bcd34cce68f9e657c59ed3351">failure_wrong_orientation</a> =  22, 
<br/>
&#160;&#160;<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8ac69af9fa40a267af8911647df8f20946">failure_interior_rings_outside</a> =  30, 
<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8aaff1555fb9bc178d97c16f856b4bd282">failure_nested_interior_rings</a> =  31, 
<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8a6b9cbda3e4d8f0ada38b1927f1fdc96c">failure_disconnected_interior</a> =  32, 
<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8ace858388cbb736c3b6e83ffd8bbcd3b4">failure_intersecting_interiors</a> =  40, 
<br/>
&#160;&#160;<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8ac785a27ddd7417b1d3e525a435a6b1e5">failure_wrong_corner_order</a> =  50, 
<a class="el" href="group__enum.html#gga8f93f0b6945c2ebb9f8a4bb53019a0d8ab214fa3c0df702224cea9854f3b74f63">failure_invalid_coordinate</a> =  60
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the possible validity failure types for a geometry.  <a href="group__enum.html#ga8f93f0b6945c2ebb9f8a4bb53019a0d8">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point1 , typename Point2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic.html#ga4be53645868644bb6c5a455450d4d00e">add_point</a> (Point1 &amp;p1, Point2 const &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a point to another.  <a href="group__arithmetic.html#ga4be53645868644bb6c5a455450d4d00e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic.html#ga9c6f97e8be0aea5a989b10282cfdfcd1">add_value</a> (Point &amp;p, typename detail::param&lt; Point &gt;::type value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the same value to each coordinate of a point.  <a href="group__arithmetic.html#ga9c6f97e8be0aea5a989b10282cfdfcd1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename RangeOrPoint &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__append.html#gaa3a95c7738229a30f77562cb095b3699">append</a> (Geometry &amp;geometry, RangeOrPoint const &amp;range_or_point, int ring_index=-1, int multi_index=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends one or more points to a linestring, ring, polygon, multi-geometry.  <a href="group__append.html#gaa3a95c7738229a30f77562cb095b3699"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1default__area__result.html">default_area_result</a>&lt; Geometry &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__area.html#gaf7a1c34467f74f290d0b090adb27db62">area</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area of a geometry.  <a href="group__area.html#gaf7a1c34467f74f290d0b090adb27db62"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Strategy::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__area.html#ga59861901cb4e4b95a9e9bf82f3b4fa35">area</a> (Geometry const &amp;geometry, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area of a geometry using the specified strategy.  <a href="group__area.html#ga59861901cb4e4b95a9e9bf82f3b4fa35"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , int Dimensions&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a1847c5af13e0d19c3911421d3dab6c8d">assert_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">assert_dimension, enables compile-time checking if coordinate dimensions are as expected  <a href="#a1847c5af13e0d19c3911421d3dab6c8d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename G1 , typename G2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a13b8191ba1135e983690791efab43927">assert_dimension_equal</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">assert_dimension_equal, enables compile-time checking if coordinate dimensions of two geometries are equal  <a href="#a13b8191ba1135e983690791efab43927"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , int Dimensions&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a8de3fe127dab25ac9c46d611f78afafa">assert_dimension_greater_equal</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , int Dimensions&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ad4a36c4d293b80a01c84e37543b59456">assert_dimension_less_equal</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">assert_dimension, enables compile-time checking if coordinate dimensions are as expected  <a href="#ad4a36c4d293b80a01c84e37543b59456"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assign.html#ga384744a79ea0798e6def3a5dfa577af3">assign</a> (Geometry1 &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns one geometry to another geometry.  <a href="group__assign.html#ga384744a79ea0798e6def3a5dfa577af3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assign.html#gac2a4b4117524f23c5a04309182172375">assign_inverse</a> (Geometry &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">assign to a box inverse infinite  <a href="group__assign.html#gac2a4b4117524f23c5a04309182172375"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point1 , typename Point2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic.html#gaa595e4f32e834533b6299e08449afc6c">assign_point</a> (Point1 &amp;p1, Point2 const &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a point with another.  <a href="group__arithmetic.html#gaa595e4f32e834533b6299e08449afc6c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assign.html#ga1fdbc43645872ba459c455318706a925">assign_points</a> (Geometry &amp;geometry, Range const &amp;range)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of points to a linestring, ring or polygon.  <a href="group__assign.html#ga1fdbc43645872ba459c455318706a925"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic.html#gaa6e3bfda2aa04de193ee936a93663c7d">assign_value</a> (Point &amp;p, typename detail::param&lt; Point &gt;::type value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign each coordinate of a point the same value.  <a href="group__arithmetic.html#gaa6e3bfda2aa04de193ee936a93663c7d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assign.html#ga9ee6c10e38a19e8e52bf9a1fc5a19a05">assign_values</a> (Geometry &amp;geometry, Type const &amp;c1, Type const &amp;c2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign two coordinates to a geometry (usually a 2D point)  <a href="group__assign.html#ga9ee6c10e38a19e8e52bf9a1fc5a19a05"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assign.html#ga8ab0619796142e5d72e104349d827738">assign_values</a> (Geometry &amp;geometry, Type const &amp;c1, Type const &amp;c2, Type const &amp;c3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign three values to a geometry (usually a 3D point)  <a href="group__assign.html#ga8ab0619796142e5d72e104349d827738"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assign.html#gaaf4e377b4c3c28f42be6d76f2df0ce6b">assign_values</a> (Geometry &amp;geometry, Type const &amp;c1, Type const &amp;c2, Type const &amp;c3, Type const &amp;c4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign four values to a geometry (usually a box or segment)  <a href="group__assign.html#gaaf4e377b4c3c28f42be6d76f2df0ce6b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assign.html#gaa7e4279800ffd8a60d4b60bb2ee5c5a7">assign_zero</a> (Geometry &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">assign zero values to a box, point  <a href="group__assign.html#gaa7e4279800ffd8a60d4b60bb2ee5c5a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output , typename Distance &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga60bc23b4b5d3b572cf221714dae9a52a">buffer</a> (Input const &amp;geometry_in, Output &amp;geometry_out, Distance const &amp;<a class="el" href="group__distance.html#ga7d68c34d1ded4428903f906244b31da4">distance</a>, Distance const &amp;chord_length=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the buffer of a geometry.  <a href="group__buffer.html#ga60bc23b4b5d3b572cf221714dae9a52a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename GeometryIn , typename MultiPolygon , typename DistanceStrategy , typename SideStrategy , typename JoinStrategy , typename EndStrategy , typename PointStrategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf56bd07bd0dc7a7e4812223f23ddae7c">buffer</a> (GeometryIn const &amp;geometry_in, MultiPolygon &amp;geometry_out, DistanceStrategy const &amp;distance_strategy, SideStrategy const &amp;side_strategy, JoinStrategy const &amp;join_strategy, EndStrategy const &amp;end_strategy, PointStrategy const &amp;point_strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the buffer of a geometry.  <a href="group__buffer.html#gaf56bd07bd0dc7a7e4812223f23ddae7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Point , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__centroid.html#ga3ec2c5e245c42ffaf28f1c88ea564c8c">centroid</a> (Geometry const &amp;geometry, Point &amp;c, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the centroid of a geometry using the specified strategy.  <a href="group__centroid.html#ga3ec2c5e245c42ffaf28f1c88ea564c8c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Point &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__centroid.html#ga0231bbe9c80e9009271245e31ce5496b">centroid</a> (Geometry const &amp;geometry, Point &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the centroid of a geometry.  <a href="group__centroid.html#ga0231bbe9c80e9009271245e31ce5496b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__clear.html#ga61147247703a55d2d81badbd7f0a12a9">clear</a> (Geometry &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a linestring, ring or polygon (exterior+interiors) or multi*.  <a href="group__clear.html#ga61147247703a55d2d81badbd7f0a12a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Collection , typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a01cddb2f3a4f6294198cd7bb58084236">collect_vectors</a> (Collection &amp;collection, Geometry const &amp;geometry)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1comparable__distance__result.html">comparable_distance_result</a><br class="typebreak"/>
&lt; Geometry1, Geometry2, <br class="typebreak"/>
Strategy &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__distance.html#ga96e975b2491449d359a57a84a03c2a86">comparable_distance</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the comparable distance measurement of two geometries using the specified strategy.  <a href="group__distance.html#ga96e975b2491449d359a57a84a03c2a86"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1default__comparable__distance__result.html">default_comparable_distance_result</a><br class="typebreak"/>
&lt; Geometry1, Geometry2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__distance.html#gabdb5143911178c7e4c78114a785551ae">comparable_distance</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the comparable distance measurement of two geometries.  <a href="group__distance.html#gabdb5143911178c7e4c78114a785551ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convert.html#ga79cfffc1475f201bda92cb40a075a3d1">convert</a> (Geometry1 const &amp;geometry1, Geometry2 &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts one geometry to another geometry.  <a href="group__convert.html#ga79cfffc1475f201bda92cb40a075a3d1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename OutputGeometry , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a5f0f6e4d01982d810d1ad1c1817521cb">convex_hull</a> (Geometry const &amp;geometry, OutputGeometry &amp;out, Strategy const &amp;strategy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename OutputGeometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convex__hull.html#gadce5f964b027cc193af16673ad8ff4e9">convex_hull</a> (Geometry const &amp;geometry, OutputGeometry &amp;hull)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the convex hull of a geometry.  <a href="group__convex__hull.html#gadce5f964b027cc193af16673ad8ff4e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool Reverse, typename Geometry , typename SegmentIdentifier , typename PointOut &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a940cd6b6c22894d4b486793e34aa4f48">copy_segment_point</a> (Geometry const &amp;geometry, SegmentIdentifier const &amp;seg_id, int offset, PointOut &amp;point_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, copies a point from a segment.  <a href="#a940cd6b6c22894d4b486793e34aa4f48"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool Reverse1, bool Reverse2, typename Geometry1 , typename Geometry2 , typename SegmentIdentifier , typename PointOut &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a52e34bc3d6bad7f7e39e13f19a2c9bde">copy_segment_point</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, SegmentIdentifier const &amp;seg_id, int offset, PointOut &amp;point_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, to avoid the same construct several times, copies a point, based on a source-index and two geometries.  <a href="#a52e34bc3d6bad7f7e39e13f19a2c9bde"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool Reverse1, bool Reverse2, typename Geometry1 , typename Geometry2 , typename SegmentIdentifier , typename PointOut &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ad1fe604e9b46fabfc39147d341472026">copy_segment_points</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, SegmentIdentifier const &amp;seg_id, PointOut &amp;point1, PointOut &amp;point2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, to avoid the same construct several times, copies a point, based on a source-index and two geometries.  <a href="#ad1fe604e9b46fabfc39147d341472026"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool Reverse1, bool Reverse2, typename Geometry1 , typename Geometry2 , typename SegmentIdentifier , typename PointOut &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#aca0fd80f5a980e4cb73e580227bab287">copy_segment_points</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, SegmentIdentifier const &amp;seg_id, PointOut &amp;point1, PointOut &amp;point2, PointOut &amp;point3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, copies three points: two from the specified segment (from, to) and the next one.  <a href="#aca0fd80f5a980e4cb73e580227bab287"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool Reverse, typename Geometry , typename SegmentIdentifier , typename RobustPolicy , typename RangeOut &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#aa3b0e31bed132879fd68c9a19d95d20b">copy_segments</a> (Geometry const &amp;geometry, SegmentIdentifier const &amp;seg_id, <a class="el" href="namespaceboost_1_1geometry.html#af0c576f82145cf6a02dcbf48b675a0c2">signed_size_type</a> to_index, RobustPolicy const &amp;robust_policy, RangeOut &amp;range_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy segments from a geometry, starting with the specified segment (seg_id) until the specified index (to_index)  <a href="#aa3b0e31bed132879fd68c9a19d95d20b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__correct.html#gaf14641937f187af33fec6bd99c8202d9">correct</a> (Geometry &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Corrects a geometry.  <a href="group__correct.html#gaf14641937f187af33fec6bd99c8202d9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__covered__by.html#ga83cfa260c6a4f3bcba5a99da6113d19c">covered_by</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first geometry is inside or on border the second geometry.  <a href="group__covered__by.html#ga83cfa260c6a4f3bcba5a99da6113d19c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__covered__by.html#ga4db6801730953629ec9eb040a5ccc1ad">covered_by</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first geometry is inside or on border the second geometry using the specified strategy.  <a href="group__covered__by.html#ga4db6801730953629ec9eb040a5ccc1ad"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__crosses.html#gab50efa33876edf806597ea27a9d77989">crosses</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two geometries \1.  <a href="group__crosses.html#gab50efa33876edf806597ea27a9d77989"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename Collection &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__difference.html#gae23e000e550abb271baac3679fae7640">difference</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Collection &amp;output_collection)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__disjoint.html#ga980fdae7d8c1840c1362f09bb0dcf04e">disjoint</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two geometries \1.  <a href="group__disjoint.html#ga980fdae7d8c1840c1362f09bb0dcf04e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1distance__result.html">distance_result</a>&lt; Geometry1, <br class="typebreak"/>
Geometry2, Strategy &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__distance.html#ga7d68c34d1ded4428903f906244b31da4">distance</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance of two geometries using the specified strategy.  <a href="group__distance.html#ga7d68c34d1ded4428903f906244b31da4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1default__distance__result.html">default_distance_result</a><br class="typebreak"/>
&lt; Geometry1, Geometry2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__distance.html#gad5f5e3da7d38da77c40d7bdad61fee54">distance</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance of two geometries.  <a href="group__distance.html#gad5f5e3da7d38da77c40d7bdad61fee54"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point1 , typename Point2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic.html#ga8141e616132d8d614da3428863336dc9">divide_point</a> (Point1 &amp;p1, Point2 const &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a point by another.  <a href="group__arithmetic.html#ga8141e616132d8d614da3428863336dc9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic.html#ga98645f15cfba3e9e9e9e83c72e0f98e3">divide_value</a> (Point &amp;p, typename detail::param&lt; Point &gt;::type value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each coordinate of the same point by a value.  <a href="group__arithmetic.html#ga98645f15cfba3e9e9e9e83c72e0f98e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point1 , typename Point2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1select__coordinate__type.html">select_coordinate_type</a>&lt; Point1, <br class="typebreak"/>
Point2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic.html#gaf962409b64cd5023d9e439c4468db1d2">dot_product</a> (Point1 const &amp;p1, Point2 const &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product (or scalar product) of 2 vectors (points).  <a href="group__arithmetic.html#gaf962409b64cd5023d9e439c4468db1d2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool Reverse1, bool Reverse2, overlay_type OverlayType, typename Turns , typename Clusters , typename Geometry1 , typename Geometry2 , typename RobustPolicy , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#adfcf6eedaf9497f45d057cccd4875588">enrich_intersection_points</a> (Turns &amp;turns, Clusters &amp;clusters, detail::overlay::operation_type for_operation, Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, RobustPolicy const &amp;robust_policy, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">All intersection points are enriched with successor information.  <a href="#adfcf6eedaf9497f45d057cccd4875588"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Box &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__envelope.html#gac1f1865a7b36047d44949e17266d8f5a">envelope</a> (Geometry const &amp;geometry, Box &amp;mbr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the envelope of a geometry.  <a href="group__envelope.html#gac1f1865a7b36047d44949e17266d8f5a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__equals.html#gaf75334fd455c4d01a57a2f2d590d068c">equals</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a geometry \1.  <a href="group__equals.html#gaf75334fd455c4d01a57a2f2d590d068c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Box , typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__expand.html#ga2f189378ab0aa90c5b98bd7f3ed3cc93">expand</a> (Box &amp;box, Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands a box using the bounding box (envelope) of another geometry (box, point)  <a href="group__expand.html#ga2f189378ab0aa90c5b98bd7f3ed3cc93"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Polygon &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1ring__return__type.html">ring_return_type</a>&lt; Polygon &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exterior__ring.html#ga08713d51a3bbe530a5f69b5084107d89">exterior_ring</a> (Polygon &amp;polygon)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the exterior_ring ring of a polygon.  <a href="group__exterior__ring.html#ga08713d51a3bbe530a5f69b5084107d89"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Polygon &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1ring__return__type.html">ring_return_type</a>&lt; Polygon <br class="typebreak"/>
const  &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exterior__ring.html#ga96a935d3093b77955f100cc3da6a4e51">exterior_ring</a> (Polygon const &amp;polygon)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the exterior ring of a polygon (const version)  <a href="group__exterior__ring.html#ga96a935d3093b77955f100cc3da6a4e51"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Edge, typename Geometry , typename Extremes , typename Intruders &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a6e974796693e03c4e4837477054bae35">extreme_points</a> (Geometry const &amp;geometry, Extremes &amp;extremes, Intruders &amp;intruders)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns extreme points (for Edge=1 in dimension 1, so the top, for Edge=0 in dimension 0, the right side)  <a href="#a6e974796693e03c4e4837477054bae35"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point , typename Op &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ad61d195eec9f266bb67b31f72a022606">for_each_coordinate</a> (Point &amp;point, Op operation)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point , typename Op &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Op&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ac25c04e4afa958469c5b8e911eac143f">for_each_coordinate</a> (Point const &amp;point, Op operation)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Functor&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__for__each.html#ga3010849a8b501309db7b74157382cfaf">for_each_point</a> (Geometry &amp;geometry, Functor f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies function [*f] to each \1.  <a href="group__for__each.html#ga3010849a8b501309db7b74157382cfaf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Functor&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__for__each.html#ga42ec4761584f85dae332cd4266418017">for_each_segment</a> (Geometry &amp;geometry, Functor f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies function [*f] to each \1.  <a href="group__for__each.html#ga42ec4761584f85dae332cd4266418017"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dimension, typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1coordinate__type.html">coordinate_type</a>&lt; Geometry &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__get.html#ga6f2549aa15489bdfa2e0ee28c620ab07">get</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get coordinate value of a geometry (usually a point)  <a href="group__get.html#ga6f2549aa15489bdfa2e0ee28c620ab07"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, std::size_t Dimension, typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1coordinate__type.html">coordinate_type</a>&lt; Geometry &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__get.html#gabf9ceb2655358244b0348cef1f308288">get</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get coordinate value of a Box or Segment  <a href="group__get.html#gabf9ceb2655358244b0348cef1f308288"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dimension, typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1fp__coordinate__type.html">fp_coordinate_type</a>&lt; Geometry &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__get.html#ga599e31cfc2d3b5074bc3ac4cf24b9152">get_as_radian</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get coordinate value of a point, result is in Radian  <a href="group__get.html#ga599e31cfc2d3b5074bc3ac4cf24b9152"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename RobustPolicy , typename Turns &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ad8660b0cfc5db2cf38ce39dc32172c8f">get_intersection_points</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, RobustPolicy const &amp;robust_policy, Turns &amp;turns)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1radius__type.html">radius_type</a>&lt; Geometry &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__access.html#ga1e0627c198b569ca7f278acce06120ee">get_radius</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get radius of a circle / sphere / ellipse / etc.  <a href="group__access.html#ga1e0627c198b569ca7f278acce06120ee"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool Reverse1, bool Reverse2, typename AssignPolicy , typename Geometry1 , typename Geometry2 , typename RobustPolicy , typename Turns , typename InterruptPolicy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a89288d6d8396b6b713099f502277ea04">get_turns</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, RobustPolicy const &amp;robust_policy, Turns &amp;turns, InterruptPolicy &amp;interrupt_policy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the turn points of two geometries.  <a href="#a89288d6d8396b6b713099f502277ea04"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a591a8b3ec94a359069e5e07d8a238b2c">has_infinite_coordinate</a> (Point const &amp;point)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ad4a419817fdd2bf57433c6a0d9e47595">has_nan_coordinate</a> (Point const &amp;point)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a2f950b91e4e331aff1235ddd25deef72">has_non_finite_coordinate</a> (Point const &amp;point)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a1949f8f89274f3b53f6129638f8efc14">has_one_element</a> (Iterator first, Iterator beyond)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Polygon &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1interior__return__type.html">interior_return_type</a>&lt; Polygon &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interior__rings.html#gac5980f18e5c2d400f598299104630c8f">interior_rings</a> (Polygon &amp;polygon)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the interior rings of a polygon (non const version)  <a href="group__interior__rings.html#gac5980f18e5c2d400f598299104630c8f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Polygon &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1interior__return__type.html">interior_return_type</a>&lt; Polygon <br class="typebreak"/>
const  &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interior__rings.html#gace65f7563db807c7d2b2ad8bc4f7116b">interior_rings</a> (Polygon const &amp;polygon)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the interior rings of a polygon (const version)  <a href="group__interior__rings.html#gace65f7563db807c7d2b2ad8bc4f7116b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename GeometryOut &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__intersection.html#gac78b88e0ea7af3453a626a0e6fc588d7">intersection</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, GeometryOut &amp;geometry_out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the intersection of two geometries.  <a href="group__intersection.html#gac78b88e0ea7af3453a626a0e6fc588d7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__intersects.html#gacc0c6eb239493fc30afd057d7d56bb11">intersects</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a geometry \1.  <a href="group__intersects.html#gacc0c6eb239493fc30afd057d7d56bb11"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__intersects.html#ga3d8bd9a2b73bb493d66cbcb37426a7be">intersects</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two geometries \1.  <a href="group__intersects.html#ga3d8bd9a2b73bb493d66cbcb37426a7be"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a4168186cc06493d9628b2ee4cb8abaf0">is_convex</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__is__empty.html#gad12981ac44661b053d1e23bbc50be1b5">is_empty</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a geometry \1.  <a href="group__is__empty.html#gad12981ac44661b053d1e23bbc50be1b5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__is__simple.html#gadb32b5248d8b5ecedadcb05a4c9d7490">is_simple</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a geometry \1.  <a href="group__is__simple.html#gadb32b5248d8b5ecedadcb05a4c9d7490"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename VisitPolicy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a183da81edb3b8b170da54b4d15b0d923">is_valid</a> (Geometry const &amp;geometry, VisitPolicy &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__is__valid.html#ga356cf864eac8d92b2b841419c945b03f">is_valid</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a geometry \1.  <a href="group__is__valid.html#ga356cf864eac8d92b2b841419c945b03f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__is__valid.html#ga679fa00f8e9cc0a124fcdba608516dfc">is_valid</a> (Geometry const &amp;geometry, <a class="el" href="group__enum.html#ga8f93f0b6945c2ebb9f8a4bb53019a0d8">validity_failure_type</a> &amp;failure)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a geometry \1.  <a href="group__is__valid.html#ga679fa00f8e9cc0a124fcdba608516dfc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__is__valid.html#gaf0867398eaeea60e5c004a8615c7c28c">is_valid</a> (Geometry const &amp;geometry, std::string &amp;message)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a geometry \1.  <a href="group__is__valid.html#gaf0867398eaeea60e5c004a8615c7c28c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1default__length__result.html">default_length_result</a><br class="typebreak"/>
&lt; Geometry &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__length.html#ga38dff36b8deb6a1a8cb0a3d6387af8fc">length</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the length of a geometry.  <a href="group__length.html#ga38dff36b8deb6a1a8cb0a3d6387af8fc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1default__length__result.html">default_length_result</a><br class="typebreak"/>
&lt; Geometry &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__length.html#ga31c0f8fcd943475255e7ab329f2c2771">length</a> (Geometry const &amp;geometry, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the length of a geometry using the specified strategy.  <a href="group__length.html#ga31c0f8fcd943475255e7ab329f2c2771"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Geometry&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make.html#gab8c2f53b1696956874ed69114cef3a94">make</a> (Type const &amp;c1, Type const &amp;c2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a geometry.  <a href="group__make.html#gab8c2f53b1696956874ed69114cef3a94"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Geometry&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make.html#gacab36dbf4f41c6994fb66600303dfe3b">make</a> (Type const &amp;c1, Type const &amp;c2, Type const &amp;c3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a geometry.  <a href="group__make.html#gacab36dbf4f41c6994fb66600303dfe3b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Geometry&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a84ea9e8996ff4c4a67339c0371042177">make</a> (Type const &amp;c1, Type const &amp;c2, Type const &amp;c3, Type const &amp;c4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Geometry&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make.html#gabf487e6de983091aa6003f792b1b05df">make_inverse</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a box with inverse infinite coordinates.  <a href="group__make.html#gabf487e6de983091aa6003f792b1b05df"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Geometry&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make.html#ga06bcbd65d487f8dad0ebdab1f08aefa6">make_zero</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a geometry with its coordinates initialized to zero.  <a href="group__make.html#ga06bcbd65d487f8dad0ebdab1f08aefa6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RangeOfIntervals , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::range_value<br class="typebreak"/>
&lt; RangeOfIntervals &gt;<br class="typebreak"/>
::type::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a873bb153a6c2f37dd97e6a6b997e07ef">maximum_gap</a> (RangeOfIntervals const &amp;range_of_intervals, T &amp;max_gap_left, T &amp;max_gap_right)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RangeOfIntervals &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::range_value<br class="typebreak"/>
&lt; RangeOfIntervals &gt;<br class="typebreak"/>
::type::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a5c2390572b9ac45d119a20fcf81b8876">maximum_gap</a> (RangeOfIntervals const &amp;range_of_intervals)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ac4e8d5a470810b2bfca824af100894d5">method_char</a> (detail::overlay::method_type const &amp;method)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point1 , typename Point2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic.html#ga3ce5cfd812427c46ac5a319a34fe33b1">multiply_point</a> (Point1 &amp;p1, Point2 const &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a point by another.  <a href="group__arithmetic.html#ga3ce5cfd812427c46ac5a319a34fe33b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic.html#gaee0fa23a64414a4781e08965653c0b81">multiply_value</a> (Point &amp;p, typename detail::param&lt; Point &gt;::type value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each coordinate of a point by the same value.  <a href="group__arithmetic.html#gaee0fa23a64414a4781e08965653c0b81"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__num__geometries.html#gaa10343b9ce9a67688199e3da44a4af5d">num_geometries</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of geometries of a geometry.  <a href="group__num__geometries.html#gaa10343b9ce9a67688199e3da44a4af5d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__num__interior__rings.html#gad46daea8aff732fece897726c8a1eaf0">num_interior_rings</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of interior rings of a geometry.  <a href="group__num__interior__rings.html#gad46daea8aff732fece897726c8a1eaf0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__num__points.html#ga4e90b249b3cf16e4ef8f486df042aacd">num_points</a> (Geometry const &amp;geometry, bool add_for_open=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of points of a geometry.  <a href="group__num__points.html#ga4e90b249b3cf16e4ef8f486df042aacd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__num__segments.html#ga6d9d17a4691db85b4dacf8390dd14396">num_segments</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of segments of a geometry.  <a href="group__num__segments.html#ga6d9d17a4691db85b4dacf8390dd14396"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a22abb7a9456a80327b223fbeee1027a6">operation_char</a> (detail::overlay::operation_type const &amp;operation)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__overlaps.html#gacf8e51774babe694d39be3f049be6b39">overlaps</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two geometries \1.  <a href="group__overlaps.html#gacf8e51774babe694d39be3f049be6b39"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1default__length__result.html">default_length_result</a><br class="typebreak"/>
&lt; Geometry &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__perimeter.html#gabf1b8b04c850eece3b57dcb5d95a0bd9">perimeter</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the perimeter of a geometry.  <a href="group__perimeter.html#gabf1b8b04c850eece3b57dcb5d95a0bd9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1default__length__result.html">default_length_result</a><br class="typebreak"/>
&lt; Geometry &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__perimeter.html#gad580959ac971e1617c5f8cd08e32c6df">perimeter</a> (Geometry const &amp;geometry, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the perimeter of a geometry using the specified strategy.  <a href="group__perimeter.html#gad580959ac971e1617c5f8cd08e32c6df"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point , typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#aad3c56fd589d630843eb5d095d2d8bfd">point_on_border</a> (Point &amp;point, Geometry const &amp;geometry, bool midpoint=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take point on a border.  <a href="#aad3c56fd589d630843eb5d095d2d8bfd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Point &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#abeacf9dce3785e034214937074a1f3cc">point_on_surface</a> (Geometry const &amp;geometry, Point &amp;point)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a Point guaranteed to lie on the surface of the Geometry.  <a href="#abeacf9dce3785e034214937074a1f3cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1point__iterator.html">point_iterator</a>&lt; Geometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a03db7eeb2de8c6f84c0ed09c480420c8">points_begin</a> (Geometry &amp;geometry)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1point__iterator.html">point_iterator</a>&lt; Geometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a6286ce2300b3917da4253f7b2c71dda5">points_end</a> (Geometry &amp;geometry)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1point__reverse__iterator.html">point_reverse_iterator</a>&lt; Geometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ac56435cec379140e921fb5e8f955d292">points_rbegin</a> (Geometry &amp;geometry)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1point__reverse__iterator.html">point_reverse_iterator</a>&lt; Geometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a5984be872c96e65629dcb6156b293e0e">points_rend</a> (Geometry &amp;geometry)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Section &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1ring__return__type.html">ring_return_type</a>&lt; Geometry <br class="typebreak"/>
const  &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ac434096877035540e71a7ad08bfe3a4b">range_by_section</a> (Geometry const &amp;geometry, Section const &amp;<a class="el" href="structboost_1_1geometry_1_1section.html">section</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get full ring (exterior, one of interiors, one from multi) indicated by the specified section.  <a href="#ac434096877035540e71a7ad08bfe3a4b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__wkt.html#ga972597e2ff21d50a85b19de43ed6cd76">read_wkt</a> (std::string const &amp;<a class="el" href="group__wkt.html#ga32f68b63c9c15ed3c31f386001c4ec29">wkt</a>, Geometry &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses OGC Well-Known Text (<a class="el" href="_w_k_t.html">WKT (Well-Known Text)</a>) into a geometry (any geometry)  <a href="group__wkt.html#ga972597e2ff21d50a85b19de43ed6cd76"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ae65cfdfcb0e698fba1370e9347960c66">recalculate</a> (Geometry1 &amp;geometry1, Geometry2 const &amp;geometry2, Strategy const &amp;strategy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename Mask &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__relate.html#gabe671b5a5c5cd468621a4605ca7e57c5">relate</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Mask const &amp;mask)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks relation between a pair of geometries defined by a mask.  <a href="group__relate.html#gabe671b5a5c5cd468621a4605ca7e57c5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1de9im_1_1matrix.html">de9im::matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__relation.html#ga6a43ab4b83f66fb53c0dfe34981a6f4b">relation</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the relation between a pair of geometries as defined in DE-9IM.  <a href="group__relation.html#ga6a43ab4b83f66fb53c0dfe34981a6f4b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ab9f805dce11277676f1de471ee87a14b">remove_spikes</a> (Geometry &amp;geometry)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Output , typename Input , typename Distance &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Output&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga8f897ad6face43210c41f8afedf526bb">return_buffer</a> (Input const &amp;geometry, Distance const &amp;<a class="el" href="group__distance.html#ga7d68c34d1ded4428903f906244b31da4">distance</a>, Distance const &amp;chord_length=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the buffer of a geometry.  <a href="group__buffer.html#ga8f897ad6face43210c41f8afedf526bb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point , typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Point&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__centroid.html#ga607a6c57dac30f7b2826f29f937a7fe4">return_centroid</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the centroid of a geometry.  <a href="group__centroid.html#ga607a6c57dac30f7b2826f29f937a7fe4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point , typename Geometry , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Point&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__centroid.html#ga34a41b95d0bcc2ecb14e3093623386d3">return_centroid</a> (Geometry const &amp;geometry, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the centroid of a geometry using the specified strategy.  <a href="group__centroid.html#ga34a41b95d0bcc2ecb14e3093623386d3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Box , typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Box&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__envelope.html#ga4afb45ba6fb41e732a008a9e1e104347">return_envelope</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the envelope of a geometry.  <a href="group__envelope.html#ga4afb45ba6fb41e732a008a9e1e104347"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1geometry_1_1point__type.html">geometry::point_type</a>&lt; Geometry &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a1922563e36f64c8dd031257ac58d4df3">return_point_on_surface</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns point guaranteed to lie on the surface of the Geometry.  <a href="#a1922563e36f64c8dd031257ac58d4df3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reverse.html#ga9d0e06498236cee4517168b4cb231998">reverse</a> (Geometry &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the points within a geometry.  <a href="group__reverse.html#ga9d0e06498236cee4517168b4cb231998"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool Reverse, typename DimensionVector , typename Geometry , typename Sections , typename RobustPolicy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ab8cd77a55d7479badca9ddb3379bce06">sectionalize</a> (Geometry const &amp;geometry, RobustPolicy const &amp;robust_policy, Sections &amp;<a class="el" href="structboost_1_1geometry_1_1sections.html">sections</a>, int source_index=0, std::size_t max_count=10)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a geometry into monotonic sections.  <a href="#ab8cd77a55d7479badca9ddb3379bce06"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1segment__iterator.html">segment_iterator</a>&lt; Geometry const  &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#af53a7cce3633298bd5fe47d6ce71b4ce">segments_begin</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1segment__iterator.html">segment_iterator</a>&lt; Geometry const  &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a947086a59a0e75d7918bda2e292d1a63">segments_end</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename AssignPolicy , typename Geometry , typename RobustPolicy , typename Turns , typename InterruptPolicy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a7a2c5b63fa7d9e10d2c87650b05ade53">self_turns</a> (Geometry const &amp;geometry, RobustPolicy const &amp;robust_policy, Turns &amp;turns, InterruptPolicy &amp;interrupt_policy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate self intersections of a geometry.  <a href="#a7a2c5b63fa7d9e10d2c87650b05ade53"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dimension, typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set.html#ga547b9e2d42e58aab04949d056b795702">set</a> (Geometry &amp;geometry, typename <a class="el" href="structboost_1_1geometry_1_1coordinate__type.html">coordinate_type</a>&lt; Geometry &gt;::type const &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set coordinate value of a geometry (usually a point)  <a href="group__set.html#ga547b9e2d42e58aab04949d056b795702"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, std::size_t Dimension, typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set.html#gab344165e39efdf322c11f5b3205cb302">set</a> (Geometry &amp;geometry, typename <a class="el" href="structboost_1_1geometry_1_1coordinate__type.html">coordinate_type</a>&lt; Geometry &gt;::type const &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set coordinate value of a Box / Segment  <a href="group__set.html#gab344165e39efdf322c11f5b3205cb302"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t Dimension, typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set.html#ga78f2e71135a76ccad3e37afab58b0f70">set_from_radian</a> (Geometry &amp;geometry, typename <a class="el" href="structboost_1_1geometry_1_1fp__coordinate__type.html">fp_coordinate_type</a>&lt; Geometry &gt;::type const &amp;radians)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set coordinate value (in radian) to a point  <a href="group__set.html#ga78f2e71135a76ccad3e37afab58b0f70"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__access.html#ga6c403657f606b2a4d3f64d6e4ae74437">set_radius</a> (Geometry &amp;geometry, typename <a class="el" href="structboost_1_1geometry_1_1radius__type.html">radius_type</a>&lt; Geometry &gt;::type const &amp;radius)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the radius of a circle / sphere / ellipse / etc.  <a href="group__access.html#ga6c403657f606b2a4d3f64d6e4ae74437"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Distance , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__simplify.html#ga8f1c13c0fe844ffdaa6196ce3854849f">simplify</a> (Geometry const &amp;geometry, Geometry &amp;out, Distance const &amp;max_distance, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify a geometry using a specified strategy.  <a href="group__simplify.html#ga8f1c13c0fe844ffdaa6196ce3854849f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename Distance &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__simplify.html#ga7f1ed83b2a595dc644205374eddf0057">simplify</a> (Geometry const &amp;geometry, Geometry &amp;out, Distance const &amp;max_distance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify a geometry.  <a href="group__simplify.html#ga7f1ed83b2a595dc644205374eddf0057"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point1 , typename Point2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic.html#ga2aaca98906e1978d00ea55b40a1a39ea">subtract_point</a> (Point1 &amp;p1, Point2 const &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a point to another.  <a href="group__arithmetic.html#ga2aaca98906e1978d00ea55b40a1a39ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic.html#gaf0ffb395ff5f6359d8da055decddd385">subtract_value</a> (Point &amp;p, typename detail::param&lt; Point &gt;::type value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the same value to each coordinate of a point.  <a href="group__arithmetic.html#gaf0ffb395ff5f6359d8da055decddd385"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1svg__manipulator.html">svg_manipulator</a>&lt; Geometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__svg.html#gaf2dffff92f8bbb5ddb246560b324988a">svg</a> (Geometry const &amp;geometry, std::string const &amp;style, int size=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulator to stream geometries as SVG.  <a href="group__svg.html#gaf2dffff92f8bbb5ddb246560b324988a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry , typename TransformStrategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ad17275bdcc3409e08b6efeac43ceed98">svg_map</a> (std::ostream &amp;stream, std::string const &amp;style, int size, Geometry const &amp;geometry, TransformStrategy const &amp;strategy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename PriorityQueue , typename InitializationVisitor , typename EventVisitor , typename InterruptPolicy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a85ba136cb1836c9107108597ad3ae909">sweep</a> (Range const &amp;range, PriorityQueue &amp;queue, InitializationVisitor &amp;initialization_visitor, EventVisitor &amp;event_visitor, InterruptPolicy const &amp;interrupt_policy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename PriorityQueue , typename InitializationVisitor , typename EventVisitor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a0d1ffc8d5508af3bb4fa044b38ea282e">sweep</a> (Range const &amp;range, PriorityQueue &amp;queue, InitializationVisitor &amp;initialization_visitor, EventVisitor &amp;event_visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename Collection &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sym__difference.html#gab9e6f8b5e8d14cd699f54e79f60b1871">sym_difference</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Collection &amp;output_collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the symmetric difference of two geometries.  <a href="group__sym__difference.html#gab9e6f8b5e8d14cd699f54e79f60b1871"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__touches.html#ga34c4c58f9757ecd08dbd413701a59fac">touches</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a geometry \1.  <a href="group__touches.html#ga34c4c58f9757ecd08dbd413701a59fac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__touches.html#gabbb053b4c78edc40a6c37f1f0f71ddbe">touches</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two geometries \1.  <a href="group__touches.html#gabbb053b4c78edc40a6c37f1f0f71ddbe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform.html#ga396a7207dc2e9dbc3c15c1c174e0e5a0">transform</a> (Geometry1 const &amp;geometry1, Geometry2 &amp;geometry2, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms from one geometry to another geometry using the specified strategy.  <a href="group__transform.html#ga396a7207dc2e9dbc3c15c1c174e0e5a0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform.html#ga5f8dab51e6972613f20878beb34feb36">transform</a> (Geometry1 const &amp;geometry1, Geometry2 &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms from one geometry to another geometry using a strategy.  <a href="group__transform.html#ga5f8dab51e6972613f20878beb34feb36"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename Collection &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__union.html#gaa300b8994725c85cc71b304713a75501">union_</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Collection &amp;output_collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two geometries which each other.  <a href="group__union.html#gaa300b8994725c85cc71b304713a75501"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__unique.html#ga122eb540d5b35cf6b3c8c28f0c7fcc45">unique</a> (Geometry &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minimal set of a geometry.  <a href="group__unique.html#ga122eb540d5b35cf6b3c8c28f0c7fcc45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#ae1082d5256a30c0e6fe7ab657486f444">visited_char</a> (detail::overlay::visit_info const &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__within.html#gaf8f597c0a7352f0a6808944db2a549b7">within</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first geometry is completely inside the second geometry.  <a href="group__within.html#gaf8f597c0a7352f0a6808944db2a549b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename Strategy &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__within.html#ga4e277994f726a9e5076429e99a6cd3b8">within</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Strategy const &amp;strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first geometry is completely inside the second geometry using the specified strategy.  <a href="group__within.html#ga4e277994f726a9e5076429e99a6cd3b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1geometry_1_1wkt__manipulator.html">wkt_manipulator</a>&lt; Geometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__wkt.html#ga32f68b63c9c15ed3c31f386001c4ec29">wkt</a> (Geometry const &amp;geometry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main WKT-streaming function.  <a href="group__wkt.html#ga32f68b63c9c15ed3c31f386001c4ec29"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a4a86ce72ed7ddcfc21f8e79445bf683d">max_corner</a> = 1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of maximum corner of the box.  <a href="#a4a86ce72ed7ddcfc21f8e79445bf683d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1geometry.html#a60f531e30e193d8ce30098428d9134c1">min_corner</a> = 0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of minimum corner of the box.  <a href="#a60f531e30e193d8ce30098428d9134c1"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="af0c576f82145cf6a02dcbf48b675a0c2"></a><!-- doxytag: member="boost::geometry::signed_size_type" ref="af0c576f82145cf6a02dcbf48b675a0c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::make_signed&lt;std::size_t&gt;::type <a class="el" href="namespaceboost_1_1geometry.html#af0c576f82145cf6a02dcbf48b675a0c2">boost::geometry::signed_size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a6b49ba0dbb14c37e57127f78a74e4921"></a><!-- doxytag: member="boost::geometry::overlay_type" ref="a6b49ba0dbb14c37e57127f78a74e4921" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceboost_1_1geometry.html#a6b49ba0dbb14c37e57127f78a74e4921">boost::geometry::overlay_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a6b49ba0dbb14c37e57127f78a74e4921a3742a61a84923702bd74f7a9461e2811"></a><!-- doxytag: member="overlay_union" ref="a6b49ba0dbb14c37e57127f78a74e4921a3742a61a84923702bd74f7a9461e2811" args="" -->overlay_union</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6b49ba0dbb14c37e57127f78a74e4921a12c38cf5208fc177a356826347ce494b"></a><!-- doxytag: member="overlay_intersection" ref="a6b49ba0dbb14c37e57127f78a74e4921a12c38cf5208fc177a356826347ce494b" args="" -->overlay_intersection</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6b49ba0dbb14c37e57127f78a74e4921a08b4b940b7639685de488dd45589f020"></a><!-- doxytag: member="overlay_difference" ref="a6b49ba0dbb14c37e57127f78a74e4921a08b4b940b7639685de488dd45589f020" args="" -->overlay_difference</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6b49ba0dbb14c37e57127f78a74e4921aef2f937a8d3cc99675b292b3508334ec"></a><!-- doxytag: member="overlay_dissolve" ref="a6b49ba0dbb14c37e57127f78a74e4921aef2f937a8d3cc99675b292b3508334ec" args="" -->overlay_dissolve</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a6424afc319f6cc4d4276a3900e966d3f"></a><!-- doxytag: member="boost::geometry::iterate_direction" ref="a6424afc319f6cc4d4276a3900e966d3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceboost_1_1geometry.html#a6424afc319f6cc4d4276a3900e966d3f">boost::geometry::iterate_direction</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag for iterating a <a class="el" href="structboost_1_1geometry_1_1reversible__view.html" title="View on a range, reversing direction if necessary.">reversible_view</a> in forward or reverse direction. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a6424afc319f6cc4d4276a3900e966d3fa8d759d0a3695aa617e26a1b3e101de29"></a><!-- doxytag: member="iterate_forward" ref="a6424afc319f6cc4d4276a3900e966d3fa8d759d0a3695aa617e26a1b3e101de29" args="" -->iterate_forward</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6424afc319f6cc4d4276a3900e966d3fa37daa24e30befa9d690d75fb5439718a"></a><!-- doxytag: member="iterate_reverse" ref="a6424afc319f6cc4d4276a3900e966d3fa37daa24e30befa9d690d75fb5439718a" args="" -->iterate_reverse</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1847c5af13e0d19c3911421d3dab6c8d"></a><!-- doxytag: member="boost::geometry::assert_dimension" ref="a1847c5af13e0d19c3911421d3dab6c8d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry , int Dimensions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#a1847c5af13e0d19c3911421d3dab6c8d">boost::geometry::assert_dimension</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>assert_dimension, enables compile-time checking if coordinate dimensions are as expected </p>

</div>
</div>
<a class="anchor" id="ad4a36c4d293b80a01c84e37543b59456"></a><!-- doxytag: member="boost::geometry::assert_dimension_less_equal" ref="ad4a36c4d293b80a01c84e37543b59456" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry , int Dimensions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#ad4a36c4d293b80a01c84e37543b59456">boost::geometry::assert_dimension_less_equal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>assert_dimension, enables compile-time checking if coordinate dimensions are as expected </p>

</div>
</div>
<a class="anchor" id="a8de3fe127dab25ac9c46d611f78afafa"></a><!-- doxytag: member="boost::geometry::assert_dimension_greater_equal" ref="a8de3fe127dab25ac9c46d611f78afafa" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry , int Dimensions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#a8de3fe127dab25ac9c46d611f78afafa">boost::geometry::assert_dimension_greater_equal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a13b8191ba1135e983690791efab43927"></a><!-- doxytag: member="boost::geometry::assert_dimension_equal" ref="a13b8191ba1135e983690791efab43927" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G1 , typename G2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#a13b8191ba1135e983690791efab43927">boost::geometry::assert_dimension_equal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>assert_dimension_equal, enables compile-time checking if coordinate dimensions of two geometries are equal </p>

</div>
</div>
<a class="anchor" id="a5f0f6e4d01982d810d1ad1c1817521cb"></a><!-- doxytag: member="boost::geometry::convex_hull" ref="a5f0f6e4d01982d810d1ad1c1817521cb" args="(Geometry const &amp;geometry, OutputGeometry &amp;out, Strategy const &amp;strategy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry , typename OutputGeometry , typename Strategy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#a5f0f6e4d01982d810d1ad1c1817521cb">boost::geometry::convex_hull</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputGeometry &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Strategy const &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="02_linestring_example_8cpp-example.html#a19">02_linestring_example.cpp</a>, and <a class="el" href="03_polygon_example_8cpp-example.html#a14">03_polygon_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4168186cc06493d9628b2ee4cb8abaf0"></a><!-- doxytag: member="boost::geometry::is_convex" ref="a4168186cc06493d9628b2ee4cb8abaf0" args="(Geometry const &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#a4168186cc06493d9628b2ee4cb8abaf0">boost::geometry::is_convex</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a84ea9e8996ff4c4a67339c0371042177"></a><!-- doxytag: member="boost::geometry::make" ref="a84ea9e8996ff4c4a67339c0371042177" args="(Type const &amp;c1, Type const &amp;c2, Type const &amp;c3, Type const &amp;c4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry , typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Geometry <a class="el" href="group__make.html#gab8c2f53b1696956874ed69114cef3a94">boost::geometry::make</a> </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>c4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abeacf9dce3785e034214937074a1f3cc"></a><!-- doxytag: member="boost::geometry::point_on_surface" ref="abeacf9dce3785e034214937074a1f3cc" args="(Geometry const &amp;geometry, Point &amp;point)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry , typename Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#abeacf9dce3785e034214937074a1f3cc">boost::geometry::point_on_surface</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns a Point guaranteed to lie on the surface of the Geometry. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Geometry</td><td>geometry type. This also defines the type of the output point </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry</td><td>Geometry to take point from </td></tr>
    <tr><td class="paramname">point</td><td>Point to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1922563e36f64c8dd031257ac58d4df3"></a><!-- doxytag: member="boost::geometry::return_point_on_surface" ref="a1922563e36f64c8dd031257ac58d4df3" args="(Geometry const &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structboost_1_1geometry_1_1point__type.html">geometry::point_type</a>&lt;Geometry&gt;::type <a class="el" href="namespaceboost_1_1geometry.html#a1922563e36f64c8dd031257ac58d4df3">boost::geometry::return_point_on_surface</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns point guaranteed to lie on the surface of the Geometry. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Geometry</td><td>geometry type. This also defines the type of the output point </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry</td><td>Geometry to take point from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Point guaranteed to lie on the surface of the Geometry </dd></dl>

</div>
</div>
<a class="anchor" id="ab9f805dce11277676f1de471ee87a14b"></a><!-- doxytag: member="boost::geometry::remove_spikes" ref="ab9f805dce11277676f1de471ee87a14b" args="(Geometry &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#ab9f805dce11277676f1de471ee87a14b">boost::geometry::remove_spikes</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry &amp;&#160;</td>
          <td class="paramname"><em>geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Geometry</td><td>geometry type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry</td><td>the geometry to make remove_spikes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e974796693e03c4e4837477054bae35"></a><!-- doxytag: member="boost::geometry::extreme_points" ref="a6e974796693e03c4e4837477054bae35" args="(Geometry const &amp;geometry, Extremes &amp;extremes, Intruders &amp;intruders)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Edge, typename Geometry , typename Extremes , typename Intruders &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#a6e974796693e03c4e4837477054bae35">boost::geometry::extreme_points</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extremes &amp;&#160;</td>
          <td class="paramname"><em>extremes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Intruders &amp;&#160;</td>
          <td class="paramname"><em>intruders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns extreme points (for Edge=1 in dimension 1, so the top, for Edge=0 in dimension 0, the right side) </p>
<dl class="note"><dt><b>Note:</b></dt><dd>We could specify a strategy (less/greater) to get bottom/left side too. However, until now we don't need that. </dd></dl>

</div>
</div>
<a class="anchor" id="a873bb153a6c2f37dd97e6a6b997e07ef"></a><!-- doxytag: member="boost::geometry::maximum_gap" ref="a873bb153a6c2f37dd97e6a6b997e07ef" args="(RangeOfIntervals const &amp;range_of_intervals, T &amp;max_gap_left, T &amp;max_gap_right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeOfIntervals , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::range_value&lt;RangeOfIntervals&gt;::type::difference_type <a class="el" href="namespaceboost_1_1geometry.html#a873bb153a6c2f37dd97e6a6b997e07ef">boost::geometry::maximum_gap</a> </td>
          <td>(</td>
          <td class="paramtype">RangeOfIntervals const &amp;&#160;</td>
          <td class="paramname"><em>range_of_intervals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>max_gap_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>max_gap_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5c2390572b9ac45d119a20fcf81b8876"></a><!-- doxytag: member="boost::geometry::maximum_gap" ref="a5c2390572b9ac45d119a20fcf81b8876" args="(RangeOfIntervals const &amp;range_of_intervals)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeOfIntervals &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::range_value&lt;RangeOfIntervals&gt;::type::difference_type <a class="el" href="namespaceboost_1_1geometry.html#a873bb153a6c2f37dd97e6a6b997e07ef">boost::geometry::maximum_gap</a> </td>
          <td>(</td>
          <td class="paramtype">RangeOfIntervals const &amp;&#160;</td>
          <td class="paramname"><em>range_of_intervals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aad3c56fd589d630843eb5d095d2d8bfd"></a><!-- doxytag: member="boost::geometry::point_on_border" ref="aad3c56fd589d630843eb5d095d2d8bfd" args="(Point &amp;point, Geometry const &amp;geometry, bool midpoint=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point , typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#aad3c56fd589d630843eb5d095d2d8bfd">boost::geometry::point_on_border</a> </td>
          <td>(</td>
          <td class="paramtype">Point &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>midpoint</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take point on a border. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Geometry</td><td>geometry type. This also defines the type of the output point </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>to assign </td></tr>
    <tr><td class="paramname">geometry</td><td>geometry to take point from </td></tr>
    <tr><td class="paramname">midpoint</td><td>boolean flag, true if the point should not be a vertex, but some point in between of two vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if successful, else false. It is only false if polygon/line have no points </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>for a polygon, it is always a point on the exterior ring </dd>
<dd>
for take_midpoint, it is not taken from two consecutive duplicate vertices, (unless there are no other). </dd></dl>

</div>
</div>
<a class="anchor" id="ae65cfdfcb0e698fba1370e9347960c66"></a><!-- doxytag: member="boost::geometry::recalculate" ref="ae65cfdfcb0e698fba1370e9347960c66" args="(Geometry1 &amp;geometry1, Geometry2 const &amp;geometry2, Strategy const &amp;strategy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry1 , typename Geometry2 , typename Strategy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#ae65cfdfcb0e698fba1370e9347960c66">boost::geometry::recalculate</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry1 &amp;&#160;</td>
          <td class="paramname"><em>geometry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry2 const &amp;&#160;</td>
          <td class="paramname"><em>geometry2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Strategy const &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a85ba136cb1836c9107108597ad3ae909"></a><!-- doxytag: member="boost::geometry::sweep" ref="a85ba136cb1836c9107108597ad3ae909" args="(Range const &amp;range, PriorityQueue &amp;queue, InitializationVisitor &amp;initialization_visitor, EventVisitor &amp;event_visitor, InterruptPolicy const &amp;interrupt_policy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename PriorityQueue , typename InitializationVisitor , typename EventVisitor , typename InterruptPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#a85ba136cb1836c9107108597ad3ae909">boost::geometry::sweep</a> </td>
          <td>(</td>
          <td class="paramtype">Range const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PriorityQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InitializationVisitor &amp;&#160;</td>
          <td class="paramname"><em>initialization_visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventVisitor &amp;&#160;</td>
          <td class="paramname"><em>event_visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptPolicy const &amp;&#160;</td>
          <td class="paramname"><em>interrupt_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0d1ffc8d5508af3bb4fa044b38ea282e"></a><!-- doxytag: member="boost::geometry::sweep" ref="a0d1ffc8d5508af3bb4fa044b38ea282e" args="(Range const &amp;range, PriorityQueue &amp;queue, InitializationVisitor &amp;initialization_visitor, EventVisitor &amp;event_visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename PriorityQueue , typename InitializationVisitor , typename EventVisitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#a85ba136cb1836c9107108597ad3ae909">boost::geometry::sweep</a> </td>
          <td>(</td>
          <td class="paramtype">Range const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PriorityQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InitializationVisitor &amp;&#160;</td>
          <td class="paramname"><em>initialization_visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventVisitor &amp;&#160;</td>
          <td class="paramname"><em>event_visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a01cddb2f3a4f6294198cd7bb58084236"></a><!-- doxytag: member="boost::geometry::collect_vectors" ref="a01cddb2f3a4f6294198cd7bb58084236" args="(Collection &amp;collection, Geometry const &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Collection , typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#a01cddb2f3a4f6294198cd7bb58084236">boost::geometry::collect_vectors</a> </td>
          <td>(</td>
          <td class="paramtype">Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Collection</td><td>Collection type, should be e.g. std::vector&lt;&gt; </td></tr>
    <tr><td class="paramname">Geometry</td><td>geometry type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>the collection of vectors </td></tr>
    <tr><td class="paramname">geometry</td><td>the geometry to make collect_vectors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a183da81edb3b8b170da54b4d15b0d923"></a><!-- doxytag: member="boost::geometry::is_valid" ref="a183da81edb3b8b170da54b4d15b0d923" args="(Geometry const &amp;geometry, VisitPolicy &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry , typename VisitPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#a183da81edb3b8b170da54b4d15b0d923">boost::geometry::is_valid</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitPolicy &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a940cd6b6c22894d4b486793e34aa4f48"></a><!-- doxytag: member="boost::geometry::copy_segment_point" ref="a940cd6b6c22894d4b486793e34aa4f48" args="(Geometry const &amp;geometry, SegmentIdentifier const &amp;seg_id, int offset, PointOut &amp;point_out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Reverse, typename Geometry , typename SegmentIdentifier , typename PointOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#a940cd6b6c22894d4b486793e34aa4f48">boost::geometry::copy_segment_point</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SegmentIdentifier const &amp;&#160;</td>
          <td class="paramname"><em>seg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOut &amp;&#160;</td>
          <td class="paramname"><em>point_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function, copies a point from a segment. </p>

</div>
</div>
<a class="anchor" id="a52e34bc3d6bad7f7e39e13f19a2c9bde"></a><!-- doxytag: member="boost::geometry::copy_segment_point" ref="a52e34bc3d6bad7f7e39e13f19a2c9bde" args="(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, SegmentIdentifier const &amp;seg_id, int offset, PointOut &amp;point_out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Reverse1, bool Reverse2, typename Geometry1 , typename Geometry2 , typename SegmentIdentifier , typename PointOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#a940cd6b6c22894d4b486793e34aa4f48">boost::geometry::copy_segment_point</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry1 const &amp;&#160;</td>
          <td class="paramname"><em>geometry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry2 const &amp;&#160;</td>
          <td class="paramname"><em>geometry2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SegmentIdentifier const &amp;&#160;</td>
          <td class="paramname"><em>seg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOut &amp;&#160;</td>
          <td class="paramname"><em>point_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function, to avoid the same construct several times, copies a point, based on a source-index and two geometries. </p>

</div>
</div>
<a class="anchor" id="ad1fe604e9b46fabfc39147d341472026"></a><!-- doxytag: member="boost::geometry::copy_segment_points" ref="ad1fe604e9b46fabfc39147d341472026" args="(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, SegmentIdentifier const &amp;seg_id, PointOut &amp;point1, PointOut &amp;point2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Reverse1, bool Reverse2, typename Geometry1 , typename Geometry2 , typename SegmentIdentifier , typename PointOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#ad1fe604e9b46fabfc39147d341472026">boost::geometry::copy_segment_points</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry1 const &amp;&#160;</td>
          <td class="paramname"><em>geometry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry2 const &amp;&#160;</td>
          <td class="paramname"><em>geometry2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SegmentIdentifier const &amp;&#160;</td>
          <td class="paramname"><em>seg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOut &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOut &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function, to avoid the same construct several times, copies a point, based on a source-index and two geometries. </p>

</div>
</div>
<a class="anchor" id="aca0fd80f5a980e4cb73e580227bab287"></a><!-- doxytag: member="boost::geometry::copy_segment_points" ref="aca0fd80f5a980e4cb73e580227bab287" args="(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, SegmentIdentifier const &amp;seg_id, PointOut &amp;point1, PointOut &amp;point2, PointOut &amp;point3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Reverse1, bool Reverse2, typename Geometry1 , typename Geometry2 , typename SegmentIdentifier , typename PointOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#ad1fe604e9b46fabfc39147d341472026">boost::geometry::copy_segment_points</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry1 const &amp;&#160;</td>
          <td class="paramname"><em>geometry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry2 const &amp;&#160;</td>
          <td class="paramname"><em>geometry2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SegmentIdentifier const &amp;&#160;</td>
          <td class="paramname"><em>seg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOut &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOut &amp;&#160;</td>
          <td class="paramname"><em>point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOut &amp;&#160;</td>
          <td class="paramname"><em>point3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function, copies three points: two from the specified segment (from, to) and the next one. </p>

</div>
</div>
<a class="anchor" id="aa3b0e31bed132879fd68c9a19d95d20b"></a><!-- doxytag: member="boost::geometry::copy_segments" ref="aa3b0e31bed132879fd68c9a19d95d20b" args="(Geometry const &amp;geometry, SegmentIdentifier const &amp;seg_id, signed_size_type to_index, RobustPolicy const &amp;robust_policy, RangeOut &amp;range_out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Reverse, typename Geometry , typename SegmentIdentifier , typename RobustPolicy , typename RangeOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#aa3b0e31bed132879fd68c9a19d95d20b">boost::geometry::copy_segments</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SegmentIdentifier const &amp;&#160;</td>
          <td class="paramname"><em>seg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_size_type&#160;</td>
          <td class="paramname"><em>to_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RobustPolicy const &amp;&#160;</td>
          <td class="paramname"><em>robust_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeOut &amp;&#160;</td>
          <td class="paramname"><em>range_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy segments from a geometry, starting with the specified segment (seg_id) until the specified index (to_index) </p>

</div>
</div>
<a class="anchor" id="ac4e8d5a470810b2bfca824af100894d5"></a><!-- doxytag: member="boost::geometry::method_char" ref="ac4e8d5a470810b2bfca824af100894d5" args="(detail::overlay::method_type const &amp;method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="namespaceboost_1_1geometry.html#ac4e8d5a470810b2bfca824af100894d5">boost::geometry::method_char</a> </td>
          <td>(</td>
          <td class="paramtype">detail::overlay::method_type const &amp;&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a22abb7a9456a80327b223fbeee1027a6"></a><!-- doxytag: member="boost::geometry::operation_char" ref="a22abb7a9456a80327b223fbeee1027a6" args="(detail::overlay::operation_type const &amp;operation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="namespaceboost_1_1geometry.html#a22abb7a9456a80327b223fbeee1027a6">boost::geometry::operation_char</a> </td>
          <td>(</td>
          <td class="paramtype">detail::overlay::operation_type const &amp;&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae1082d5256a30c0e6fe7ab657486f444"></a><!-- doxytag: member="boost::geometry::visited_char" ref="ae1082d5256a30c0e6fe7ab657486f444" args="(detail::overlay::visit_info const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="namespaceboost_1_1geometry.html#ae1082d5256a30c0e6fe7ab657486f444">boost::geometry::visited_char</a> </td>
          <td>(</td>
          <td class="paramtype">detail::overlay::visit_info const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adfcf6eedaf9497f45d057cccd4875588"></a><!-- doxytag: member="boost::geometry::enrich_intersection_points" ref="adfcf6eedaf9497f45d057cccd4875588" args="(Turns &amp;turns, Clusters &amp;clusters, detail::overlay::operation_type for_operation, Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, RobustPolicy const &amp;robust_policy, Strategy const &amp;strategy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Reverse1, bool Reverse2, overlay_type OverlayType, typename Turns , typename Clusters , typename Geometry1 , typename Geometry2 , typename RobustPolicy , typename Strategy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#adfcf6eedaf9497f45d057cccd4875588">boost::geometry::enrich_intersection_points</a> </td>
          <td>(</td>
          <td class="paramtype">Turns &amp;&#160;</td>
          <td class="paramname"><em>turns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Clusters &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::overlay::operation_type&#160;</td>
          <td class="paramname"><em>for_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry1 const &amp;&#160;</td>
          <td class="paramname"><em>geometry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry2 const &amp;&#160;</td>
          <td class="paramname"><em>geometry2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RobustPolicy const &amp;&#160;</td>
          <td class="paramname"><em>robust_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Strategy const &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>All intersection points are enriched with successor information. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Turns</td><td>type of intersection container (e.g. vector of "intersection/turn point"'s) </td></tr>
    <tr><td class="paramname">Geometry1</td><td>Any type fulfilling a Geometry Concept </td></tr>
    <tr><td class="paramname">Geometry2</td><td>Any type fulfilling a Geometry Concept </td></tr>
    <tr><td class="paramname">Strategy</td><td>side strategy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">turns</td><td>container containing intersectionpoints </td></tr>
    <tr><td class="paramname">for_operation</td><td>operation_type (union or intersection) </td></tr>
    <tr><td class="paramname">geometry1</td><td>A model of the specified concept </td></tr>
    <tr><td class="paramname">geometry2</td><td>A model of the specified concept </td></tr>
    <tr><td class="paramname">robust_policy</td><td>policy to handle robustness issues </td></tr>
    <tr><td class="paramname">strategy</td><td>strategy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8660b0cfc5db2cf38ce39dc32172c8f"></a><!-- doxytag: member="boost::geometry::get_intersection_points" ref="ad8660b0cfc5db2cf38ce39dc32172c8f" args="(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, RobustPolicy const &amp;robust_policy, Turns &amp;turns)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry1 , typename Geometry2 , typename RobustPolicy , typename Turns &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#ad8660b0cfc5db2cf38ce39dc32172c8f">boost::geometry::get_intersection_points</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry1 const &amp;&#160;</td>
          <td class="paramname"><em>geometry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry2 const &amp;&#160;</td>
          <td class="paramname"><em>geometry2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RobustPolicy const &amp;&#160;</td>
          <td class="paramname"><em>robust_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Turns &amp;&#160;</td>
          <td class="paramname"><em>turns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a89288d6d8396b6b713099f502277ea04"></a><!-- doxytag: member="boost::geometry::get_turns" ref="a89288d6d8396b6b713099f502277ea04" args="(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, RobustPolicy const &amp;robust_policy, Turns &amp;turns, InterruptPolicy &amp;interrupt_policy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Reverse1, bool Reverse2, typename AssignPolicy , typename Geometry1 , typename Geometry2 , typename RobustPolicy , typename Turns , typename InterruptPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#a89288d6d8396b6b713099f502277ea04">boost::geometry::get_turns</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry1 const &amp;&#160;</td>
          <td class="paramname"><em>geometry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry2 const &amp;&#160;</td>
          <td class="paramname"><em>geometry2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RobustPolicy const &amp;&#160;</td>
          <td class="paramname"><em>robust_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Turns &amp;&#160;</td>
          <td class="paramname"><em>turns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptPolicy &amp;&#160;</td>
          <td class="paramname"><em>interrupt_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the turn points of two geometries. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Geometry1</td><td>Any type fulfilling a Geometry Concept </td></tr>
    <tr><td class="paramname">Geometry2</td><td>Any type fulfilling a Geometry Concept </td></tr>
    <tr><td class="paramname">Turns</td><td>type of turn-container (e.g. vector of "intersection/turn point"'s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry1</td><td>A model of the specified concept </td></tr>
    <tr><td class="paramname">geometry2</td><td>A model of the specified concept </td></tr>
    <tr><td class="paramname">robust_policy</td><td>policy to handle robustness issues </td></tr>
    <tr><td class="paramname">turns</td><td>container which will contain turn points </td></tr>
    <tr><td class="paramname">interrupt_policy</td><td>policy determining if process is stopped when intersection is found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a2c5b63fa7d9e10d2c87650b05ade53"></a><!-- doxytag: member="boost::geometry::self_turns" ref="a7a2c5b63fa7d9e10d2c87650b05ade53" args="(Geometry const &amp;geometry, RobustPolicy const &amp;robust_policy, Turns &amp;turns, InterruptPolicy &amp;interrupt_policy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AssignPolicy , typename Geometry , typename RobustPolicy , typename Turns , typename InterruptPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#a7a2c5b63fa7d9e10d2c87650b05ade53">boost::geometry::self_turns</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RobustPolicy const &amp;&#160;</td>
          <td class="paramname"><em>robust_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Turns &amp;&#160;</td>
          <td class="paramname"><em>turns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptPolicy &amp;&#160;</td>
          <td class="paramname"><em>interrupt_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate self intersections of a geometry. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Geometry</td><td>geometry type </td></tr>
    <tr><td class="paramname">Turns</td><td>type of intersection container (e.g. vector of "intersection/turn point"'s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry</td><td>geometry </td></tr>
    <tr><td class="paramname">robust_policy</td><td>policy to handle robustness issues </td></tr>
    <tr><td class="paramname">turns</td><td>container which will contain intersection points </td></tr>
    <tr><td class="paramname">interrupt_policy</td><td>policy determining if process is stopped when intersection is found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac434096877035540e71a7ad08bfe3a4b"></a><!-- doxytag: member="boost::geometry::range_by_section" ref="ac434096877035540e71a7ad08bfe3a4b" args="(Geometry const &amp;geometry, Section const &amp;section)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry , typename Section &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structboost_1_1geometry_1_1ring__return__type.html">ring_return_type</a>&lt;Geometry const&gt;::type <a class="el" href="namespaceboost_1_1geometry.html#ac434096877035540e71a7ad08bfe3a4b">boost::geometry::range_by_section</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Section const &amp;&#160;</td>
          <td class="paramname"><em>section</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get full ring (exterior, one of interiors, one from multi) indicated by the specified section. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Geometry</td><td>type </td></tr>
    <tr><td class="paramname">Section</td><td>type of section to get from </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry</td><td>geometry to take section of </td></tr>
    <tr><td class="paramname">section</td><td>structure with section </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8cd77a55d7479badca9ddb3379bce06"></a><!-- doxytag: member="boost::geometry::sectionalize" ref="ab8cd77a55d7479badca9ddb3379bce06" args="(Geometry const &amp;geometry, RobustPolicy const &amp;robust_policy, Sections &amp;sections, int source_index=0, std::size_t max_count=10)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Reverse, typename DimensionVector , typename Geometry , typename Sections , typename RobustPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#ab8cd77a55d7479badca9ddb3379bce06">boost::geometry::sectionalize</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RobustPolicy const &amp;&#160;</td>
          <td class="paramname"><em>robust_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sections &amp;&#160;</td>
          <td class="paramname"><em>sections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_count</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a geometry into monotonic sections. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Geometry</td><td>type of geometry to check </td></tr>
    <tr><td class="paramname">Sections</td><td>type of sections to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry</td><td>geometry to create sections from </td></tr>
    <tr><td class="paramname">robust_policy</td><td>policy to handle robustness issues </td></tr>
    <tr><td class="paramname">sections</td><td>structure with sections </td></tr>
    <tr><td class="paramname">source_index</td><td>index to assign to the ring_identifiers </td></tr>
    <tr><td class="paramname">max_count</td><td>maximal number of points per section (defaults to 10, this seems to give the fastest results) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1949f8f89274f3b53f6129638f8efc14"></a><!-- doxytag: member="boost::geometry::has_one_element" ref="a1949f8f89274f3b53f6129638f8efc14" args="(Iterator first, Iterator beyond)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#a1949f8f89274f3b53f6129638f8efc14">boost::geometry::has_one_element</a> </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>beyond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a03db7eeb2de8c6f84c0ed09c480420c8"></a><!-- doxytag: member="boost::geometry::points_begin" ref="a03db7eeb2de8c6f84c0ed09c480420c8" args="(Geometry &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1point__iterator.html">point_iterator</a>&lt;Geometry&gt; <a class="el" href="namespaceboost_1_1geometry.html#a03db7eeb2de8c6f84c0ed09c480420c8">boost::geometry::points_begin</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry &amp;&#160;</td>
          <td class="paramname"><em>geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6286ce2300b3917da4253f7b2c71dda5"></a><!-- doxytag: member="boost::geometry::points_end" ref="a6286ce2300b3917da4253f7b2c71dda5" args="(Geometry &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1point__iterator.html">point_iterator</a>&lt;Geometry&gt; <a class="el" href="namespaceboost_1_1geometry.html#a6286ce2300b3917da4253f7b2c71dda5">boost::geometry::points_end</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry &amp;&#160;</td>
          <td class="paramname"><em>geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac56435cec379140e921fb5e8f955d292"></a><!-- doxytag: member="boost::geometry::points_rbegin" ref="ac56435cec379140e921fb5e8f955d292" args="(Geometry &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1point__reverse__iterator.html">point_reverse_iterator</a>&lt;Geometry&gt; <a class="el" href="namespaceboost_1_1geometry.html#ac56435cec379140e921fb5e8f955d292">boost::geometry::points_rbegin</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry &amp;&#160;</td>
          <td class="paramname"><em>geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5984be872c96e65629dcb6156b293e0e"></a><!-- doxytag: member="boost::geometry::points_rend" ref="a5984be872c96e65629dcb6156b293e0e" args="(Geometry &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1point__reverse__iterator.html">point_reverse_iterator</a>&lt;Geometry&gt; <a class="el" href="namespaceboost_1_1geometry.html#a5984be872c96e65629dcb6156b293e0e">boost::geometry::points_rend</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry &amp;&#160;</td>
          <td class="paramname"><em>geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af53a7cce3633298bd5fe47d6ce71b4ce"></a><!-- doxytag: member="boost::geometry::segments_begin" ref="af53a7cce3633298bd5fe47d6ce71b4ce" args="(Geometry const &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1segment__iterator.html">segment_iterator</a>&lt;Geometry const&gt; <a class="el" href="namespaceboost_1_1geometry.html#af53a7cce3633298bd5fe47d6ce71b4ce">boost::geometry::segments_begin</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a947086a59a0e75d7918bda2e292d1a63"></a><!-- doxytag: member="boost::geometry::segments_end" ref="a947086a59a0e75d7918bda2e292d1a63" args="(Geometry const &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1geometry_1_1segment__iterator.html">segment_iterator</a>&lt;Geometry const&gt; <a class="el" href="namespaceboost_1_1geometry.html#a947086a59a0e75d7918bda2e292d1a63">boost::geometry::segments_end</a> </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad17275bdcc3409e08b6efeac43ceed98"></a><!-- doxytag: member="boost::geometry::svg_map" ref="ad17275bdcc3409e08b6efeac43ceed98" args="(std::ostream &amp;stream, std::string const &amp;style, int size, Geometry const &amp;geometry, TransformStrategy const &amp;strategy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry , typename TransformStrategy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#ad17275bdcc3409e08b6efeac43ceed98">boost::geometry::svg_map</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransformStrategy const &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad61d195eec9f266bb67b31f72a022606"></a><!-- doxytag: member="boost::geometry::for_each_coordinate" ref="ad61d195eec9f266bb67b31f72a022606" args="(Point &amp;point, Op operation)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceboost_1_1geometry.html#ad61d195eec9f266bb67b31f72a022606">boost::geometry::for_each_coordinate</a> </td>
          <td>(</td>
          <td class="paramtype">Point &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac25c04e4afa958469c5b8e911eac143f"></a><!-- doxytag: member="boost::geometry::for_each_coordinate" ref="ac25c04e4afa958469c5b8e911eac143f" args="(Point const &amp;point, Op operation)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Op <a class="el" href="namespaceboost_1_1geometry.html#ad61d195eec9f266bb67b31f72a022606">boost::geometry::for_each_coordinate</a> </td>
          <td>(</td>
          <td class="paramtype">Point const &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a591a8b3ec94a359069e5e07d8a238b2c"></a><!-- doxytag: member="boost::geometry::has_infinite_coordinate" ref="a591a8b3ec94a359069e5e07d8a238b2c" args="(Point const &amp;point)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#a591a8b3ec94a359069e5e07d8a238b2c">boost::geometry::has_infinite_coordinate</a> </td>
          <td>(</td>
          <td class="paramtype">Point const &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4a419817fdd2bf57433c6a0d9e47595"></a><!-- doxytag: member="boost::geometry::has_nan_coordinate" ref="ad4a419817fdd2bf57433c6a0d9e47595" args="(Point const &amp;point)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#ad4a419817fdd2bf57433c6a0d9e47595">boost::geometry::has_nan_coordinate</a> </td>
          <td>(</td>
          <td class="paramtype">Point const &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2f950b91e4e331aff1235ddd25deef72"></a><!-- doxytag: member="boost::geometry::has_non_finite_coordinate" ref="a2f950b91e4e331aff1235ddd25deef72" args="(Point const &amp;point)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceboost_1_1geometry.html#a2f950b91e4e331aff1235ddd25deef72">boost::geometry::has_non_finite_coordinate</a> </td>
          <td>(</td>
          <td class="paramtype">Point const &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a60f531e30e193d8ce30098428d9134c1"></a><!-- doxytag: member="boost::geometry::min_corner" ref="a60f531e30e193d8ce30098428d9134c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int const <a class="el" href="namespaceboost_1_1geometry.html#a60f531e30e193d8ce30098428d9134c1">boost::geometry::min_corner</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Index of minimum corner of the box. </p>

</div>
</div>
<a class="anchor" id="a4a86ce72ed7ddcfc21f8e79445bf683d"></a><!-- doxytag: member="boost::geometry::max_corner" ref="a4a86ce72ed7ddcfc21f8e79445bf683d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int const <a class="el" href="namespaceboost_1_1geometry.html#a4a86ce72ed7ddcfc21f8e79445bf683d">boost::geometry::max_corner</a> = 1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Index of maximum corner of the box. </p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>April 2, 2011</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2007-2011 Barend Gehrels, Amsterdam, the Netherlands<br>
Copyright &copy; 2008-2011 Bruno Lalande, Paris, France<br>
Copyright &copy; 2009-2010 Mateusz Loskot, London, UK<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
