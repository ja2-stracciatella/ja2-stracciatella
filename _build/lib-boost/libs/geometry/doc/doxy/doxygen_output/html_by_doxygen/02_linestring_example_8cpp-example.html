<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.Geometry (aka GGL, Generic Geometry Library)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.Geometry" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">02_linestring_example.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>The linestring example shows how linestrings can be declared and used and shows some more algorithms. One of the important concepts of the Generic Geometry Library is that it is totally built upon the standard library, using the standard containers such as std::vector.</p>
<p>A linestring is, as explained elsewhere in this documentation, not much more than a vector of points. Most algorithms run on linestrings, but can also run on any iterator pair. And all algorithms on std::vector can be used on geometry::linestring.</p>
<p>The sample shows this, shows some algorithms:</p>
<ul>
<li>geometry::envelope</li>
<li>geometry::length</li>
<li>geometry::distance</li>
<li>geometry::simplify</li>
<li>geometry::for_each</li>
<li>geometry::intersection</li>
</ul>
<p>This documentation illustrates the simplify algorithm and the intersection algorithm with some pictures.</p>
<p>The simplify algorithm simplifies a linestring. Simplification means that the less important points are removed from the line and that the points that are most important for the shape of a line are kept. Simplification is done using the well known Douglas Peucker algorithm. The library user can specify the distance or tolerance, which indicates how much the linestring should be simplified.</p>
<p>The image below shows the original and simplified linestring: </p>
<div class="image">
<img src="simplify_linestring.png" alt="simplify_linestring.png"/>
</div>
<p> The blue line is the original linestring; the red line is the simplified line which has one point less. In geographical applications simplification can reduce a linestring to its basic form containing only 10% of its original points.</p>
<p>The intersection algorithm intersects two geometries which each other, delivering a third geometry. In the case of the example a linestring is intersected with a box. Intersection with a box is often called a clip. The image below illustrates the intersection. </p>
<div class="image">
<img src="clip_linestring.png" alt="clip_linestring.png"/>
</div>
<p> The yellow line is intersected with the blue box. The intersection result, painted in red, contains three linestrings.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// Boost.Geometry (aka GGL, Generic Geometry Library)</span>

<span class="comment">// Copyright (c) 2007-2012 Barend Gehrels, Amsterdam, the Netherlands.</span>
<span class="comment">// Copyright (c) 2008-2012 Bruno Lalande, Paris, France.</span>
<span class="comment">// Copyright (c) 2009-2012 Mateusz Loskot, London, UK.</span>

<span class="comment">// Use, modification and distribution is subject to the Boost Software License,</span>
<span class="comment">// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="comment">// http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="comment">//</span>
<span class="comment">// Linestring Example</span>

<span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// for reverse, unique</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;iterator&gt;</span>
<span class="preprocessor">#include &lt;utility&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>

<span class="preprocessor">#include &lt;boost/geometry/geometry.hpp&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="linestring_8hpp.html">boost/geometry/geometries/linestring.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="point__xy_8hpp.html">boost/geometry/geometries/point_xy.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="geometries_2polygon_8hpp.html">boost/geometry/geometries/polygon.hpp</a>&gt;</span>

<span class="comment">// Optional includes and defines to handle c-arrays as points, std::vectors as linestrings</span>
<span class="preprocessor">#include &lt;<a class="code" href="register_2linestring_8hpp.html">boost/geometry/geometries/register/linestring.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="c__array_8hpp.html">boost/geometry/geometries/adapted/c_array.hpp</a>&gt;</span>

<a name="a0"></a><a class="code" href="c__array_8hpp.html#a815278dd46c0e0cbb9188150ef5305a9">BOOST_GEOMETRY_REGISTER_C_ARRAY_CS</a>(cs::cartesian)

<a name="a1"></a><a class="code" href="group__register.html#ga56729e5117bdd1ef2f5df70e113135d1" title="Macro to register a \1.">BOOST_GEOMETRY_REGISTER_LINESTRING_TEMPLATED</a>(std::vector)
<a class="code" href="group__register.html#ga56729e5117bdd1ef2f5df70e113135d1" title="Macro to register a \1.">BOOST_GEOMETRY_REGISTER_LINESTRING_TEMPLATED</a>(std::deque)


template&lt;typename P&gt;
inline <span class="keywordtype">void</span> translate_function(P&amp; p)
{
        p.x(p.x() + 100.0);
}

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> P&gt;
<span class="keyword">struct </span>scale_functor
{
    <span class="keyword">inline</span> <span class="keywordtype">void</span> operator()(P&amp; p)
    {
        p.x(p.x() * 1000.0);
        p.y(p.y() * 1000.0);
    }
};


<span class="keyword">template</span>&lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>&gt;
<span class="keyword">struct </span>round_coordinates
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1geometry_1_1coordinate__type.html#a426b2210908d022e151055d1fed4ac75">boost::geometry::coordinate_type&lt;Point&gt;::type</a> coordinate_type;
    coordinate_type m_factor;

    <span class="keyword">inline</span> round_coordinates(coordinate_type <span class="keyword">const</span>&amp; factor)
        : m_factor(factor)
    {}

    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> Dimension&gt;
    <span class="keyword">inline</span> <span class="keywordtype">void</span> round(Point&amp; p)
    {
        coordinate_type c = boost::geometry::get&lt;Dimension&gt;(p) / m_factor;
        <span class="keywordtype">int</span> rounded = c;
        boost::geometry::set&lt;Dimension&gt;(p, coordinate_type(rounded) * m_factor);
    }

    <span class="keyword">inline</span> <span class="keywordtype">void</span> operator()(Point&amp; p)
    {
        round&lt;0&gt;(p);
        round&lt;1&gt;(p);
    }
};


<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
    <span class="keyword">using namespace </span>boost::geometry;

    <span class="comment">// Define a linestring, which is a vector of points, and add some points</span>
    <span class="comment">// (we add them deliberately in different ways)</span>
    <span class="keyword">typedef</span> <a name="_a2"></a><a class="code" href="classboost_1_1geometry_1_1model_1_1d2_1_1point__xy.html" title="2D point in Cartesian coordinate system">model::d2::point_xy&lt;double&gt;</a> point_2d;
    <span class="keyword">typedef</span> <a name="_a3"></a><a class="code" href="classboost_1_1geometry_1_1model_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">model::linestring&lt;point_2d&gt;</a> linestring_2d;
    linestring_2d ls;

    <span class="comment">// points can be created using &quot;make&quot; and added to a linestring using the std:: &quot;push_back&quot;</span>
    ls.push_back(make&lt;point_2d&gt;(1.1, 1.1));

    <span class="comment">// points can also be assigned using &quot;assign_values&quot; and added to a linestring using &quot;append&quot;</span>
    point_2d lp;
    <a name="a4"></a><a class="code" href="group__assign.html#ga9ee6c10e38a19e8e52bf9a1fc5a19a05" title="Assign two coordinates to a geometry (usually a 2D point)">assign_values</a>(lp, 2.5, 2.1);
    <a name="a5"></a><a class="code" href="group__append.html#gaa3a95c7738229a30f77562cb095b3699" title="Appends one or more points to a linestring, ring, polygon, multi-geometry.">append</a>(ls, lp);

    <span class="comment">// Lines can be streamed using DSV (delimiter separated values)</span>
    std::cout &lt;&lt; dsv(ls) &lt;&lt; std::endl;

    <span class="comment">// The bounding box of linestrings can be calculated</span>
    <span class="keyword">typedef</span> <a name="_a6"></a><a class="code" href="classboost_1_1geometry_1_1model_1_1box.html" title="Class box: defines a box made of two describing points.">model::box&lt;point_2d&gt;</a> box_2d;
    box_2d b;
    <a name="a7"></a><a class="code" href="group__envelope.html#gac1f1865a7b36047d44949e17266d8f5a" title="Calculates the envelope of a geometry.">envelope</a>(ls, b);
    std::cout &lt;&lt; dsv(b) &lt;&lt; std::endl;

    <span class="comment">// The length of the line can be calulated</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;length: &quot;</span> &lt;&lt; <a name="a8"></a><a class="code" href="group__length.html#ga38dff36b8deb6a1a8cb0a3d6387af8fc" title="Calculates the length of a geometry.">length</a>(ls) &lt;&lt; std::endl;

    <span class="comment">// All things from std::vector can be called, because a linestring is a vector</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;number of points 1: &quot;</span> &lt;&lt; ls.size() &lt;&lt; std::endl;

    <span class="comment">// All things from boost ranges can be called because a linestring is considered as a range</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;number of points 2: &quot;</span> &lt;&lt; boost::size(ls) &lt;&lt; std::endl;

    <span class="comment">// Generic function from geometry/OGC delivers the same value</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;number of points 3: &quot;</span> &lt;&lt; <a name="a9"></a><a class="code" href="group__num__points.html#ga4e90b249b3cf16e4ef8f486df042aacd" title="Calculates the number of points of a geometry.">num_points</a>(ls) &lt;&lt; std::endl;

    <span class="comment">// The distance from a point to a linestring can be calculated</span>
    point_2d p(1.9, 1.2);
    std::cout &lt;&lt; <span class="stringliteral">&quot;distance of &quot;</span> &lt;&lt; dsv(p)
        &lt;&lt; <span class="stringliteral">&quot; to line: &quot;</span> &lt;&lt; <a name="a10"></a><a class="code" href="group__distance.html#ga7d68c34d1ded4428903f906244b31da4" title="Calculate the distance of two geometries using the specified strategy.">distance</a>(p, ls) &lt;&lt; std::endl;

    <span class="comment">// A linestring is a vector. However, some algorithms consider &quot;segments&quot;,</span>
    <span class="comment">// which are the line pieces between two points of a linestring.</span>
    <span class="keywordtype">double</span> d = <a class="code" href="group__distance.html#ga7d68c34d1ded4428903f906244b31da4" title="Calculate the distance of two geometries using the specified strategy.">distance</a>(p, <a name="_a11"></a><a class="code" href="classboost_1_1geometry_1_1model_1_1segment.html" title="Class segment: small class containing two points.">model::segment&lt;point_2d &gt;</a>(ls.front(), ls.back()));
    std::cout &lt;&lt; <span class="stringliteral">&quot;distance: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;

    <span class="comment">// Add some three points more, let&#39;s do it using a classic array.</span>
    <span class="comment">// (See documentation for picture of this linestring)</span>
    <span class="keyword">const</span> <span class="keywordtype">double</span> c[][2] = { {3.1, 3.1}, {4.9, 1.1}, {3.1, 1.9} };
    <a class="code" href="group__append.html#gaa3a95c7738229a30f77562cb095b3699" title="Appends one or more points to a linestring, ring, polygon, multi-geometry.">append</a>(ls, c);
    std::cout &lt;&lt; <span class="stringliteral">&quot;appended: &quot;</span> &lt;&lt; dsv(ls) &lt;&lt; std::endl;

    <span class="comment">// Output as iterator-pair on a vector</span>
    {
        std::vector&lt;point_2d&gt; v;
        std::copy(ls.begin(), ls.end(), <a name="a12"></a><a class="code" href="namespaceboost_1_1geometry_1_1range.html#a1e6b151e65be317d5cfaadfd26f5135e">std::back_inserter</a>(v));

        std::cout
            &lt;&lt; <span class="stringliteral">&quot;as vector: &quot;</span>
            &lt;&lt; dsv(v)
            &lt;&lt; std::endl;
    }

    <span class="comment">// All algorithms from std can be used: a linestring is a vector</span>
    <a name="a13"></a><a class="code" href="group__reverse.html#ga9d0e06498236cee4517168b4cb231998" title="Reverses the points within a geometry.">std::reverse</a>(ls.begin(), ls.end());
    std::cout &lt;&lt; <span class="stringliteral">&quot;reversed: &quot;</span> &lt;&lt; dsv(ls) &lt;&lt; std::endl;
    <a class="code" href="group__reverse.html#ga9d0e06498236cee4517168b4cb231998" title="Reverses the points within a geometry.">std::reverse</a>(boost::begin(ls), boost::end(ls));

    <span class="comment">// The other way, using a vector instead of a linestring, is also possible</span>
    std::vector&lt;point_2d&gt; pv(ls.begin(), ls.end());
    std::cout &lt;&lt; <span class="stringliteral">&quot;length: &quot;</span> &lt;&lt; <a class="code" href="group__length.html#ga38dff36b8deb6a1a8cb0a3d6387af8fc" title="Calculates the length of a geometry.">length</a>(pv) &lt;&lt; std::endl;

    <span class="comment">// If there are double points in the line, you can use unique to remove them</span>
    <span class="comment">// So we add the last point, print, make a unique copy and print</span>
    {
        <span class="comment">// (sidenote, we have to make copies, because</span>
        <span class="comment">// ls.push_back(ls.back()) often succeeds but</span>
        <span class="comment">// IS dangerous and erroneous!</span>
        point_2d last = ls.back(), first = ls.front();
        ls.push_back(last);
        ls.insert(ls.begin(), first);
    }
    std::cout &lt;&lt; <span class="stringliteral">&quot;extra duplicate points: &quot;</span> &lt;&lt; dsv(ls) &lt;&lt; std::endl;

    {
        linestring_2d ls_copy;
        std::unique_copy(ls.begin(), ls.end(), <a class="code" href="namespaceboost_1_1geometry_1_1range.html#a1e6b151e65be317d5cfaadfd26f5135e">std::back_inserter</a>(ls_copy),
            <a name="_a14"></a><a class="code" href="structboost_1_1geometry_1_1equal__to.html" title="Equal To functor, to compare if points are equal.">boost::geometry::equal_to&lt;point_2d&gt;</a>());
        ls = ls_copy;
        std::cout &lt;&lt; <span class="stringliteral">&quot;uniquecopy: &quot;</span> &lt;&lt; dsv(ls) &lt;&lt; std::endl;
    }

    <span class="comment">// Lines can be simplified. This removes points, but preserves the shape</span>
    linestring_2d ls_simplified;
    <a name="a15"></a><a class="code" href="group__simplify.html#ga8f1c13c0fe844ffdaa6196ce3854849f" title="Simplify a geometry using a specified strategy.">simplify</a>(ls, ls_simplified, 0.5);
    std::cout &lt;&lt; <span class="stringliteral">&quot;simplified: &quot;</span> &lt;&lt; dsv(ls_simplified) &lt;&lt; std::endl;


    <span class="comment">// for_each:</span>
    <span class="comment">// 1) Lines can be visited with std::for_each</span>
    <span class="comment">// 2) for_each_point is also defined for all geometries</span>
    <span class="comment">// 3) for_each_segment is defined for all geometries to all segments</span>
    <span class="comment">// 4) loop is defined for geometries to visit segments</span>
    <span class="comment">//    with state apart, and to be able to break out (not shown here)</span>
    {
        linestring_2d lscopy = ls;
        std::for_each(lscopy.begin(), lscopy.end(), translate_function&lt;point_2d&gt;);
        <a name="a16"></a><a class="code" href="group__for__each.html#ga3010849a8b501309db7b74157382cfaf" title="Applies function [*f] to each \1.">for_each_point</a>(lscopy, scale_functor&lt;point_2d&gt;());
        <a class="code" href="group__for__each.html#ga3010849a8b501309db7b74157382cfaf" title="Applies function [*f] to each \1.">for_each_point</a>(lscopy, translate_function&lt;point_2d&gt;);
        std::cout &lt;&lt; <span class="stringliteral">&quot;modified line: &quot;</span> &lt;&lt; dsv(lscopy) &lt;&lt; std::endl;
    }

    <span class="comment">// Lines can be clipped using a clipping box. Clipped lines are added to the output iterator</span>
    box_2d cb(point_2d(1.5, 1.5), point_2d(4.5, 2.5));

    std::vector&lt;linestring_2d&gt; clipped;
    <a name="a17"></a><a class="code" href="group__intersection.html#gac78b88e0ea7af3453a626a0e6fc588d7" title="Calculate the intersection of two geometries.">intersection</a>(cb, ls, clipped);

    <span class="comment">// Also possible: clip-output to a vector of vectors</span>
    std::vector&lt;std::vector&lt;point_2d&gt; &gt; vector_out;
    <a class="code" href="group__intersection.html#gac78b88e0ea7af3453a626a0e6fc588d7" title="Calculate the intersection of two geometries.">intersection</a>(cb, ls, vector_out);

    std::cout &lt;&lt; <span class="stringliteral">&quot;clipped output as vector:&quot;</span> &lt;&lt; std::endl;
    <span class="keywordflow">for</span> (std::vector&lt;std::vector&lt;point_2d&gt; &gt;::const_iterator it
            = vector_out.begin(); it != vector_out.end(); ++it)
    {
        std::cout &lt;&lt; dsv(*it) &lt;&lt; std::endl;
    }

    <span class="comment">// Calculate the convex hull of the linestring</span>
    <a name="_a18"></a><a class="code" href="classboost_1_1geometry_1_1model_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">model::polygon&lt;point_2d&gt;</a> hull;
    <a name="a19"></a><a class="code" href="namespaceboost_1_1geometry.html#a5f0f6e4d01982d810d1ad1c1817521cb">convex_hull</a>(ls, hull);
    std::cout &lt;&lt; <span class="stringliteral">&quot;Convex hull:&quot;</span> &lt;&lt; dsv(hull) &lt;&lt; std::endl;

    <span class="comment">// All the above assumed 2D Cartesian linestrings. 3D is possible as well</span>
    <span class="comment">// Let&#39;s define a 3D point ourselves, this time using &#39;float&#39;</span>
    <span class="keyword">typedef</span> <a name="_a20"></a><a class="code" href="classboost_1_1geometry_1_1model_1_1point.html" title="Basic point class, having coordinates defined in a neutral way.">model::point&lt;float, 3, cs::cartesian&gt;</a> point_3d;
    <a class="code" href="classboost_1_1geometry_1_1model_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">model::linestring&lt;point_3d&gt;</a> line3;
    line3.push_back(make&lt;point_3d&gt;(1,2,3));
    line3.push_back(make&lt;point_3d&gt;(4,5,6));
    line3.push_back(make&lt;point_3d&gt;(7,8,9));

    <span class="comment">// Not all algorithms work on 3d lines. For example convex hull does NOT.</span>
    <span class="comment">// But, for example, length, distance, simplify, envelope and stream do.</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;3D: length: &quot;</span> &lt;&lt; <a class="code" href="group__length.html#ga38dff36b8deb6a1a8cb0a3d6387af8fc" title="Calculates the length of a geometry.">length</a>(line3) &lt;&lt; <span class="stringliteral">&quot; line: &quot;</span> &lt;&lt; dsv(line3) &lt;&lt; std::endl;

    <span class="comment">// With DSV you can also use other delimiters, e.g. JSON style</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;JSON: &quot;</span>
        &lt;&lt; dsv(ls, <span class="stringliteral">&quot;, &quot;</span>, <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>, <span class="stringliteral">&quot;, &quot;</span>, <span class="stringliteral">&quot;[ &quot;</span>, <span class="stringliteral">&quot; ]&quot;</span>)
        &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> </div><!-- contents -->
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>April 2, 2011</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2007-2011 Barend Gehrels, Amsterdam, the Netherlands<br>
Copyright &copy; 2008-2011 Bruno Lalande, Paris, France<br>
Copyright &copy; 2009-2010 Mateusz Loskot, London, UK<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
