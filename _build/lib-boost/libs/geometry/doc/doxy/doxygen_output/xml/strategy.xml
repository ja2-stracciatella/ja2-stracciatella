<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="strategy" kind="page">
    <compoundname>strategy</compoundname>
    <title>Strategy rationale</title>
    <detaileddescription>
<sect1 id="strategy_1strpar1">
<title>Purpose of strategies</title>
<para>A strategy is (Wikipedia, <ulink url="http://en.wikipedia.org/wiki/Strategy_pattern">http://en.wikipedia.org/wiki/Strategy_pattern</ulink>) a software design pattern whereby algorithms can be selected at runtime. According to Wikipedia, it is also known as the Policy pattern. In the C++ template contexts, policies are usually meant as selecting functionality at compile time. so it is reasonable to state that a strategy can also be used at compile-time</para><para>Within GGL the term policy is used (sparsely), but in a broader, or in another context. The term Strategy is used specificly for a computation method targeted to a specific coordinate system</para><para>GGL-Strategies do have the following purposes:<itemizedlist>
<listitem><para>for each coordinate system, a default strategy is selected by compile time, using the coordinate system tag. This is effectively tag dispatching.</para></listitem><listitem><para>users can override the default choice by using the overloaded function, which has a strategy as an extra parameter, and take another strategy</para></listitem><listitem><para>users can override the default choice by using the overloaded function, to use the default strategy, but constructed with specific parameters</para></listitem><listitem><para>users can override the default choice by using the overloaded function, to use the default strategy (which can be a templated structure), with other template parameters then the default ones</para></listitem><listitem><para>users can override the default choice by using the overloaded function, to use the default strategy (which can be a templated structure), with other template parameters then the default ones, with the specific purpose as to select another calculation type (e.g. GMP or another big number type)</para></listitem></itemizedlist>
</para><para>All this happens at compile-time.</para><para>For example (this is also explained in the design rationale) the distance functionality. The default distance strategy for point-point is Pythagoras (for cartesian coordinate systems) or Haversine (for spherical) or Andoyer (for geographic). Haversine works on the unit sphere, radius 1. Library users can use the distance function, specifying haversine strategy constructed with a radius of 2. Or they can use the distance function, specifying the more precise Vincenty strategy (for geographic coordinate systems, but that might not even be checked there). Specifying strategies is useful, even if not point-point distance is to be calculated, but e.g. point-polygon distance. In the end it will call the elementary specified functionality. Note that, for this example, the point-segment distance strategy is also &quot;elementary&quot;. Note also that it can have an optional template parameter defining the underlying point-point-distance-strategy.</para></sect1>
<sect1 id="strategy_1strpar2">
<title>Properties of strategies</title>
<para>Because strategies can be constructed outside the calling function, they can be specified as an optional parameter (implemented as an overloaded function), and not as only a template-parameter. Furthermore, strategies might be used several times, in several function calls. Therefore they are declared as const reference parameter, they should be stateless (besides construction information).</para><para>The strategy needs to access construction information (member variables), its calculation method is therefore usually not a static method but a non-static const method. It can then access member variables, while still being const, non-mutable, stateless, being able to be called across several function calls. If often has to keep some calculation information (state), so it should (for some algorithms) declare a state_type. In those cases, that state_type is instantiated before first call and specified in each call. The calculation method is always called <bold>apply</bold> (as convention in GGL) and gets the most elementary information as a parameter: a point, a segment, a range. It depends on the algorithm and, sometimes, on the source geometry passed. That should actually be the case as least as possible In most cases, there is an additional method <bold>result</bold> which returns the calculated result. That result-method is a also non-static const method, and the state is passed. Note that the methods might be non-static const, but they might also be static. That is not checked by the concept-checker.</para><para>A strategy for a specific algorithm has a concept. The distance-strategy should follow the distance-strategy-concept. The point-in-polygon strategy should follow the point-in-polygon-strategy-concept. Those concepts are not modelled as traits classes (contrary to the geometries). The reason for this is that it seems not necessary to use legacy classes as concepts, without modification. A wrapper can be built. So the strategies should have a method <bold>apply</bold> and should define some types.</para><para>Which types, and which additional methods (often a method <bold>result</bold>), is dependant on the algorithm / type of strategy.</para><para>Strategies are checked by a strategy-concept-checker. For this checker (and sometimes for checking alone), they should define some types. Because if no types are defined, the methods cannot be checked at compile time... The strategy-concept-checkers are thus implemented per algorithm and they use the Boost Concept Check Library for checking.</para><para>So as explained above, the essence of the design is:<itemizedlist>
<listitem><para>function determines default-strategy, or is called with specified strategy</para></listitem><listitem><para>function calls dispatch (dispatching is done on geometry_tag)</para></listitem><listitem><para>dispatch calls implementation (in namespace detail), which can be shared for different geometry types and for single/multi</para></listitem><listitem><para>implementation calls strategy (if applicable), with the smallest common (geometric) element applicable for all calculation method, the common denominator</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="strategy_1strpar3">
<title>Alternative designs</title>
<para>Some calculations (strategies) might need to take the whole geometry, instead of working on point-per-point or segment-per-segment base. This would bypass the dispatch functionality. Because all strategies would take the whole geometry, it is not necessary to dispatch per geometry type. In fact this dispatching on geometry-type is moved to the strategy_traits class (which are specialized per coordinate system in the current design). So in this alternative design, the strategy traits class specializes on both geometry-tag and coordinate-system-tag, to select the default strategy. For the default strategy, this move from &quot;dispatch&quot; to another dispatch called &quot;strategy_XXX&quot; (XXX is the algorithm) might make sense. However, if library users would call the overloaded function and specify a strategy, the only thing what would happen is that that specified strategy is called. So, for example: <programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>G1,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>G2,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>S&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="group__within_1gaf8f597c0a7352f0a6808944db2a549b7" kindref="member" tooltip="Checks if the first geometry is completely inside the second geometry.">within</ref>(G1<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>g1,<sp/>G2<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>g2,<sp/>S&amp;<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>strategy)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>strategy.apply(g1,<sp/>g2);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The library user could call just this strategy.apply(..) method directly. If more strategies are provided by the library or its extensions, it would still make sense: the user can still call <bold>within</bold> and does not have to call the <bold>apply</bold> method of the strategy.</para><para>The convex hull strategy currently works on a whole geometry. However, it is possible that it will be reshaped to work per range (the algorithm internally works per range), plus a mechanism to pass ranges multiple times (it currently is two-pass). </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
