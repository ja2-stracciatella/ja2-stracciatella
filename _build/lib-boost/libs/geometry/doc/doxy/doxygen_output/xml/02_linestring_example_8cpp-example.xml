<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="02_linestring_example_8cpp-example" kind="example">
    <compoundname>02_linestring_example.cpp</compoundname>
    <detaileddescription>
<para>The linestring example shows how linestrings can be declared and used and shows some more algorithms. One of the important concepts of the Generic Geometry Library is that it is totally built upon the standard library, using the standard containers such as std::vector.</para><para>A linestring is, as explained elsewhere in this documentation, not much more than a vector of points. Most algorithms run on linestrings, but can also run on any iterator pair. And all algorithms on std::vector can be used on geometry::linestring.</para><para>The sample shows this, shows some algorithms:<itemizedlist>
<listitem><para>geometry::envelope</para></listitem><listitem><para>geometry::length</para></listitem><listitem><para>geometry::distance</para></listitem><listitem><para>geometry::simplify</para></listitem><listitem><para>geometry::for_each</para></listitem><listitem><para>geometry::intersection</para></listitem></itemizedlist>
</para><para>This documentation illustrates the simplify algorithm and the intersection algorithm with some pictures.</para><para>The simplify algorithm simplifies a linestring. Simplification means that the less important points are removed from the line and that the points that are most important for the shape of a line are kept. Simplification is done using the well known Douglas Peucker algorithm. The library user can specify the distance or tolerance, which indicates how much the linestring should be simplified.</para><para>The image below shows the original and simplified linestring: <image type="html" name="simplify_linestring.png"></image>
 The blue line is the original linestring; the red line is the simplified line which has one point less. In geographical applications simplification can reduce a linestring to its basic form containing only 10% of its original points.</para><para>The intersection algorithm intersects two geometries which each other, delivering a third geometry. In the case of the example a linestring is intersected with a box. Intersection with a box is often called a clip. The image below illustrates the intersection. <image type="html" name="clip_linestring.png"></image>
 The yellow line is intersected with the blue box. The intersection result, painted in red, contains three linestrings. <programlisting><codeline><highlight class="comment">//<sp/>Boost.Geometry<sp/>(aka<sp/>GGL,<sp/>Generic<sp/>Geometry<sp/>Library)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Copyright<sp/>(c)<sp/>2007-2012<sp/>Barend<sp/>Gehrels,<sp/>Amsterdam,<sp/>the<sp/>Netherlands.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Copyright<sp/>(c)<sp/>2008-2012<sp/>Bruno<sp/>Lalande,<sp/>Paris,<sp/>France.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Copyright<sp/>(c)<sp/>2009-2012<sp/>Mateusz<sp/>Loskot,<sp/>London,<sp/>UK.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Use,<sp/>modification<sp/>and<sp/>distribution<sp/>is<sp/>subject<sp/>to<sp/>the<sp/>Boost<sp/>Software<sp/>License,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Version<sp/>1.0.<sp/>(See<sp/>accompanying<sp/>file<sp/>LICENSE_1_0.txt<sp/>or<sp/>copy<sp/>at</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>http://www.boost.org/LICENSE_1_0.txt)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Linestring<sp/>Example</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>for<sp/>reverse,<sp/>unique</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iterator&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/geometry/geometry.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="linestring_8hpp" kindref="compound">boost/geometry/geometries/linestring.hpp</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="point__xy_8hpp" kindref="compound">boost/geometry/geometries/point_xy.hpp</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="geometries_2polygon_8hpp" kindref="compound">boost/geometry/geometries/polygon.hpp</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Optional<sp/>includes<sp/>and<sp/>defines<sp/>to<sp/>handle<sp/>c-arrays<sp/>as<sp/>points,<sp/>std::vectors<sp/>as<sp/>linestrings</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="register_2linestring_8hpp" kindref="compound">boost/geometry/geometries/register/linestring.hpp</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="c__array_8hpp" kindref="compound">boost/geometry/geometries/adapted/c_array.hpp</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="c__array_8hpp_1a815278dd46c0e0cbb9188150ef5305a9" kindref="member">BOOST_GEOMETRY_REGISTER_C_ARRAY_CS</ref>(cs::cartesian)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__register_1ga56729e5117bdd1ef2f5df70e113135d1" kindref="member" tooltip="Macro to register a \1.">BOOST_GEOMETRY_REGISTER_LINESTRING_TEMPLATED</ref>(std::vector)</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__register_1ga56729e5117bdd1ef2f5df70e113135d1" kindref="member" tooltip="Macro to register a \1.">BOOST_GEOMETRY_REGISTER_LINESTRING_TEMPLATED</ref>(std::deque)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>P&gt;</highlight></codeline>
<codeline><highlight class="normal">inline<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>translate_function(P&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p.x(p.x()<sp/>+<sp/>100.0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>P&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">scale_functor</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(P&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p.x(p.x()<sp/>*<sp/>1000.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p.y(p.y()<sp/>*<sp/>1000.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Po</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">round_coordinates</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="structboost_1_1geometry_1_1coordinate__type_1a426b2210908d022e151055d1fed4ac75" kindref="member">boost::geometry::coordinate_type&lt;Point&gt;::type</ref><sp/>coordinate_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinate_type<sp/>m_factor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>round_coordinates(coordinate_type<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>factor)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>m_factor(factor)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Dimension&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>round(Point&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>coordinate_type<sp/>c<sp/>=<sp/>boost::geometry::get&lt;Dimension&gt;(p)<sp/>/<sp/>m_factor;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>rounded<sp/>=<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::geometry::set&lt;Dimension&gt;(p,<sp/>coordinate_type(rounded)<sp/>*<sp/>m_factor);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(Point&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>round&lt;0&gt;(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>round&lt;1&gt;(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">boost::geometry;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>linestring,<sp/>which<sp/>is<sp/>a<sp/>vector<sp/>of<sp/>points,<sp/>and<sp/>add<sp/>some<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(we<sp/>add<sp/>them<sp/>deliberately<sp/>in<sp/>different<sp/>ways)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classboost_1_1geometry_1_1model_1_1d2_1_1point__xy" kindref="compound" tooltip="2D point in Cartesian coordinate system">model::d2::point_xy&lt;double&gt;</ref><sp/>point_2d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classboost_1_1geometry_1_1model_1_1linestring" kindref="compound" tooltip="A linestring (named so by OGC) is a collection (default a vector) of points.">model::linestring&lt;point_2d&gt;</ref><sp/>linestring_2d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>linestring_2d<sp/>ls;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>points<sp/>can<sp/>be<sp/>created<sp/>using<sp/>&quot;make&quot;<sp/>and<sp/>added<sp/>to<sp/>a<sp/>linestring<sp/>using<sp/>the<sp/>std::<sp/>&quot;push_back&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ls.push_back(make&lt;point_2d&gt;(1.1,<sp/>1.1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>points<sp/>can<sp/>also<sp/>be<sp/>assigned<sp/>using<sp/>&quot;assign_values&quot;<sp/>and<sp/>added<sp/>to<sp/>a<sp/>linestring<sp/>using<sp/>&quot;append&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_2d<sp/>lp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__assign_1ga9ee6c10e38a19e8e52bf9a1fc5a19a05" kindref="member" tooltip="Assign two coordinates to a geometry (usually a 2D point)">assign_values</ref>(lp,<sp/>2.5,<sp/>2.1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__append_1gaa3a95c7738229a30f77562cb095b3699" kindref="member" tooltip="Appends one or more points to a linestring, ring, polygon, multi-geometry.">append</ref>(ls,<sp/>lp);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Lines<sp/>can<sp/>be<sp/>streamed<sp/>using<sp/>DSV<sp/>(delimiter<sp/>separated<sp/>values)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>dsv(ls)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>bounding<sp/>box<sp/>of<sp/>linestrings<sp/>can<sp/>be<sp/>calculated</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classboost_1_1geometry_1_1model_1_1box" kindref="compound" tooltip="Class box: defines a box made of two describing points.">model::box&lt;point_2d&gt;</ref><sp/>box_2d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>box_2d<sp/>b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__envelope_1gac1f1865a7b36047d44949e17266d8f5a" kindref="member" tooltip="Calculates the envelope of a geometry.">envelope</ref>(ls,<sp/>b);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>dsv(b)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>length<sp/>of<sp/>the<sp/>line<sp/>can<sp/>be<sp/>calulated</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;length:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__length_1ga38dff36b8deb6a1a8cb0a3d6387af8fc" kindref="member" tooltip="Calculates the length of a geometry.">length</ref>(ls)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>things<sp/>from<sp/>std::vector<sp/>can<sp/>be<sp/>called,<sp/>because<sp/>a<sp/>linestring<sp/>is<sp/>a<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;number<sp/>of<sp/>points<sp/>1:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>ls.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>things<sp/>from<sp/>boost<sp/>ranges<sp/>can<sp/>be<sp/>called<sp/>because<sp/>a<sp/>linestring<sp/>is<sp/>considered<sp/>as<sp/>a<sp/>range</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;number<sp/>of<sp/>points<sp/>2:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>boost::size(ls)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Generic<sp/>function<sp/>from<sp/>geometry/OGC<sp/>delivers<sp/>the<sp/>same<sp/>value</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;number<sp/>of<sp/>points<sp/>3:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__num__points_1ga4e90b249b3cf16e4ef8f486df042aacd" kindref="member" tooltip="Calculates the number of points of a geometry.">num_points</ref>(ls)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>distance<sp/>from<sp/>a<sp/>point<sp/>to<sp/>a<sp/>linestring<sp/>can<sp/>be<sp/>calculated</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_2d<sp/>p(1.9,<sp/>1.2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;distance<sp/>of<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dsv(p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>to<sp/>line:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__distance_1ga7d68c34d1ded4428903f906244b31da4" kindref="member" tooltip="Calculate the distance of two geometries using the specified strategy.">distance</ref>(p,<sp/>ls)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>A<sp/>linestring<sp/>is<sp/>a<sp/>vector.<sp/>However,<sp/>some<sp/>algorithms<sp/>consider<sp/>&quot;segments&quot;,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>which<sp/>are<sp/>the<sp/>line<sp/>pieces<sp/>between<sp/>two<sp/>points<sp/>of<sp/>a<sp/>linestring.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>d<sp/>=<sp/><ref refid="group__distance_1ga7d68c34d1ded4428903f906244b31da4" kindref="member" tooltip="Calculate the distance of two geometries using the specified strategy.">distance</ref>(p,<sp/><ref refid="classboost_1_1geometry_1_1model_1_1segment" kindref="compound" tooltip="Class segment: small class containing two points.">model::segment&lt;point_2d &gt;</ref>(ls.front(),<sp/>ls.back()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;distance:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>d<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>some<sp/>three<sp/>points<sp/>more,<sp/>let&apos;s<sp/>do<sp/>it<sp/>using<sp/>a<sp/>classic<sp/>array.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(See<sp/>documentation<sp/>for<sp/>picture<sp/>of<sp/>this<sp/>linestring)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>c[][2]<sp/>=<sp/>{<sp/>{3.1,<sp/>3.1},<sp/>{4.9,<sp/>1.1},<sp/>{3.1,<sp/>1.9}<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__append_1gaa3a95c7738229a30f77562cb095b3699" kindref="member" tooltip="Appends one or more points to a linestring, ring, polygon, multi-geometry.">append</ref>(ls,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;appended:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dsv(ls)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>as<sp/>iterator-pair<sp/>on<sp/>a<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;point_2d&gt;<sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::copy(ls.begin(),<sp/>ls.end(),<sp/><ref refid="namespaceboost_1_1geometry_1_1range_1a1e6b151e65be317d5cfaadfd26f5135e" kindref="member">std::back_inserter</ref>(v));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;as<sp/>vector:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>dsv(v)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>algorithms<sp/>from<sp/>std<sp/>can<sp/>be<sp/>used:<sp/>a<sp/>linestring<sp/>is<sp/>a<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__reverse_1ga9d0e06498236cee4517168b4cb231998" kindref="member" tooltip="Reverses the points within a geometry.">std::reverse</ref>(ls.begin(),<sp/>ls.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;reversed:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dsv(ls)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__reverse_1ga9d0e06498236cee4517168b4cb231998" kindref="member" tooltip="Reverses the points within a geometry.">std::reverse</ref>(boost::begin(ls),<sp/>boost::end(ls));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>other<sp/>way,<sp/>using<sp/>a<sp/>vector<sp/>instead<sp/>of<sp/>a<sp/>linestring,<sp/>is<sp/>also<sp/>possible</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;point_2d&gt;<sp/>pv(ls.begin(),<sp/>ls.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;length:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__length_1ga38dff36b8deb6a1a8cb0a3d6387af8fc" kindref="member" tooltip="Calculates the length of a geometry.">length</ref>(pv)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>there<sp/>are<sp/>double<sp/>points<sp/>in<sp/>the<sp/>line,<sp/>you<sp/>can<sp/>use<sp/>unique<sp/>to<sp/>remove<sp/>them</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>So<sp/>we<sp/>add<sp/>the<sp/>last<sp/>point,<sp/>print,<sp/>make<sp/>a<sp/>unique<sp/>copy<sp/>and<sp/>print</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(sidenote,<sp/>we<sp/>have<sp/>to<sp/>make<sp/>copies,<sp/>because</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>ls.push_back(ls.back())<sp/>often<sp/>succeeds<sp/>but</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>IS<sp/>dangerous<sp/>and<sp/>erroneous!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point_2d<sp/>last<sp/>=<sp/>ls.back(),<sp/>first<sp/>=<sp/>ls.front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ls.push_back(last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ls.insert(ls.begin(),<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;extra<sp/>duplicate<sp/>points:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dsv(ls)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>linestring_2d<sp/>ls_copy;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::unique_copy(ls.begin(),<sp/>ls.end(),<sp/><ref refid="namespaceboost_1_1geometry_1_1range_1a1e6b151e65be317d5cfaadfd26f5135e" kindref="member">std::back_inserter</ref>(ls_copy),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structboost_1_1geometry_1_1equal__to" kindref="compound" tooltip="Equal To functor, to compare if points are equal.">boost::geometry::equal_to&lt;point_2d&gt;</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ls<sp/>=<sp/>ls_copy;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;uniquecopy:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dsv(ls)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Lines<sp/>can<sp/>be<sp/>simplified.<sp/>This<sp/>removes<sp/>points,<sp/>but<sp/>preserves<sp/>the<sp/>shape</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>linestring_2d<sp/>ls_simplified;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__simplify_1ga8f1c13c0fe844ffdaa6196ce3854849f" kindref="member" tooltip="Simplify a geometry using a specified strategy.">simplify</ref>(ls,<sp/>ls_simplified,<sp/>0.5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;simplified:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dsv(ls_simplified)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for_each:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1)<sp/>Lines<sp/>can<sp/>be<sp/>visited<sp/>with<sp/>std::for_each</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2)<sp/>for_each_point<sp/>is<sp/>also<sp/>defined<sp/>for<sp/>all<sp/>geometries</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3)<sp/>for_each_segment<sp/>is<sp/>defined<sp/>for<sp/>all<sp/>geometries<sp/>to<sp/>all<sp/>segments</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>4)<sp/>loop<sp/>is<sp/>defined<sp/>for<sp/>geometries<sp/>to<sp/>visit<sp/>segments</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>with<sp/>state<sp/>apart,<sp/>and<sp/>to<sp/>be<sp/>able<sp/>to<sp/>break<sp/>out<sp/>(not<sp/>shown<sp/>here)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>linestring_2d<sp/>lscopy<sp/>=<sp/>ls;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::for_each(lscopy.begin(),<sp/>lscopy.end(),<sp/>translate_function&lt;point_2d&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__for__each_1ga3010849a8b501309db7b74157382cfaf" kindref="member" tooltip="Applies function [*f] to each \1.">for_each_point</ref>(lscopy,<sp/>scale_functor&lt;point_2d&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__for__each_1ga3010849a8b501309db7b74157382cfaf" kindref="member" tooltip="Applies function [*f] to each \1.">for_each_point</ref>(lscopy,<sp/>translate_function&lt;point_2d&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;modified<sp/>line:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dsv(lscopy)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Lines<sp/>can<sp/>be<sp/>clipped<sp/>using<sp/>a<sp/>clipping<sp/>box.<sp/>Clipped<sp/>lines<sp/>are<sp/>added<sp/>to<sp/>the<sp/>output<sp/>iterator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>box_2d<sp/>cb(point_2d(1.5,<sp/>1.5),<sp/>point_2d(4.5,<sp/>2.5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;linestring_2d&gt;<sp/>clipped;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__intersection_1gac78b88e0ea7af3453a626a0e6fc588d7" kindref="member" tooltip="Calculate the intersection of two geometries.">intersection</ref>(cb,<sp/>ls,<sp/>clipped);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Also<sp/>possible:<sp/>clip-output<sp/>to<sp/>a<sp/>vector<sp/>of<sp/>vectors</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::vector&lt;point_2d&gt;<sp/>&gt;<sp/>vector_out;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__intersection_1gac78b88e0ea7af3453a626a0e6fc588d7" kindref="member" tooltip="Calculate the intersection of two geometries.">intersection</ref>(cb,<sp/>ls,<sp/>vector_out);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;clipped<sp/>output<sp/>as<sp/>vector:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::vector&lt;std::vector&lt;point_2d&gt;<sp/>&gt;::const_iterator<sp/>it</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>vector_out.begin();<sp/>it<sp/>!=<sp/>vector_out.end();<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>dsv(*it)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>the<sp/>convex<sp/>hull<sp/>of<sp/>the<sp/>linestring</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classboost_1_1geometry_1_1model_1_1polygon" kindref="compound" tooltip="The polygon contains an outer ring and zero or more inner rings.">model::polygon&lt;point_2d&gt;</ref><sp/>hull;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespaceboost_1_1geometry_1a5f0f6e4d01982d810d1ad1c1817521cb" kindref="member">convex_hull</ref>(ls,<sp/>hull);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Convex<sp/>hull:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dsv(hull)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>the<sp/>above<sp/>assumed<sp/>2D<sp/>Cartesian<sp/>linestrings.<sp/>3D<sp/>is<sp/>possible<sp/>as<sp/>well</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Let&apos;s<sp/>define<sp/>a<sp/>3D<sp/>point<sp/>ourselves,<sp/>this<sp/>time<sp/>using<sp/>&apos;float&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classboost_1_1geometry_1_1model_1_1point" kindref="compound" tooltip="Basic point class, having coordinates defined in a neutral way.">model::point&lt;float, 3, cs::cartesian&gt;</ref><sp/>point_3d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classboost_1_1geometry_1_1model_1_1linestring" kindref="compound" tooltip="A linestring (named so by OGC) is a collection (default a vector) of points.">model::linestring&lt;point_3d&gt;</ref><sp/>line3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>line3.push_back(make&lt;point_3d&gt;(1,2,3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>line3.push_back(make&lt;point_3d&gt;(4,5,6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>line3.push_back(make&lt;point_3d&gt;(7,8,9));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Not<sp/>all<sp/>algorithms<sp/>work<sp/>on<sp/>3d<sp/>lines.<sp/>For<sp/>example<sp/>convex<sp/>hull<sp/>does<sp/>NOT.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>But,<sp/>for<sp/>example,<sp/>length,<sp/>distance,<sp/>simplify,<sp/>envelope<sp/>and<sp/>stream<sp/>do.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;3D:<sp/>length:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__length_1ga38dff36b8deb6a1a8cb0a3d6387af8fc" kindref="member" tooltip="Calculates the length of a geometry.">length</ref>(line3)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>line:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dsv(line3)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>With<sp/>DSV<sp/>you<sp/>can<sp/>also<sp/>use<sp/>other<sp/>delimiters,<sp/>e.g.<sp/>JSON<sp/>style</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;JSON:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>dsv(ls,<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;[&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;]&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;[<sp/>&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;<sp/>]&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>    </detaileddescription>
  </compounddef>
</doxygen>
