<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="sets" kind="page">
    <compoundname>sets</compoundname>
    <title>Spatial set-theoretic operations (union, intersection, difference)</title>
    <detaileddescription>
<sect1 id="sets_1sets_par1">
<title>Introduction</title>
<para>The GGL implementation of the algorithms intersection, union, difference and symmetric difference is based on set theory (a.o. <ulink url="http://en.wikipedia.org/wiki/Set_(mathematics)">http://en.wikipedia.org/wiki/Set_(mathematics)</ulink>). This theory is applied for spatial sets.</para><para>Intersection and union are so-called set-theoretic operations. Those operations work on sets, and geometries (especially polygons and multi-polygons) can be seen as sets, sets of points.</para><para>The first section will repeat a small, relevant part of the algebra of sets, also describing the notation used in this page. The next section will extend this algebra of sets for spatial sets (polygons).</para></sect1>
<sect1 id="sets_1sets_par2">
<title>Algebra of sets in a spatial context</title>
<para><itemizedlist>
<listitem><para>A &amp;#8745; B : the intersection of two sets A and B is the set that contains all elements of A that also belong to B (aka AND)</para></listitem><listitem><para>A &amp;#8746; B : the union of two sets A and B is the set that contains all elements that belong to A or B (aka OR)</para></listitem><listitem><para>A<small><superscript>c</superscript></small> : the complement of set A is the set of elements which do not belong to A</para></listitem><listitem><para>A \ B : the difference of two sets A and B is the set of elements which belong to A but not to B</para></listitem><listitem><para>A &amp;#8710; B : the symmetric difference of two sets A and B is the set of elements which belong to either A or to B, but not to A and B (aka XOR)</para></listitem></itemizedlist>
</para><para>(Source of most definitions: <ulink url="http://en.wikipedia.org/wiki/Algebra_of_sets">http://en.wikipedia.org/wiki/Algebra_of_sets</ulink>)</para><para>There are several laws on sets and we will not discuss them all here. The most important for this page are:<itemizedlist>
<listitem><para>B \ A = A<small><superscript>c</superscript></small> &amp;#8745; B and, vice versa, A \ B = B<small><superscript>c</superscript></small> &amp;#8745; A</para></listitem><listitem><para>A &amp;#8710; B = (B \ A) &amp;#8746; (A \ B) (<ulink url="http://www.tutorvista.com/content/math/number-theory/sets/operations-sets.php">http://www.tutorvista.com/content/math/number-theory/sets/operations-sets.php</ulink>)</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="sets_1sets_par3">
<title>Polygons</title>
<para>Polygons are sets of points, and, therefore polygons follow all definitions and laws for sets. For pragmatic reasons and implementations in computer programs, polygons have an orientation, clockwise or counter clockwise. Orientation is not part of most set theory descriptions, but is an important aspect for the appliance of sets to polygon operations.</para><para>If a polygon is (arbitrarily) defined as having its vertices in clockwise direction:<itemizedlist>
<listitem><para>then its interior lies on the right side of the edges [<ulink url="http://gandraxa.com/draw_orthogonal_polygons.aspx">http://gandraxa.com/draw_orthogonal_polygons.aspx</ulink>]</para></listitem><listitem><para>and its exterior lies, therefore, on the left side of the edges</para></listitem></itemizedlist>
</para><para>This definition is important for the spatial interpretation sets.</para><para><itemizedlist>
<listitem><para>If set A describes the interior of a polygon, then A<small><superscript>c</superscript></small>, its complement, describes the exterior of a polygon.</para></listitem><listitem><para>Stated differently, set A is a polygon, all points belonging to A are inside the polygon. Its complement, A<small><superscript>c</superscript></small>, contains all points not belonging to A.</para></listitem><listitem><para>If A is a polygon with its vertices oriented clockwise, A<small><superscript>c</superscript></small> is a polygon with the same vertices, but in reverse order, so counter clockwise. Both sets have their points belonging to them at the right side of their edges</para></listitem></itemizedlist>
</para><para><image type="html" name="set_a_ac.png"></image>
</para><para>The last observation is helpful in calculating the difference and the symmetric difference:<itemizedlist>
<listitem><para>the difference B \ A is defined above by the law B \ A = A<small><superscript>c</superscript></small> &amp;#8745; B. In polygon terms it is therefore the intersection of the &quot;reverse of A&quot; with B. To calculate it, it is enough to have polygon A input in reverse order, and intersect this with polygon B</para></listitem><listitem><para>the symmetric difference A &amp;#8710; B is defined above by the law (B \ A) &amp;#8746; (A \ B), which leads to (A<small><superscript>c</superscript></small> &amp;#8745; B) &amp;#8746; (B<small><superscript>c</superscript></small> &amp;#8745; A). To calculate the symmetric difference, it is enough to have polygon A input in reverse order, intersect this with polygon B, store the result; then have polygon B input in reverse order, intersect this with polygon A, add this to the result and this is the symmetric difference. The combination of both sub-results does not have to be intersected as it is only touching on vertices and do not have overlaps.</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="sets_1sets_par4">
<title>Implementation of intersection and union</title>
<para>All spatial set-theoretic operations are implemented in shared code. There is hardly any difference in code between the calculation of an intersection or a union. The only difference is that at each intersection point, for an intersection the right turn should be taken. For union the left turn should be taken.</para><para><image type="html" name="set_int_right_union_left.png"></image>
</para><para>This is implemented as such in GGL. The turn to be taken is a variable.</para><para>There is an alternative to calculate union as well:<itemizedlist>
<listitem><para>the union A &amp;#8746; B equals to the complement of the intersection of the complements of the inputs, (A<small><superscript>c</superscript></small> &amp;#8745; B<small><superscript>c</superscript></small>)<small><superscript>c</superscript></small> (De Morgan law, <ulink url="http://en.wikipedia.org/wiki/Algebra_of_sets#Some_additional_laws_for_complements">http://en.wikipedia.org/wiki/Algebra_of_sets#Some_additional_laws_for_complements</ulink>)</para></listitem></itemizedlist>
</para><para>There is an additional difference in the handling of disjoint holes (holes which are not intersected). This is also implemented in the same generic way (the implementation will still be tweaked a little to have it even more generic).</para><para>For a counter clockwise polygon, the behaviour is the reverse: for intersection take the left path, for union take the right path. This is a trivial thing to implement, but it still has to be done (as the orientation was introduced in a later phase in GGL).</para></sect1>
<sect1 id="sets_1sets_par5">
<title>Iterating forward or reverse</title>
<para>As explained above, for a difference, the vertices of the first polygon should be iterated by a forward iterator, but the vertices of the second polygon should be iterated by a reverse iterator (or vice versa). This (trivial) implementation still has to be done. It will <bold>not</bold> be implemented by creating a copy, reversing it, and presenting it as input to the set operation (as outlined above). That is easy and will work but has a performance penalty. Instead a reversible iterator will used, extended from Boost.Range iterators, and decorating a Boost.Range iterator at the same time, which can travel forward or backward.</para><para>It is currently named <bold>reversible_view</bold> and usage looks like:</para><para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Direction,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Range&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>walk(Range<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>&amp;<sp/>range)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>reversible_view&lt;Range,<sp/>Direction&gt;<sp/>view_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>view_type<sp/>view(range);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>boost::range_const_iterator&lt;view_type&gt;::type<sp/>it;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(it<sp/>=<sp/>boost::begin(view);<sp/>it<sp/>!=<sp/>boost::end(view);<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>do<sp/>something</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">walk&lt;1&gt;(range);<sp/></highlight><highlight class="comment">//<sp/>forward</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">walk&lt;-1&gt;(range);<sp/></highlight><highlight class="comment">//<sp/>backward</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="sets_1sets_par6">
<title>Characteristics of the intersection algorithm</title>
<para>The algorithm is a modern variant of the graph traversal algorithm, after Weiler-Atherton (<ulink url="http://en.wikipedia.org/wiki/Weiler-Atherton_clipping_algorithm">http://en.wikipedia.org/wiki/Weiler-Atherton_clipping_algorithm</ulink>).</para><para>It has the following characteristics (part of these points are deviations from Weiler-Atherton)<itemizedlist>
<listitem><para>No copy is necessary (the original Weiler-Atherton, and its descendants, insert intersections in (linked) lists, which require to make first copies of both input geometries).</para></listitem><listitem><para>All turning points (which are intersection points with side/turn information) are unaware of the context, so we have (and need) no information about if, before the intersection point, a segment was inside or outside of the other geometry</para></listitem><listitem><para>It can do intersections, unions, symmetric differences, differences</para></listitem><listitem><para>It can handle polygons with holes, non-convex polygons, polygons-with-polygons, polygons-with-boxes (clip), rings, multi-polygons</para></listitem><listitem><para>It can handle one polygon at the time (resolve self-intersections), two polygons (the normal use case), or more polygons (applicable for intersections and unions)</para></listitem><listitem><para>It can handle clockwise and counter-clockwise geometries</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="sets_1sets_par7">
<title>Outline of the intersection algorithm</title>
<para>The actual implementation consists of the next phases.</para><para><bold>1</bold> the input geometries are indexed (if necessary). Currently we use monotonic sections for the index. It is done by the algorithm <bold>sectionalize</bold>. Sections are created is done on the fly, so no preparation is required before (though this would improve performance - it is possible that there will be an alternative variant where prepared sections or other indexes are part of the input). For box-polygon this phase is not necessary and skipped. Sectionalizing is done in linear time.</para><para><bold>2</bold>, intersection points are calculated. Segments of polygon A are compared with segments of polygon B. Segment intersection is only done for segments in overlapping sections. Intersection points are not inserted into the original polygon or in a copy. A linked list is therefore not necessary. This phase is called <bold>get_intersection_points</bold>. This function can currently be used for one or two input geometries, for self-intersection or for intersection. Because found intersections are provided with intersection-information, including a reference to their source, it is possible (but currently not implemented) to have more than two geometry inputs.</para><para>The complexity of getting the intersections is (much) less than quadratic (n*m) because of the monotonic sections. The exact complexity depends on the number of sections, of how the input polygons look like. In a worst case scenario, there are only two monotonic sections per polygon and both overlap. The complexity is then quadratic. However, the sectionalize algorithm has a maximum number of segments per section, so for large polygons there are always more monotonic sections and in those cases they do not overlap by the definition of &quot;monotonic&quot;. For boxes, the complexity is linear time.</para><para>To give another idea of how sections and indexes work: For a test processing 3918 polygons (but not processing those of which envelopes do not overlap):<itemizedlist>
<listitem><para>brute force (O(n<small><superscript>2</superscript></small>)): 11856331 combinations</para></listitem><listitem><para>monotonic sections: 213732 combinations (55 times less)</para></listitem><listitem><para>a spatial index: 34877 combinations (1/6 of using monotonic sections) So there can still be gained some performance by another index. However the current spatial index implementation (in an extension, not in Formal Review) will still be revisited, so it is currently not used.</para></listitem></itemizedlist>
</para><para><emphasis>In &quot;normal&quot; cases 84% of the time is spent on finding intersection points. These divisions in &apos;s refers to the performance test described elsewhere</emphasis></para><para>One piece of information per intersection points is if it is <bold>trivial</bold>. It is trivial if the intersection is not located at segment end points.</para><para><bold>3</bold>, the found intersection points are merged (<bold>merge_intersection_points</bold>), and some intersections can be deleted (e.g. in case of collinearities). This merge process consists of sorting the intersection points in X (major) and Y (minor) direction, and merging intersections with a common location together. Intersections with common locations do occur as soon as segments are collinear or meet at their end points. This phase is skipped if all intersection points are trivial.</para><para><emphasis>About 6% is spent on merging.</emphasis></para><para><bold>4</bold>, some turns need to be adapted. If segments intersect in their interiors, this is never necessary. However, if segments intersect on their end points, it is sometimes necessary to change &quot;side&quot; information to &quot;turn&quot; information. This phase is called <bold>adapt_turns</bold>.</para><para>The image below gives one example when adapting turns is necessary. There is side information, both segments have sides <bold>left</bold> and <bold>right</bold>, there is also <bold>collinear</bold>. However, for an intersection no turn should be taken at all, so no right turn. For a union, both polygons have to be travelled. In this case the side information is adapted to turn information, both turns will be <bold>left</bold>. This phase is skipped if all intersection points are trivial.</para><para><image type="html" name="set_adapt_turns.png"></image>
</para><para><bold>5</bold>, the merged intersection points are enriched (<bold>enrich_intersection_points</bold>) with information about a.o. the next intersection point (travel information).</para><para><emphasis>About 3% is spent on enrichment.</emphasis></para><para><bold>6</bold>, polygons are traversed (<bold>traverse</bold>) using the intersection points, enriched with travel information. The input polygons are traversed and at all intersection poitns a direction is taken, left for union, right for intersection point (for counter clockwise polygons this is the other way round). In some cases separate rings are produced. In some cases new holes are formed.</para><para><emphasis>About 6% is spent on traversal.</emphasis></para><para><bold>7</bold>, the created rings are assembled (<bold>assemble</bold>) into polygon(s) with exterior rings and interior rings. Even if there are no intersection points found, this process can be important to find containment and coverage.</para><para><emphasis>Timing of this phase is not yet available, as the comparison program work on rings.</emphasis> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
