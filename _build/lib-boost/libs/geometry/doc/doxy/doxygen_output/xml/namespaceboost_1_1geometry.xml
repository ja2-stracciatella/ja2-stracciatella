<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="namespaceboost_1_1geometry" kind="namespace">
    <compoundname>boost::geometry</compoundname>
    <innerclass refid="structboost_1_1geometry_1_1add__const__if__c" prot="public">boost::geometry::add_const_if_c</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1areal__tag" prot="public">boost::geometry::areal_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1box__tag" prot="public">boost::geometry::box_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1box__view" prot="public">boost::geometry::box_view</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1cartesian__tag" prot="public">boost::geometry::cartesian_tag</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1centroid__exception" prot="public">boost::geometry::centroid_exception</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1closeable__view" prot="public">boost::geometry::closeable_view</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1closing__iterator" prot="public">boost::geometry::closing_iterator</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1closure" prot="public">boost::geometry::closure</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1closure__as__bool" prot="public">boost::geometry::closure_as_bool</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1closure__as__bool_3_01closed_01_4" prot="public">boost::geometry::closure_as_bool&lt; closed &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1closure__as__bool_3_01open_01_4" prot="public">boost::geometry::closure_as_bool&lt; open &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1collected__vector" prot="public">boost::geometry::collected_vector</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1comparable__distance__result" prot="public">boost::geometry::comparable_distance_result</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1comparable__distance__result_3_01_geometry1_00_01_geometry2_00_01void_01_4" prot="public">boost::geometry::comparable_distance_result&lt; Geometry1, Geometry2, void &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1compress__variant" prot="public">boost::geometry::compress_variant</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1concatenate__iterator" prot="public">boost::geometry::concatenate_iterator</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1coordinate__system" prot="public">boost::geometry::coordinate_system</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1coordinate__type" prot="public">boost::geometry::coordinate_type</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1cs__tag" prot="public">boost::geometry::cs_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1default__area__result" prot="public">boost::geometry::default_area_result</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1default__comparable__distance__result" prot="public">boost::geometry::default_comparable_distance_result</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1default__distance__result" prot="public">boost::geometry::default_distance_result</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1default__length__result" prot="public">boost::geometry::default_length_result</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1default__strategy" prot="public">boost::geometry::default_strategy</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1degree" prot="public">boost::geometry::degree</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1dimension" prot="public">boost::geometry::dimension</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1distance__result" prot="public">boost::geometry::distance_result</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1distance__result_3_01_geometry1_00_01_geometry2_00_01void_01_4" prot="public">boost::geometry::distance_result&lt; Geometry1, Geometry2, void &gt;</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1empty__input__exception" prot="public">boost::geometry::empty_input_exception</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1equal__to" prot="public">boost::geometry::equal_to</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1ever__circling__iterator" prot="public">boost::geometry::ever_circling_iterator</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1ever__circling__range__iterator" prot="public">boost::geometry::ever_circling_range_iterator</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1exception" prot="public">boost::geometry::exception</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1flatten__iterator" prot="public">boost::geometry::flatten_iterator</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1fp__coordinate__type" prot="public">boost::geometry::fp_coordinate_type</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1fraction__type" prot="public">boost::geometry::fraction_type</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1geographic__tag" prot="public">boost::geometry::geographic_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1geometry__collection__tag" prot="public">boost::geometry::geometry_collection_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1geometry__id" prot="public">boost::geometry::geometry_id</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1geometry__not__recognized__tag" prot="public">boost::geometry::geometry_not_recognized_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1greater" prot="public">boost::geometry::greater</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1helper__geometry" prot="public">boost::geometry::helper_geometry</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1identity__view" prot="public">boost::geometry::identity_view</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1inconsistent__turns__exception" prot="public">boost::geometry::inconsistent_turns_exception</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1interior__return__type" prot="public">boost::geometry::interior_return_type</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1interior__type" prot="public">boost::geometry::interior_type</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1invalid__input__exception" prot="public">boost::geometry::invalid_input_exception</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1is__areal" prot="public">boost::geometry::is_areal</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1is__radian" prot="public">boost::geometry::is_radian</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1less" prot="public">boost::geometry::less</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1linear__tag" prot="public">boost::geometry::linear_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1linestring__tag" prot="public">boost::geometry::linestring_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1multi__linestring__tag" prot="public">boost::geometry::multi_linestring_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1multi__point__tag" prot="public">boost::geometry::multi_point_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1multi__polygon__tag" prot="public">boost::geometry::multi_polygon_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1multi__tag" prot="public">boost::geometry::multi_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1not__implemented" prot="public">boost::geometry::not_implemented</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1order__as__direction" prot="public">boost::geometry::order_as_direction</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1order__as__direction_3_01clockwise_01_4" prot="public">boost::geometry::order_as_direction&lt; clockwise &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1order__as__direction_3_01counterclockwise_01_4" prot="public">boost::geometry::order_as_direction&lt; counterclockwise &gt;</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1overlay__invalid__input__exception" prot="public">boost::geometry::overlay_invalid_input_exception</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1parameter__type__of" prot="public">boost::geometry::parameter_type_of</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1partition" prot="public">boost::geometry::partition</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1point__iterator" prot="public">boost::geometry::point_iterator</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1point__order" prot="public">boost::geometry::point_order</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1point__reverse__iterator" prot="public">boost::geometry::point_reverse_iterator</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1point__tag" prot="public">boost::geometry::point_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1point__type" prot="public">boost::geometry::point_type</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1point__type_3_01boost_1_1variant_3_01_b_o_o_s_t___v_a_r_i_a_n_t___e_ne779fef8428519fc7733ab4259a48372" prot="public">boost::geometry::point_type&lt; boost::variant&lt; BOOST_VARIANT_ENUM_PARAMS(T)&gt; &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1pointlike__tag" prot="public">boost::geometry::pointlike_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1polygon__tag" prot="public">boost::geometry::polygon_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1polygonal__tag" prot="public">boost::geometry::polygonal_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1promote__floating__point" prot="public">boost::geometry::promote_floating_point</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1promote__integral" prot="public">boost::geometry::promote_integral</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1promote__integral_3_01_t_00_01_promote_unsigned_to_unsigned_00_01_use_checked_integer_00_01false_01_4" prot="public">boost::geometry::promote_integral&lt; T, PromoteUnsignedToUnsigned, UseCheckedInteger, false &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1radian" prot="public">boost::geometry::radian</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1radius__type" prot="public">boost::geometry::radius_type</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1read__wkt__exception" prot="public">boost::geometry::read_wkt_exception</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1reverse__dispatch" prot="public">boost::geometry::reverse_dispatch</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1reversible__view" prot="public">boost::geometry::reversible_view</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1ring__identifier" prot="public">boost::geometry::ring_identifier</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1ring__return__type" prot="public">boost::geometry::ring_return_type</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1ring__tag" prot="public">boost::geometry::ring_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1ring__type" prot="public">boost::geometry::ring_type</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1section" prot="public">boost::geometry::section</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1sections" prot="public">boost::geometry::sections</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1segment__identifier" prot="public">boost::geometry::segment_identifier</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1segment__intersection__info" prot="public">boost::geometry::segment_intersection_info</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1segment__intersection__points" prot="public">boost::geometry::segment_intersection_points</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1segment__iterator" prot="public">boost::geometry::segment_iterator</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1segment__tag" prot="public">boost::geometry::segment_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1segment__view" prot="public">boost::geometry::segment_view</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1select__calculation__type" prot="public">boost::geometry::select_calculation_type</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1select__calculation__type__alt" prot="public">boost::geometry::select_calculation_type_alt</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1select__coordinate__type" prot="public">boost::geometry::select_coordinate_type</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1select__coordinate__type_3_01_t1_00_01_t2_00_01void_01_4" prot="public">boost::geometry::select_coordinate_type&lt; T1, T2, void &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1select__coordinate__type_3_01_t1_00_01void_00_01void_01_4" prot="public">boost::geometry::select_coordinate_type&lt; T1, void, void &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1select__most__precise" prot="public">boost::geometry::select_most_precise</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1select__most__precise_3_01boost_1_1rational_3_01_t_01_4_00_01double_01_4" prot="public">boost::geometry::select_most_precise&lt; boost::rational&lt; T &gt;, double &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1select__most__precise_3_01boost_1_1rational_3_01_t1_01_4_00_01boost_1_1rational_3_01_t2_01_4_01_4" prot="public">boost::geometry::select_most_precise&lt; boost::rational&lt; T1 &gt;, boost::rational&lt; T2 &gt; &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1select__most__precise_3_01_t1_00_01_t2_00_01void_01_4" prot="public">boost::geometry::select_most_precise&lt; T1, T2, void &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1select__most__precise_3_01_t1_00_01void_00_01void_01_4" prot="public">boost::geometry::select_most_precise&lt; T1, void, void &gt;</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1side__info" prot="public">boost::geometry::side_info</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1single__tag" prot="public">boost::geometry::single_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1single__tag__of" prot="public">boost::geometry::single_tag_of</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1single__tag__of_3_01detail_1_1buffer_1_1buffered__ring__collection__tag_01_4" prot="public">boost::geometry::single_tag_of&lt; detail::buffer::buffered_ring_collection_tag &gt;</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1spherical__equatorial__tag" prot="public">boost::geometry::spherical_equatorial_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1spherical__polar__tag" prot="public">boost::geometry::spherical_polar_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1spherical__tag" prot="public">boost::geometry::spherical_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1srs__sphere__tag" prot="public">boost::geometry::srs_sphere_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1srs__spheroid__tag" prot="public">boost::geometry::srs_spheroid_tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1strategy__compare" prot="public">boost::geometry::strategy_compare</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1strategy__convex__hull" prot="public">boost::geometry::strategy_convex_hull</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1strategy__intersection" prot="public">boost::geometry::strategy_intersection</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1strategy__intersection__empty" prot="public">boost::geometry::strategy_intersection_empty</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1strategy__tag__distance__box__box" prot="public">boost::geometry::strategy_tag_distance_box_box</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1strategy__tag__distance__point__box" prot="public">boost::geometry::strategy_tag_distance_point_box</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1strategy__tag__distance__point__point" prot="public">boost::geometry::strategy_tag_distance_point_point</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1strategy__tag__distance__point__segment" prot="public">boost::geometry::strategy_tag_distance_point_segment</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1svg__manipulator" prot="public">boost::geometry::svg_manipulator</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1svg__mapper" prot="public">boost::geometry::svg_mapper</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1tag" prot="public">boost::geometry::tag</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1tag__cast" prot="public">boost::geometry::tag_cast</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1topological__dimension" prot="public">boost::geometry::topological_dimension</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1transform__variant" prot="public">boost::geometry::transform_variant</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1transform__variant_3_01variant_3_01_b_o_o_s_t___v_a_r_i_a_n_t___e_n_uf4ac33b8d803230c1237c41fa1e5e7a2" prot="public">boost::geometry::transform_variant&lt; variant&lt; BOOST_VARIANT_ENUM_PARAMS(T)&gt;, Op, boost::mpl::na &gt;</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1turn__info__exception" prot="public">boost::geometry::turn_info_exception</innerclass>
    <innerclass refid="structboost_1_1geometry_1_1volumetric__tag" prot="public">boost::geometry::volumetric_tag</innerclass>
    <innerclass refid="classboost_1_1geometry_1_1wkt__manipulator" prot="public">boost::geometry::wkt_manipulator</innerclass>
    <innernamespace refid="namespaceboost_1_1geometry_1_1traits">boost::geometry::traits</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1cs">boost::geometry::cs</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1srs">boost::geometry::srs</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1resolve__variant">boost::geometry::resolve_variant</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1resolve__strategy">boost::geometry::resolve_strategy</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1info">boost::geometry::info</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1nyi">boost::geometry::nyi</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1detail">boost::geometry::detail</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1core__dispatch">boost::geometry::core_dispatch</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1dispatch">boost::geometry::dispatch</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1strategy">boost::geometry::strategy</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1de9im">boost::geometry::de9im</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1concept">boost::geometry::concept</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1model">boost::geometry::model</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1detail__dispatch">boost::geometry::detail_dispatch</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1fusion__adapt__detail">boost::geometry::fusion_adapt_detail</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1policies">boost::geometry::policies</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1util">boost::geometry::util</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1math">boost::geometry::math</innernamespace>
    <innernamespace refid="namespaceboost_1_1geometry_1_1range">boost::geometry::range</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__enum_1ga7d33eca9a5389952bdf719972eb802b6" prot="public" static="no">
        <name>closure_selector</name>
        <enumvalue id="group__enum_1gga7d33eca9a5389952bdf719972eb802b6a684591bd018092efa79ef4b7731b7b05" prot="public">
          <name>open</name>
          <initializer> 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Rings are open: first point and last point are different, algorithms close them explicitly on the fly </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga7d33eca9a5389952bdf719972eb802b6a17768d8af3fcc199a847d70965cbf9c5" prot="public">
          <name>closed</name>
          <initializer> 1</initializer>
          <briefdescription>
<para>Rings are closed: first point and last point must be the same. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga7d33eca9a5389952bdf719972eb802b6a6dc65ac8f2b1a2fe71d912b634955510" prot="public">
          <name>closure_undertermined</name>
          <initializer> -1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>(Not yet implemented): algorithms first figure out if ring must be closed on the fly </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumerates options for defining if polygons are open or closed. </para>        </briefdescription>
        <detaileddescription>
<para>The enumeration closure_selector describes options for if a polygon is open or closed. In a closed polygon the very first point (per ring) should be equal to the very last point. The specific closing property of a polygon type is defined by the closure metafunction. The closure metafunction defines a value, which is one of the values enumerated in the closure_selector</para><para> <qbk>
[heading See also]
[link geometry.reference.core.closure The closure metafunction]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/closure.hpp" line="51" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/closure.hpp" bodystart="50" bodyend="60"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceboost_1_1geometry_1a6424afc319f6cc4d4276a3900e966d3f" prot="public" static="no">
        <name>iterate_direction</name>
        <enumvalue id="namespaceboost_1_1geometry_1a6424afc319f6cc4d4276a3900e966d3fa8d759d0a3695aa617e26a1b3e101de29" prot="public">
          <name>iterate_forward</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceboost_1_1geometry_1a6424afc319f6cc4d4276a3900e966d3fa37daa24e30befa9d690d75fb5439718a" prot="public">
          <name>iterate_reverse</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flag for iterating a <ref refid="structboost_1_1geometry_1_1reversible__view" kindref="compound">reversible_view</ref> in forward or reverse direction. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/views/reversible_view.hpp" line="35" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/views/reversible_view.hpp" bodystart="35" bodyend="35"/>
      </memberdef>
      <memberdef kind="enum" id="group__enum_1ga0af1c124acb76f0892024d6d4ab2bc8c" prot="public" static="no">
        <name>order_selector</name>
        <enumvalue id="group__enum_1gga0af1c124acb76f0892024d6d4ab2bc8ca29458b1c5c6f01e41bc529cff7cdbec2" prot="public">
          <name>clockwise</name>
          <initializer> 1</initializer>
          <briefdescription>
<para>Points are ordered clockwise. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga0af1c124acb76f0892024d6d4ab2bc8ca3a0efd1027a55cf48cfc5f9b57391468" prot="public">
          <name>counterclockwise</name>
          <initializer> 2</initializer>
          <briefdescription>
<para>Points are ordered counter clockwise. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga0af1c124acb76f0892024d6d4ab2bc8ca0525b242b4e6519d79366300eca9f8da" prot="public">
          <name>order_undetermined</name>
          <initializer> 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Points might be stored in any order, algorithms will determine it on the fly (not yet supported) </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumerates options for the order of points within polygons. </para>        </briefdescription>
        <detaileddescription>
<para>The enumeration order_selector describes options for the order of points within a polygon. Polygons can be ordered either clockwise or counterclockwise. The specific order of a polygon type is defined by the <ref refid="structboost_1_1geometry_1_1point__order" kindref="compound">point_order</ref> metafunction. The <ref refid="structboost_1_1geometry_1_1point__order" kindref="compound">point_order</ref> metafunction defines a value, which is one of the values enumerated in the order_selector</para><para> <qbk>
[heading See also]
[link geometry.reference.core.point_order The point_order metafunction]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/point_order.hpp" line="49" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/point_order.hpp" bodystart="48" bodyend="57"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceboost_1_1geometry_1a6b49ba0dbb14c37e57127f78a74e4921" prot="public" static="no">
        <name>overlay_type</name>
        <enumvalue id="namespaceboost_1_1geometry_1a6b49ba0dbb14c37e57127f78a74e4921a3742a61a84923702bd74f7a9461e2811" prot="public">
          <name>overlay_union</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceboost_1_1geometry_1a6b49ba0dbb14c37e57127f78a74e4921a12c38cf5208fc177a356826347ce494b" prot="public">
          <name>overlay_intersection</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceboost_1_1geometry_1a6b49ba0dbb14c37e57127f78a74e4921a08b4b940b7639685de488dd45589f020" prot="public">
          <name>overlay_difference</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceboost_1_1geometry_1a6b49ba0dbb14c37e57127f78a74e4921aef2f937a8d3cc99675b292b3508334ec" prot="public">
          <name>overlay_dissolve</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/overlay_type.hpp" line="18" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/overlay_type.hpp" bodystart="17" bodyend="23"/>
      </memberdef>
      <memberdef kind="enum" id="group__enum_1ga8f93f0b6945c2ebb9f8a4bb53019a0d8" prot="public" static="no">
        <name>validity_failure_type</name>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8ad799abcd8ac589c3e2500b7bbd1e6334" prot="public">
          <name>no_failure</name>
          <initializer> 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The geometry is valid </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8a9b7cd8df6dac3078c1dee47e7cbd0709" prot="public">
          <name>failure_few_points</name>
          <initializer> 10</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The geometry has a very small number of points, e.g., less than 2 for linestrings, less than 3 for open rings, a closed multi-polygon that contains a polygon with less than 4 points, etc. (applies to linestrings, rings, polygons, multi-linestrings and multi-polygons) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8a73b19bdd2d80e479bfd6eeee2222da56" prot="public">
          <name>failure_wrong_topological_dimension</name>
          <initializer> 11</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The topological dimension of the geometry is smaller than its dimension, e.g., a linestring with 3 identical points, an open polygon with an interior ring consisting of 3 collinear points, etc. (applies to linear and areal geometries, including segments and boxes) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8a316c3e4c46e746c679525750e1050224" prot="public">
          <name>failure_spikes</name>
          <initializer> 12</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The geometry contains spikes (applies to linear and areal geometries) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8a8af5f9ddd5eb89d21a7b27c7a182fceb" prot="public">
          <name>failure_duplicate_points</name>
          <initializer> 13</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The geometry has (consecutive) duplicate points (applies to areal geometries only) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8ae58e4a68b24407dfba4145cd31dac494" prot="public">
          <name>failure_not_closed</name>
          <initializer> 20</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The geometry is defined as closed, the starting/ending points are not equal (applies to areal geometries only) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8a15a1c5e9922f20f1b1e9bd12ab26e4bc" prot="public">
          <name>failure_self_intersections</name>
          <initializer> 21</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The geometry has invalid self-intersections. (applies to areal geometries only) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8a4869614bcd34cce68f9e657c59ed3351" prot="public">
          <name>failure_wrong_orientation</name>
          <initializer> 22</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The actual orientation of the geometry is different from the one defined (applies to areal geometries only) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8ac69af9fa40a267af8911647df8f20946" prot="public">
          <name>failure_interior_rings_outside</name>
          <initializer> 30</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The geometry contains interior rings that lie outside the exterior ring (applies to polygons and multi-polygons only) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8aaff1555fb9bc178d97c16f856b4bd282" prot="public">
          <name>failure_nested_interior_rings</name>
          <initializer> 31</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The geometry has nested interior rings (applies to polygons and multi-polygons only) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8a6b9cbda3e4d8f0ada38b1927f1fdc96c" prot="public">
          <name>failure_disconnected_interior</name>
          <initializer> 32</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The interior of the geometry is disconnected (applies to polygons and multi-polygons only) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8ace858388cbb736c3b6e83ffd8bbcd3b4" prot="public">
          <name>failure_intersecting_interiors</name>
          <initializer> 40</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The multi-polygon contains polygons whose interiors are not disjoint (applies to multi-polygons only) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8ac785a27ddd7417b1d3e525a435a6b1e5" prot="public">
          <name>failure_wrong_corner_order</name>
          <initializer> 50</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The top-right corner of the box is lexicographically smaller than its bottom-left corner (applies to boxes only) </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__enum_1gga8f93f0b6945c2ebb9f8a4bb53019a0d8ab214fa3c0df702224cea9854f3b74f63" prot="public">
          <name>failure_invalid_coordinate</name>
          <initializer> 60</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The geometry has at least one point with an invalid coordinate (for example, the coordinate is a NaN) </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumerates the possible validity failure types for a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The enumeration validity_failure_type enumerates the possible reasons for which a geometry may be found as invalid by the is_valid algorithm. Besides the values that indicate invalidity, there is an additional value (no_failure) that indicates validity.</para><para> <qbk>
[heading See also]
[link geometry.reference.algorithms.is_valid The is_valid
algorithm taking a reference to validity_failure_type as second argument]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/validity_failure_type.hpp" line="34" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/validity_failure_type.hpp" bodystart="33" bodyend="85"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespaceboost_1_1geometry_1af0c576f82145cf6a02dcbf48b675a0c2" prot="public" static="no">
        <type>boost::make_signed&lt; std::size_t &gt;::type</type>
        <definition>typedef boost::make_signed&lt;std::size_t&gt;::type boost::geometry::signed_size_type</definition>
        <argsstring></argsstring>
        <name>signed_size_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/signed_size_type.hpp" line="23" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/signed_size_type.hpp" bodystart="23" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespaceboost_1_1geometry_1a4a86ce72ed7ddcfc21f8e79445bf683d" prot="public" static="no" mutable="no">
        <type>int const</type>
        <definition>int const boost::geometry::max_corner</definition>
        <argsstring></argsstring>
        <name>max_corner</name>
        <initializer> 1</initializer>
        <briefdescription>
<para>Index of maximum corner of the box. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" line="38" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceboost_1_1geometry_1a60f531e30e193d8ce30098428d9134c1" prot="public" static="no" mutable="no">
        <type>int const</type>
        <definition>int const boost::geometry::min_corner</definition>
        <argsstring></argsstring>
        <name>min_corner</name>
        <initializer> 0</initializer>
        <briefdescription>
<para>Index of minimum corner of the box. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" line="35" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" bodystart="35" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__arithmetic_1ga4be53645868644bb6c5a455450d4d00e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point1</type>
          </param>
          <param>
            <type>typename Point2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::add_point</definition>
        <argsstring>(Point1 &amp;p1, Point2 const &amp;p2)</argsstring>
        <name>add_point</name>
        <param>
          <type>Point1 &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>Point2 const &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
<para>Adds a point to another. </para>        </briefdescription>
        <detaileddescription>
<para>The coordinates of the second point will be added to those of the first point. The second point is not modified. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Point2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p1</parametername>
</parameternamelist>
<parameterdescription>
<para>first point </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p2</parametername>
</parameternamelist>
<parameterdescription>
<para>second point </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" line="164" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" bodystart="163" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="group__arithmetic_1ga9c6f97e8be0aea5a989b10282cfdfcd1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::add_value</definition>
        <argsstring>(Point &amp;p, typename detail::param&lt; Point &gt;::type value)</argsstring>
        <name>add_value</name>
        <param>
          <type>Point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>typename detail::param&lt; Point &gt;::type</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Adds the same value to each coordinate of a point. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>point </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>value to add </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" line="141" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" bodystart="140" bodyend="150"/>
      </memberdef>
      <memberdef kind="function" id="group__append_1gaa3a95c7738229a30f77562cb095b3699" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename RangeOrPoint</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::append</definition>
        <argsstring>(Geometry &amp;geometry, RangeOrPoint const &amp;range_or_point, int ring_index=-1, int multi_index=0)</argsstring>
        <name>append</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>RangeOrPoint const &amp;</type>
          <declname>range_or_point</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ring_index</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>int</type>
          <declname>multi_index</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Appends one or more points to a linestring, ring, polygon, multi-geometry. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RangeOrPoint</parametername>
</parameternamelist>
<parameterdescription>
<para>Either a range or a point, fullfilling Boost.Range concept or Boost.Geometry Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>range_or_point</parametername>
</parameternamelist>
<parameterdescription>
<para>The point or range to add </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ring_index</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the ring in case of a polygon: exterior ring (-1, the default) or interior ring index </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>multi_index</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the geometry to which the points are appended</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/append.qbk]</qbk>  } </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/append.hpp" line="361" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/append.hpp" bodystart="359" bodyend="364"/>
      </memberdef>
      <memberdef kind="function" id="group__area_1gaf7a1c34467f74f290d0b090adb27db62" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1default__area__result" kindref="compound">default_area_result</ref>&lt; Geometry &gt;::type</type>
        <definition>default_area_result&lt;Geometry&gt;::type boost::geometry::area</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>area</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the area of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function area calculates the area of a geometry. It uses the default strategy, based on the coordinate system of the geometry.</para><para>The area algorithm calculates the surface area of all geometries having a surface, namely box, polygon, ring, multipolygon. The units are the square of the units used for the points defining the surface. If subject geometry is defined in meters, then area is calculated in square meters.</para><para>The area calculation can be done in all three common coordinate systems, Cartesian, Spherical and Geographic as well.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk>[include reference/algorithms/area.qbk]</qbk>   <qbk>[heading Examples]</qbk>   <qbk>[area] [area_output]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/area.hpp" line="268" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/area.hpp" bodystart="267" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="group__area_1ga59861901cb4e4b95a9e9bf82f3b4fa35" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type>Strategy::return_type</type>
        <definition>Strategy::return_type boost::geometry::area</definition>
        <argsstring>(Geometry const &amp;geometry, Strategy const &amp;strategy)</argsstring>
        <name>area</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Calculates the area of a geometry using the specified strategy. </para>        </briefdescription>
        <detaileddescription>
<para>The free function area calculates the area of a geometry using the specified strategy. Reasons to specify a strategy include: use another coordinate system for calculations; construct the strategy beforehand (e.g. with the radius of the Earth); select a strategy when there are more than one available for a calculation. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Area Strategy Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The strategy which will be used for area calculations </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk.distinguish>with strategy</qbk.distinguish> </para><para> <qbk>
[include reference/algorithms/area.qbk]

[heading Example]
[area_with_strategy]
[area_with_strategy_output]

[heading Available Strategies]
\* [link geometry.reference.strategies.strategy_area_surveyor Surveyor (cartesian)]
\* [link geometry.reference.strategies.strategy_area_huiller Huiller (spherical)]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/area.hpp" line="312" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/area.hpp" bodystart="310" bodyend="318"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a1847c5af13e0d19c3911421d3dab6c8d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>int</type>
            <declname>Dimensions</declname>
            <defname>Dimensions</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assert_dimension</definition>
        <argsstring>()</argsstring>
        <name>assert_dimension</name>
        <briefdescription>
<para>assert_dimension, enables compile-time checking if coordinate dimensions are as expected </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/coordinate_dimension.hpp" line="95" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/coordinate_dimension.hpp" bodystart="94" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a13b8191ba1135e983690791efab43927" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename G1</type>
          </param>
          <param>
            <type>typename G2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assert_dimension_equal</definition>
        <argsstring>()</argsstring>
        <name>assert_dimension_equal</name>
        <briefdescription>
<para>assert_dimension_equal, enables compile-time checking if coordinate dimensions of two geometries are equal </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/coordinate_dimension.hpp" line="121" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/coordinate_dimension.hpp" bodystart="120" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a8de3fe127dab25ac9c46d611f78afafa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>int</type>
            <declname>Dimensions</declname>
            <defname>Dimensions</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assert_dimension_greater_equal</definition>
        <argsstring>()</argsstring>
        <name>assert_dimension_greater_equal</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/coordinate_dimension.hpp" line="111" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/coordinate_dimension.hpp" bodystart="110" bodyend="113"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ad4a36c4d293b80a01c84e37543b59456" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>int</type>
            <declname>Dimensions</declname>
            <defname>Dimensions</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assert_dimension_less_equal</definition>
        <argsstring>()</argsstring>
        <name>assert_dimension_less_equal</name>
        <briefdescription>
<para>assert_dimension, enables compile-time checking if coordinate dimensions are as expected </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/coordinate_dimension.hpp" line="105" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/coordinate_dimension.hpp" bodystart="104" bodyend="107"/>
      </memberdef>
      <memberdef kind="function" id="group__assign_1ga384744a79ea0798e6def3a5dfa577af3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assign</definition>
        <argsstring>(Geometry1 &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>assign</name>
        <param>
          <type>Geometry1 &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Assigns one geometry to another geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The assign algorithm assigns one geometry, e.g. a BOX, to another geometry, e.g. a RING. This only works if it is possible and applicable.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept (target) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept (source)</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>
[heading Example]
[assign] [assign_output]

[heading See also]
\* [link geometry.reference.algorithms.convert convert]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" line="370" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" bodystart="369" bodyend="372"/>
      </memberdef>
      <memberdef kind="function" id="group__assign_1gac2a4b4117524f23c5a04309182172375" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assign_inverse</definition>
        <argsstring>(Geometry &amp;geometry)</argsstring>
        <name>assign_inverse</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>assign to a box inverse infinite </para>        </briefdescription>
        <detaileddescription>
<para>The assign_inverse function initialize a 2D or 3D box with large coordinates, the min corner is very large, the max corner is very small. This is a convenient starting point to collect the minimum bounding box of a geometry.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>
[heading Example]
[assign_inverse] [assign_inverse_output]

[heading See also]
\* [link geometry.reference.algorithms.make.make_inverse make_inverse]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" line="98" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" bodystart="97" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="group__arithmetic_1gaa595e4f32e834533b6299e08449afc6c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point1</type>
          </param>
          <param>
            <type>typename Point2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assign_point</definition>
        <argsstring>(Point1 &amp;p1, Point2 const &amp;p2)</argsstring>
        <name>assign_point</name>
        <param>
          <type>Point1 &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>Point2 const &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
<para>Assign a point with another. </para>        </briefdescription>
        <detaileddescription>
<para>The coordinates of the first point will be assigned those of the second point. The second point is not modified. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Point2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p1</parametername>
</parameternamelist>
<parameterdescription>
<para>first point </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p2</parametername>
</parameternamelist>
<parameterdescription>
<para>second point </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" line="324" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" bodystart="323" bodyend="329"/>
      </memberdef>
      <memberdef kind="function" id="group__assign_1ga1fdbc43645872ba459c455318706a925" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Range</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assign_points</definition>
        <argsstring>(Geometry &amp;geometry, Range const &amp;range)</argsstring>
        <name>assign_points</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Range const &amp;</type>
          <declname>range</declname>
        </param>
        <briefdescription>
<para>Assign a range of points to a linestring, ring or polygon. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The point-type of the range might be different from the point-type of the geometry</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Range</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Range Concept where it range_value type fulfills the Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>range</parametername>
</parameternamelist>
<parameterdescription>
<para>A range containg points fulfilling range and point concepts</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>
[heading Notes]
[note Assign automatically clears the geometry before assigning (use append if you don't want that)]
[heading Example]
[assign_points] [assign_points_output]

[heading See also]
\* [link geometry.reference.algorithms.append append]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" line="71" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" bodystart="70" bodyend="76"/>
      </memberdef>
      <memberdef kind="function" id="group__arithmetic_1gaa6e3bfda2aa04de193ee936a93663c7d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assign_value</definition>
        <argsstring>(Point &amp;p, typename detail::param&lt; Point &gt;::type value)</argsstring>
        <name>assign_value</name>
        <param>
          <type>Point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>typename detail::param&lt; Point &gt;::type</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Assign each coordinate of a point the same value. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>point </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>value to assign </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" line="302" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" bodystart="301" bodyend="310"/>
      </memberdef>
      <memberdef kind="function" id="group__assign_1ga9ee6c10e38a19e8e52bf9a1fc5a19a05" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assign_values</definition>
        <argsstring>(Geometry &amp;geometry, Type const &amp;c1, Type const &amp;c2)</argsstring>
        <name>assign_values</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c1</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c2</declname>
        </param>
        <briefdescription>
<para>Assign two coordinates to a geometry (usually a 2D point) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>numerical type (int, double, ttmath, ...) to specify the coordinates </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c1</parametername>
</parameternamelist>
<parameterdescription>
<para>First coordinate (usually x-coordinate) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second coordinate (usually y-coordinate)</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> 2 coordinate values</qbk.distinguish>   <qbk>
[heading Example]
[assign_2d_point] [assign_2d_point_output]

[heading See also]
\* [link geometry.reference.algorithms.make.make_2_2_coordinate_values make]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" line="148" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" bodystart="147" bodyend="157"/>
      </memberdef>
      <memberdef kind="function" id="group__assign_1ga8ab0619796142e5d72e104349d827738" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assign_values</definition>
        <argsstring>(Geometry &amp;geometry, Type const &amp;c1, Type const &amp;c2, Type const &amp;c3)</argsstring>
        <name>assign_values</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c1</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c2</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c3</declname>
        </param>
        <briefdescription>
<para>Assign three values to a geometry (usually a 3D point) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>numerical type (int, double, ttmath, ...) to specify the coordinates </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c1</parametername>
</parameternamelist>
<parameterdescription>
<para>First coordinate (usually x-coordinate) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second coordinate (usually y-coordinate) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c3</parametername>
</parameternamelist>
<parameterdescription>
<para>Third coordinate (usually z-coordinate)</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> 3 coordinate values</qbk.distinguish>   <qbk>
[heading Example]
[assign_3d_point] [assign_3d_point_output]

[heading See also]
\* [link geometry.reference.algorithms.make.make_3_3_coordinate_values make]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" line="181" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" bodystart="179" bodyend="190"/>
      </memberdef>
      <memberdef kind="function" id="group__assign_1gaaf4e377b4c3c28f42be6d76f2df0ce6b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assign_values</definition>
        <argsstring>(Geometry &amp;geometry, Type const &amp;c1, Type const &amp;c2, Type const &amp;c3, Type const &amp;c4)</argsstring>
        <name>assign_values</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c1</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c2</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c3</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c4</declname>
        </param>
        <briefdescription>
<para>Assign four values to a geometry (usually a box or segment) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>numerical type (int, double, ttmath, ...) to specify the coordinates </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c1</parametername>
</parameternamelist>
<parameterdescription>
<para>First coordinate (usually x1) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second coordinate (usually y1) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c3</parametername>
</parameternamelist>
<parameterdescription>
<para>Third coordinate (usually x2) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c4</parametername>
</parameternamelist>
<parameterdescription>
<para>Fourth coordinate (usually y2)</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> 4 coordinate values</qbk.distinguish>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" line="208" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" bodystart="206" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="group__assign_1gaa7e4279800ffd8a60d4b60bb2ee5c5a7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::assign_zero</definition>
        <argsstring>(Geometry &amp;geometry)</argsstring>
        <name>assign_zero</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>assign zero values to a box, point </para>        </briefdescription>
        <detaileddescription>
<para>The assign_zero function initializes a 2D or 3D point or box with coordinates of zero <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" line="118" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/assign.hpp" bodystart="117" bodyend="126"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer_1ga60bc23b4b5d3b572cf221714dae9a52a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Input</type>
          </param>
          <param>
            <type>typename Output</type>
          </param>
          <param>
            <type>typename Distance</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::buffer</definition>
        <argsstring>(Input const &amp;geometry_in, Output &amp;geometry_out, Distance const &amp;distance, Distance const &amp;chord_length=-1)</argsstring>
        <name>buffer</name>
        <param>
          <type>Input const &amp;</type>
          <declname>geometry_in</declname>
        </param>
        <param>
          <type>Output &amp;</type>
          <declname>geometry_out</declname>
        </param>
        <param>
          <type>Distance const &amp;</type>
          <declname>distance</declname>
        </param>
        <param>
          <type>Distance const &amp;</type>
          <declname>chord_length</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Calculates the buffer of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function buffer calculates the buffer (a polygon being the spatial point set collection within a specified maximum distance from a geometry) of a geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Input</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Output</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Distance</parametername>
</parameternamelist>
<parameterdescription>
<para>numerical type (int, double, ttmath, ...) </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry_in</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry_out</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>distance</parametername>
</parameternamelist>
<parameterdescription>
<para>The distance to be used for the buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>chord_length</parametername>
</parameternamelist>
<parameterdescription>
<para>(optional) The length of the chord&apos;s in the generated arcs around points or bends</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/buffer.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/buffer.hpp" line="184" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/buffer.hpp" bodystart="182" bodyend="189"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer_1gaf56bd07bd0dc7a7e4812223f23ddae7c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryIn</type>
          </param>
          <param>
            <type>typename MultiPolygon</type>
          </param>
          <param>
            <type>typename DistanceStrategy</type>
          </param>
          <param>
            <type>typename SideStrategy</type>
          </param>
          <param>
            <type>typename JoinStrategy</type>
          </param>
          <param>
            <type>typename EndStrategy</type>
          </param>
          <param>
            <type>typename PointStrategy</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::buffer</definition>
        <argsstring>(GeometryIn const &amp;geometry_in, MultiPolygon &amp;geometry_out, DistanceStrategy const &amp;distance_strategy, SideStrategy const &amp;side_strategy, JoinStrategy const &amp;join_strategy, EndStrategy const &amp;end_strategy, PointStrategy const &amp;point_strategy)</argsstring>
        <name>buffer</name>
        <param>
          <type>GeometryIn const &amp;</type>
          <declname>geometry_in</declname>
        </param>
        <param>
          <type>MultiPolygon &amp;</type>
          <declname>geometry_out</declname>
        </param>
        <param>
          <type>DistanceStrategy const &amp;</type>
          <declname>distance_strategy</declname>
        </param>
        <param>
          <type>SideStrategy const &amp;</type>
          <declname>side_strategy</declname>
        </param>
        <param>
          <type>JoinStrategy const &amp;</type>
          <declname>join_strategy</declname>
        </param>
        <param>
          <type>EndStrategy const &amp;</type>
          <declname>end_strategy</declname>
        </param>
        <param>
          <type>PointStrategy const &amp;</type>
          <declname>point_strategy</declname>
        </param>
        <briefdescription>
<para>Calculates the buffer of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function buffer calculates the buffer (a polygon being the spatial point set collection within a specified maximum distance from a geometry) of a geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>GeometryIn</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MultiPolygon</parametername>
</parameternamelist>
<parameterdescription>
<para>A type fulfilling the MultiPolygon Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>DistanceStrategy</parametername>
</parameternamelist>
<parameterdescription>
<para>A strategy defining distance (or radius) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SideStrategy</parametername>
</parameternamelist>
<parameterdescription>
<para>A strategy defining creation along sides </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>JoinStrategy</parametername>
</parameternamelist>
<parameterdescription>
<para>A strategy defining creation around convex corners </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>EndStrategy</parametername>
</parameternamelist>
<parameterdescription>
<para>A strategy defining creation at linestring ends </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PointStrategy</parametername>
</parameternamelist>
<parameterdescription>
<para>A strategy defining creation around points </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry_in</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry_out</parametername>
</parameternamelist>
<parameterdescription>
<para>output multi polygon (or std:: collection of polygons), will contain a buffered version of the input geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>distance_strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The distance strategy to be used </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>side_strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The side strategy to be used </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>join_strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The join strategy to be used </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end_strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The end strategy to be used </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>point_strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The point strategy to be used</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish>with strategies</qbk.distinguish>   <qbk>[include reference/algorithms/buffer_with_strategies.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/buffer.hpp" line="257" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/buffer.hpp" bodystart="250" bodyend="287"/>
      </memberdef>
      <memberdef kind="function" id="group__centroid_1ga3ec2c5e245c42ffaf28f1c88ea564c8c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Point</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::centroid</definition>
        <argsstring>(Geometry const &amp;geometry, Point &amp;c, Strategy const &amp;strategy)</argsstring>
        <name>centroid</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Point &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Calculates the centroid of a geometry using the specified strategy. </para>        </briefdescription>
        <detaileddescription>
<para>The free function centroid calculates the geometric center (or: center of mass) of a geometry. Reasons to specify a strategy include: use another coordinate system for calculations; construct the strategy beforehand (e.g. with the radius of the Earth); select a strategy when there are more than one available for a calculation. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Centroid Strategy Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified Point Concept which is set to the \1 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The strategy which will be used for centroid calculations</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish>with strategy</qbk.distinguish>   <qbk>[include reference/algorithms/centroid.qbk]</qbk>   <qbk>[include reference/algorithms/centroid_strategies.qbk]</qbk>  } </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/centroid.hpp" line="606" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/centroid.hpp" bodystart="604" bodyend="608"/>
      </memberdef>
      <memberdef kind="function" id="group__centroid_1ga0231bbe9c80e9009271245e31ce5496b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Point</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::centroid</definition>
        <argsstring>(Geometry const &amp;geometry, Point &amp;c)</argsstring>
        <name>centroid</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Point &amp;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Calculates the centroid of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function centroid calculates the geometric center (or: center of mass) of a geometry. It uses the default strategy, based on the coordinate system of the geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>The calculated centroid will be assigned to this point reference</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/centroid.qbk]</qbk>   <qbk>
[heading Example]
[centroid]
[centroid_output]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/centroid.hpp" line="629" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/centroid.hpp" bodystart="628" bodyend="631"/>
      </memberdef>
      <memberdef kind="function" id="group__clear_1ga61147247703a55d2d81badbd7f0a12a9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::clear</definition>
        <argsstring>(Geometry &amp;geometry)</argsstring>
        <name>clear</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Clears a linestring, ring or polygon (exterior+interiors) or multi*. </para>        </briefdescription>
        <detaileddescription>
<para>Generic function to clear a geometry. All points will be removed from the collection or collections making up the geometry. In most cases this is equivalent to the .<ref refid="group__clear_1ga61147247703a55d2d81badbd7f0a12a9" kindref="member">clear()</ref> method of a std::vector&lt;...&gt;. In the case of a polygon, this clear functionality is automatically called for the exterior ring, and for the interior ring collection. In the case of a point, boxes and segments, nothing will happen.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which will be cleared </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>points and boxes cannot be cleared, instead they can be set to zero by &quot;assign_zero&quot;</para></simplesect>
 <qbk>[include reference/algorithms/clear.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/clear.hpp" line="187" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/clear.hpp" bodystart="186" bodyend="191"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a01cddb2f3a4f6294198cd7bb58084236" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Collection</type>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::collect_vectors</definition>
        <argsstring>(Collection &amp;collection, Geometry const &amp;geometry)</argsstring>
        <name>collect_vectors</name>
        <param>
          <type>Collection &amp;</type>
          <declname>collection</declname>
        </param>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Collection</parametername>
</parameternamelist>
<parameterdescription>
<para>Collection type, should be e.g. std::vector&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>collection</parametername>
</parameternamelist>
<parameterdescription>
<para>the collection of vectors </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>the geometry to make collect_vectors </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/equals/collect_vectors.hpp" line="314" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/equals/collect_vectors.hpp" bodystart="313" bodyend="323"/>
      </memberdef>
      <memberdef kind="function" id="group__distance_1ga96e975b2491449d359a57a84a03c2a86" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1comparable__distance__result" kindref="compound">comparable_distance_result</ref>&lt; Geometry1, Geometry2, Strategy &gt;::type</type>
        <definition>comparable_distance_result&lt;Geometry1, Geometry2, Strategy&gt;::type boost::geometry::comparable_distance</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Strategy const &amp;strategy)</argsstring>
        <name>comparable_distance</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Calculate the comparable distance measurement of two geometries using the specified strategy. </para>        </briefdescription>
        <detaileddescription>
<para>The free function comparable_distance does not necessarily calculate the distance, but it calculates a distance measure such that two distances are comparable to each other. For example: for the Cartesian coordinate system, Pythagoras is used but the square root is not taken, which makes it faster and the results of two point pairs can still be compared to each other. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>first geometry type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>second geometry type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Distance Strategy Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The strategy which will be used for distance calculations </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk.distinguish>with strategy</qbk.distinguish>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/comparable_distance/interface.hpp" line="320" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/comparable_distance/interface.hpp" bodystart="318" bodyend="329"/>
      </memberdef>
      <memberdef kind="function" id="group__distance_1gabdb5143911178c7e4c78114a785551ae" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1default__comparable__distance__result" kindref="compound">default_comparable_distance_result</ref>&lt; Geometry1, Geometry2 &gt;::type</type>
        <definition>default_comparable_distance_result&lt;Geometry1, Geometry2&gt;::type boost::geometry::comparable_distance</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>comparable_distance</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Calculate the comparable distance measurement of two geometries. </para>        </briefdescription>
        <detaileddescription>
<para>The free function comparable_distance does not necessarily calculate the distance, but it calculates a distance measure such that two distances are comparable to each other. For example: for the Cartesian coordinate system, Pythagoras is used but the square root is not taken, which makes it faster and the results of two point pairs can still be compared to each other. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>first geometry type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>second geometry type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk>[include reference/algorithms/comparable_distance.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/comparable_distance/interface.hpp" line="352" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/comparable_distance/interface.hpp" bodystart="351" bodyend="357"/>
      </memberdef>
      <memberdef kind="function" id="group__convert_1ga79cfffc1475f201bda92cb40a075a3d1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::convert</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 &amp;geometry2)</argsstring>
        <name>convert</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Converts one geometry to another geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The convert algorithm converts one geometry, e.g. a BOX, to another geometry, e.g. a RING. This only works if it is possible and applicable. If the point-order is different, or the closure is different between two geometry types, it will be converted correctly by explicitly reversing the points or closing or opening the polygon rings.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept (source) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept (target)</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/convert.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/convert.hpp" line="549" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/convert.hpp" bodystart="548" bodyend="551"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a5f0f6e4d01982d810d1ad1c1817521cb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename OutputGeometry</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::convex_hull</definition>
        <argsstring>(Geometry const &amp;geometry, OutputGeometry &amp;out, Strategy const &amp;strategy)</argsstring>
        <name>convex_hull</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>OutputGeometry &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/convex_hull.hpp" line="304" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/convex_hull.hpp" bodystart="302" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="group__convex__hull_1gadce5f964b027cc193af16673ad8ff4e9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename OutputGeometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::convex_hull</definition>
        <argsstring>(Geometry const &amp;geometry, OutputGeometry &amp;hull)</argsstring>
        <name>convex_hull</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>OutputGeometry &amp;</type>
          <declname>hull</declname>
        </param>
        <briefdescription>
<para>Calculates the convex hull of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function convex_hull calculates the convex hull of a geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>the input geometry type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutputGeometry</parametername>
</parameternamelist>
<parameterdescription>
<para>the output geometry type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept, input geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>hull</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which is set to the \1</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/convex_hull.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/convex_hull.hpp" line="329" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/convex_hull.hpp" bodystart="327" bodyend="331"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a940cd6b6c22894d4b486793e34aa4f48" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>Reverse</declname>
            <defname>Reverse</defname>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename SegmentIdentifier</type>
          </param>
          <param>
            <type>typename PointOut</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::copy_segment_point</definition>
        <argsstring>(Geometry const &amp;geometry, SegmentIdentifier const &amp;seg_id, int offset, PointOut &amp;point_out)</argsstring>
        <name>copy_segment_point</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>SegmentIdentifier const &amp;</type>
          <declname>seg_id</declname>
        </param>
        <param>
          <type>int</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>PointOut &amp;</type>
          <declname>point_out</declname>
        </param>
        <briefdescription>
<para>Helper function, copies a point from a segment. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/copy_segment_point.hpp" line="286" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/copy_segment_point.hpp" bodystart="283" bodyend="297"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a52e34bc3d6bad7f7e39e13f19a2c9bde" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>Reverse1</declname>
            <defname>Reverse1</defname>
          </param>
          <param>
            <type>bool</type>
            <declname>Reverse2</declname>
            <defname>Reverse2</defname>
          </param>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename SegmentIdentifier</type>
          </param>
          <param>
            <type>typename PointOut</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::copy_segment_point</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, SegmentIdentifier const &amp;seg_id, int offset, PointOut &amp;point_out)</argsstring>
        <name>copy_segment_point</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>SegmentIdentifier const &amp;</type>
          <declname>seg_id</declname>
        </param>
        <param>
          <type>int</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>PointOut &amp;</type>
          <declname>point_out</declname>
        </param>
        <briefdescription>
<para>Helper function, to avoid the same construct several times, copies a point, based on a source-index and two geometries. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/copy_segment_point.hpp" line="315" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/copy_segment_point.hpp" bodystart="312" bodyend="345"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ad1fe604e9b46fabfc39147d341472026" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>Reverse1</declname>
            <defname>Reverse1</defname>
          </param>
          <param>
            <type>bool</type>
            <declname>Reverse2</declname>
            <defname>Reverse2</defname>
          </param>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename SegmentIdentifier</type>
          </param>
          <param>
            <type>typename PointOut</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::copy_segment_points</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, SegmentIdentifier const &amp;seg_id, PointOut &amp;point1, PointOut &amp;point2)</argsstring>
        <name>copy_segment_points</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>SegmentIdentifier const &amp;</type>
          <declname>seg_id</declname>
        </param>
        <param>
          <type>PointOut &amp;</type>
          <declname>point1</declname>
        </param>
        <param>
          <type>PointOut &amp;</type>
          <declname>point2</declname>
        </param>
        <briefdescription>
<para>Helper function, to avoid the same construct several times, copies a point, based on a source-index and two geometries. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/copy_segment_point.hpp" line="363" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/copy_segment_point.hpp" bodystart="360" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1aca0fd80f5a980e4cb73e580227bab287" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>Reverse1</declname>
            <defname>Reverse1</defname>
          </param>
          <param>
            <type>bool</type>
            <declname>Reverse2</declname>
            <defname>Reverse2</defname>
          </param>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename SegmentIdentifier</type>
          </param>
          <param>
            <type>typename PointOut</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::copy_segment_points</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, SegmentIdentifier const &amp;seg_id, PointOut &amp;point1, PointOut &amp;point2, PointOut &amp;point3)</argsstring>
        <name>copy_segment_points</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>SegmentIdentifier const &amp;</type>
          <declname>seg_id</declname>
        </param>
        <param>
          <type>PointOut &amp;</type>
          <declname>point1</declname>
        </param>
        <param>
          <type>PointOut &amp;</type>
          <declname>point2</declname>
        </param>
        <param>
          <type>PointOut &amp;</type>
          <declname>point3</declname>
        </param>
        <briefdescription>
<para>Helper function, copies three points: two from the specified segment (from, to) and the next one. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/copy_segment_point.hpp" line="386" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/copy_segment_point.hpp" bodystart="383" bodyend="393"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1aa3b0e31bed132879fd68c9a19d95d20b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>Reverse</declname>
            <defname>Reverse</defname>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename SegmentIdentifier</type>
          </param>
          <param>
            <type>typename RobustPolicy</type>
          </param>
          <param>
            <type>typename RangeOut</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::copy_segments</definition>
        <argsstring>(Geometry const &amp;geometry, SegmentIdentifier const &amp;seg_id, signed_size_type to_index, RobustPolicy const &amp;robust_policy, RangeOut &amp;range_out)</argsstring>
        <name>copy_segments</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>SegmentIdentifier const &amp;</type>
          <declname>seg_id</declname>
        </param>
        <param>
          <type><ref refid="namespaceboost_1_1geometry_1af0c576f82145cf6a02dcbf48b675a0c2" kindref="member">signed_size_type</ref></type>
          <declname>to_index</declname>
        </param>
        <param>
          <type>RobustPolicy const &amp;</type>
          <declname>robust_policy</declname>
        </param>
        <param>
          <type>RangeOut &amp;</type>
          <declname>range_out</declname>
        </param>
        <briefdescription>
<para>Copy segments from a geometry, starting with the specified segment (seg_id) until the specified index (to_index) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/copy_segments.hpp" line="351" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/copy_segments.hpp" bodystart="346" bodyend="359"/>
      </memberdef>
      <memberdef kind="function" id="group__correct_1gaf14641937f187af33fec6bd99c8202d9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::correct</definition>
        <argsstring>(Geometry &amp;geometry)</argsstring>
        <name>correct</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Corrects a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>Corrects a geometry: all rings which are wrongly oriented with respect to their expected orientation are reversed. To all rings which do not have a closing point and are typed as they should have one, the first point is appended. Also boxes can be corrected.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which will be corrected if necessary</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/correct.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/correct.hpp" line="327" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/correct.hpp" bodystart="326" bodyend="329"/>
      </memberdef>
      <memberdef kind="function" id="group__covered__by_1ga83cfa260c6a4f3bcba5a99da6113d19c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::covered_by</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>covered_by</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Checks if the first geometry is inside or on border the second geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function covered_by checks if the first geometry is inside or on border the second geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which might be inside or on the border of the second geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which might cover the first geometry </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if geometry1 is inside of or on the border of geometry2, else false </para></simplesect>
<simplesect kind="note"><para>The default strategy is used for covered_by detection</para></simplesect>
 <qbk>[include reference/algorithms/covered_by.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/covered_by.hpp" line="442" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/covered_by.hpp" bodystart="441" bodyend="445"/>
      </memberdef>
      <memberdef kind="function" id="group__covered__by_1ga4db6801730953629ec9eb040a5ccc1ad" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::covered_by</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Strategy const &amp;strategy)</argsstring>
        <name>covered_by</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Checks if the first geometry is inside or on border the second geometry using the specified strategy. </para>        </briefdescription>
        <detaileddescription>
<para>The free function covered_by checks if the first geometry is inside or on border the second geometry, using the specified strategy. Reasons to specify a strategy include: use another coordinate system for calculations; construct the strategy beforehand (e.g. with the radius of the Earth); select a strategy when there are more than one available for a calculation. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which might be inside or on the border of the second geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which might cover the first geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>strategy to be used </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if geometry1 is inside of or on the border of geometry2, else false</para></simplesect>
 <qbk.distinguish>with strategy</qbk.distinguish>   <qbk>[include reference/algorithms/covered_by.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/covered_by.hpp" line="466" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/covered_by.hpp" bodystart="464" bodyend="469"/>
      </memberdef>
      <memberdef kind="function" id="group__crosses_1gab50efa33876edf806597ea27a9d77989" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::crosses</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>crosses</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Checks if two geometries \1. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns true if two geometries \1</para></simplesect>
 <qbk>[include reference/algorithms/crosses.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/crosses.hpp" line="186" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/crosses.hpp" bodystart="185" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="group__difference_1gae23e000e550abb271baac3679fae7640" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename Collection</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::difference</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Collection &amp;output_collection)</argsstring>
        <name>difference</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>Collection &amp;</type>
          <declname>output_collection</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Calculate the difference of two geometries</para><para>The free function difference calculates the spatial set theoretic difference of two geometries. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Collection</parametername>
</parameternamelist>
<parameterdescription>
<para>output collection, either a multi-geometry, or a std::vector&lt;Geometry&gt; / std::deque&lt;Geometry&gt; etc </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output_collection</parametername>
</parameternamelist>
<parameterdescription>
<para>the output collection</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/difference.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/difference.hpp" line="144" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/difference.hpp" bodystart="142" bodyend="163"/>
      </memberdef>
      <memberdef kind="function" id="group__disjoint_1ga980fdae7d8c1840c1362f09bb0dcf04e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::disjoint</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>disjoint</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Checks if two geometries \1. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns true if two geometries \1</para></simplesect>
 <qbk>[include reference/algorithms/disjoint.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/disjoint/interface.hpp" line="179" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/disjoint/interface.hpp" bodystart="177" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="group__distance_1ga7d68c34d1ded4428903f906244b31da4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1distance__result" kindref="compound">distance_result</ref>&lt; Geometry1, Geometry2, Strategy &gt;::type</type>
        <definition>distance_result&lt;Geometry1, Geometry2, Strategy&gt;::type boost::geometry::distance</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Strategy const &amp;strategy)</argsstring>
        <name>distance</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Calculate the distance of two geometries using the specified strategy. </para>        </briefdescription>
        <detaileddescription>
<para>The free function area calculates the area of a geometry. using the specified strategy. Reasons to specify a strategy include: use another coordinate system for calculations; construct the strategy beforehand (e.g. with the radius of the Earth); select a strategy when there are more than one available for a calculation.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Distance Strategy Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The strategy which will be used for distance calculations </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1 </para></simplesect>
<simplesect kind="note"><para>The strategy can be a point-point strategy. In case of distance point-line/point-polygon it may also be a point-segment strategy.</para></simplesect>
 <qbk.distinguish>with strategy</qbk.distinguish> </para><para> <qbk>
[heading Available Strategies]
\* [link geometry.reference.strategies.strategy_distance_pythagoras Pythagoras (cartesian)]
\* [link geometry.reference.strategies.strategy_distance_haversine Haversine (spherical)]
\* [link geometry.reference.strategies.strategy_distance_cross_track Cross track (spherical, point-to-segment)]
\* [link geometry.reference.strategies.strategy_distance_projected_point Projected point (cartesian, point-to-segment)]
\* more (currently extensions): Vincenty, Andoyer (geographic)
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/distance/interface.hpp" line="363" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/distance/interface.hpp" bodystart="360" bodyend="375"/>
      </memberdef>
      <memberdef kind="function" id="group__distance_1gad5f5e3da7d38da77c40d7bdad61fee54" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1default__distance__result" kindref="compound">default_distance_result</ref>&lt; Geometry1, Geometry2 &gt;::type</type>
        <definition>default_distance_result&lt;Geometry1, Geometry2&gt;::type boost::geometry::distance</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>distance</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Calculate the distance of two geometries. </para>        </briefdescription>
        <detaileddescription>
<para>The default strategy is used, corresponding to the coordinate system of the geometries <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk>[include reference/algorithms/distance.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/distance/interface.hpp" line="394" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/distance/interface.hpp" bodystart="392" bodyend="399"/>
      </memberdef>
      <memberdef kind="function" id="group__arithmetic_1ga8141e616132d8d614da3428863336dc9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point1</type>
          </param>
          <param>
            <type>typename Point2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::divide_point</definition>
        <argsstring>(Point1 &amp;p1, Point2 const &amp;p2)</argsstring>
        <name>divide_point</name>
        <param>
          <type>Point1 &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>Point2 const &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
<para>Divides a point by another. </para>        </briefdescription>
        <detaileddescription>
<para>The coordinates of the first point will be divided by those of the second point. The second point is not modified. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Point2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p1</parametername>
</parameternamelist>
<parameterdescription>
<para>first point </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p2</parametername>
</parameternamelist>
<parameterdescription>
<para>second point </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" line="285" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" bodystart="284" bodyend="290"/>
      </memberdef>
      <memberdef kind="function" id="group__arithmetic_1ga98645f15cfba3e9e9e9e83c72e0f98e3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::divide_value</definition>
        <argsstring>(Point &amp;p, typename detail::param&lt; Point &gt;::type value)</argsstring>
        <name>divide_value</name>
        <param>
          <type>Point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>typename detail::param&lt; Point &gt;::type</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Divides each coordinate of the same point by a value. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>point </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>value to divide by </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" line="262" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" bodystart="261" bodyend="271"/>
      </memberdef>
      <memberdef kind="function" id="group__arithmetic_1gaf962409b64cd5023d9e439c4468db1d2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point1</type>
          </param>
          <param>
            <type>typename Point2</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1select__coordinate__type" kindref="compound">select_coordinate_type</ref>&lt; Point1, Point2 &gt;::type</type>
        <definition>select_coordinate_type&lt;Point1, Point2&gt;::type boost::geometry::dot_product</definition>
        <argsstring>(Point1 const &amp;p1, Point2 const &amp;p2)</argsstring>
        <name>dot_product</name>
        <param>
          <type>Point1 const &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>Point2 const &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
<para>Computes the dot product (or scalar product) of 2 vectors (points). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Point2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p1</parametername>
</parameternamelist>
<parameterdescription>
<para>first point </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p2</parametername>
</parameternamelist>
<parameterdescription>
<para>second point </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the dot product </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/dot_product.hpp" line="71" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/dot_product.hpp" bodystart="69" bodyend="80"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1adfcf6eedaf9497f45d057cccd4875588" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>Reverse1</declname>
            <defname>Reverse1</defname>
          </param>
          <param>
            <type>bool</type>
            <declname>Reverse2</declname>
            <defname>Reverse2</defname>
          </param>
          <param>
            <type>overlay_type</type>
            <declname>OverlayType</declname>
            <defname>OverlayType</defname>
          </param>
          <param>
            <type>typename Turns</type>
          </param>
          <param>
            <type>typename Clusters</type>
          </param>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename RobustPolicy</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::enrich_intersection_points</definition>
        <argsstring>(Turns &amp;turns, Clusters &amp;clusters, detail::overlay::operation_type for_operation, Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, RobustPolicy const &amp;robust_policy, Strategy const &amp;strategy)</argsstring>
        <name>enrich_intersection_points</name>
        <param>
          <type>Turns &amp;</type>
          <declname>turns</declname>
        </param>
        <param>
          <type>Clusters &amp;</type>
          <declname>clusters</declname>
        </param>
        <param>
          <type>detail::overlay::operation_type</type>
          <declname>for_operation</declname>
        </param>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>RobustPolicy const &amp;</type>
          <declname>robust_policy</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>All intersection points are enriched with successor information. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Turns</parametername>
</parameternamelist>
<parameterdescription>
<para>type of intersection container (e.g. vector of &quot;intersection/turn point&quot;&apos;s) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>side strategy type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>turns</parametername>
</parameternamelist>
<parameterdescription>
<para>container containing intersectionpoints </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>for_operation</parametername>
</parameternamelist>
<parameterdescription>
<para>operation_type (union or intersection) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>robust_policy</parametername>
</parameternamelist>
<parameterdescription>
<para>policy to handle robustness issues </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>strategy </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/enrich_intersection_points.hpp" line="264" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/enrich_intersection_points.hpp" bodystart="258" bodyend="339"/>
      </memberdef>
      <memberdef kind="function" id="group__envelope_1gac1f1865a7b36047d44949e17266d8f5a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Box</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::envelope</definition>
        <argsstring>(Geometry const &amp;geometry, Box &amp;mbr)</argsstring>
        <name>envelope</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Box &amp;</type>
          <declname>mbr</declname>
        </param>
        <briefdescription>
<para>Calculates the envelope of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function envelope calculates the envelope (also known as axis aligned bounding box, aabb, or minimum bounding rectangle, mbr) of a geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Box</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Box Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mbr</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified Box Concept which is set to the \1</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/envelope.qbk]</qbk>   <qbk>
[heading Example]
[envelope] [envelope_output]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/envelope/interface.hpp" line="96" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/envelope/interface.hpp" bodystart="95" bodyend="98"/>
      </memberdef>
      <memberdef kind="function" id="group__equals_1gaf75334fd455c4d01a57a2f2d590d068c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::equals</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>equals</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Checks if a geometry \1. </para>        </briefdescription>
        <detaileddescription>
<para>The free function equals checks if the first geometry is spatially equal the second geometry. Spatially equal means that the same point set is included. A box can therefore be spatially equal to a ring or a polygon, or a linestring can be spatially equal to a multi-linestring or a segment. This only works theoretically, not all combinations are implemented yet.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns true if two geometries \1</para></simplesect>
 <qbk>[include reference/algorithms/equals.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/equals.hpp" line="460" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/equals.hpp" bodystart="459" bodyend="463"/>
      </memberdef>
      <memberdef kind="function" id="group__expand_1ga2f189378ab0aa90c5b98bd7f3ed3cc93" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Box</type>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::expand</definition>
        <argsstring>(Box &amp;box, Geometry const &amp;geometry)</argsstring>
        <name>expand</name>
        <param>
          <type>Box &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Expands a box using the bounding box (envelope) of another geometry (box, point) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Box</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the box </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>box</parametername>
</parameternamelist>
<parameterdescription>
<para>box to be expanded using another geometry, mutable </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept geometry which envelope (bounding box) will be added to the box</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/expand.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/expand/interface.hpp" line="122" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/expand/interface.hpp" bodystart="121" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="group__exterior__ring_1ga08713d51a3bbe530a5f69b5084107d89" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Polygon</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1ring__return__type" kindref="compound">ring_return_type</ref>&lt; Polygon &gt;::type</type>
        <definition>ring_return_type&lt;Polygon&gt;::type boost::geometry::exterior_ring</definition>
        <argsstring>(Polygon &amp;polygon)</argsstring>
        <name>exterior_ring</name>
        <param>
          <type>Polygon &amp;</type>
          <declname>polygon</declname>
        </param>
        <briefdescription>
<para>Function to get the exterior_ring ring of a polygon. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>OGC compliance: instead of ExteriorRing </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Polygon</parametername>
</parameternamelist>
<parameterdescription>
<para>polygon type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>polygon</parametername>
</parameternamelist>
<parameterdescription>
<para>the polygon to get the exterior ring from </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a reference to the exterior ring </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/exterior_ring.hpp" line="111" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/exterior_ring.hpp" bodystart="110" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="group__exterior__ring_1ga96a935d3093b77955f100cc3da6a4e51" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Polygon</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1ring__return__type" kindref="compound">ring_return_type</ref>&lt; Polygon const  &gt;::type</type>
        <definition>ring_return_type&lt;Polygon const&gt;::type boost::geometry::exterior_ring</definition>
        <argsstring>(Polygon const &amp;polygon)</argsstring>
        <name>exterior_ring</name>
        <param>
          <type>Polygon const &amp;</type>
          <declname>polygon</declname>
        </param>
        <briefdescription>
<para>Function to get the exterior ring of a polygon (const version) </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>OGC compliance: instead of ExteriorRing </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Polygon</parametername>
</parameternamelist>
<parameterdescription>
<para>polygon type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>polygon</parametername>
</parameternamelist>
<parameterdescription>
<para>the polygon to get the exterior ring from </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a const reference to the exterior ring</para></simplesect>
 <qbk.distinguish>const version</qbk.distinguish>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/exterior_ring.hpp" line="133" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/exterior_ring.hpp" bodystart="131" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a6e974796693e03c4e4837477054bae35" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>Edge</declname>
            <defname>Edge</defname>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Extremes</type>
          </param>
          <param>
            <type>typename Intruders</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::extreme_points</definition>
        <argsstring>(Geometry const &amp;geometry, Extremes &amp;extremes, Intruders &amp;intruders)</argsstring>
        <name>extreme_points</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Extremes &amp;</type>
          <declname>extremes</declname>
        </param>
        <param>
          <type>Intruders &amp;</type>
          <declname>intruders</declname>
        </param>
        <briefdescription>
<para>Returns extreme points (for Edge=1 in dimension 1, so the top, for Edge=0 in dimension 0, the right side) </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>We could specify a strategy (less/greater) to get bottom/left side too. However, until now we don&apos;t need that. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/extreme_points.hpp" line="494" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/extreme_points.hpp" bodystart="493" bodyend="513"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ad61d195eec9f266bb67b31f72a022606" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
          <param>
            <type>typename Op</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::for_each_coordinate</definition>
        <argsstring>(Point &amp;point, Op operation)</argsstring>
        <name>for_each_coordinate</name>
        <param>
          <type>Point &amp;</type>
          <declname>point</declname>
        </param>
        <param>
          <type>Op</type>
          <declname>operation</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/util/for_each_coordinate.hpp" line="68" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/util/for_each_coordinate.hpp" bodystart="67" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ac25c04e4afa958469c5b8e911eac143f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
          <param>
            <type>typename Op</type>
          </param>
        </templateparamlist>
        <type>Op</type>
        <definition>Op boost::geometry::for_each_coordinate</definition>
        <argsstring>(Point const &amp;point, Op operation)</argsstring>
        <name>for_each_coordinate</name>
        <param>
          <type>Point const &amp;</type>
          <declname>point</declname>
        </param>
        <param>
          <type>Op</type>
          <declname>operation</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/util/for_each_coordinate.hpp" line="81" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/util/for_each_coordinate.hpp" bodystart="80" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="group__for__each_1ga3010849a8b501309db7b74157382cfaf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Functor</type>
          </param>
        </templateparamlist>
        <type>Functor</type>
        <definition>Functor boost::geometry::for_each_point</definition>
        <argsstring>(Geometry &amp;geometry, Functor f)</argsstring>
        <name>for_each_point</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Functor</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Applies function [*f] to each \1. </para>        </briefdescription>
        <detaileddescription>
<para>Applies a function [*f] (functor, having operator() defined) to each point making up the geometry</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Unary function, taking a point as argument </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Functor</parametername>
</parameternamelist>
<parameterdescription>
<para>Function or class with operator()</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/for_each_point.qbk]</qbk>   <qbk>[heading Example]</qbk>   <qbk>[for_each_point] [for_each_point_output]</qbk>   <qbk>[for_each_point_const] [for_each_point_const_output]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/for_each.hpp" line="339" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/for_each.hpp" bodystart="338" bodyend="344"/>
      </memberdef>
      <memberdef kind="function" id="group__for__each_1ga42ec4761584f85dae332cd4266418017" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Functor</type>
          </param>
        </templateparamlist>
        <type>Functor</type>
        <definition>Functor boost::geometry::for_each_segment</definition>
        <argsstring>(Geometry &amp;geometry, Functor f)</argsstring>
        <name>for_each_segment</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Functor</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Applies function [*f] to each \1. </para>        </briefdescription>
        <detaileddescription>
<para>Applies a function [*f] (functor, having operator() defined) to each segment making up the geometry</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Unary function, taking a segment as argument </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Functor</parametername>
</parameternamelist>
<parameterdescription>
<para>Function or class with operator()</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/for_each_segment.qbk]</qbk>   <qbk>[heading Example]</qbk>   <qbk>[for_each_segment_const] [for_each_segment_const_output]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/for_each.hpp" line="362" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/for_each.hpp" bodystart="361" bodyend="367"/>
      </memberdef>
      <memberdef kind="function" id="group__get_1ga6f2549aa15489bdfa2e0ee28c620ab07" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>Dimension</declname>
            <defname>Dimension</defname>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1coordinate__type" kindref="compound">coordinate_type</ref>&lt; Geometry &gt;::type</type>
        <definition>coordinate_type&lt;Geometry&gt;::type boost::geometry::get</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>get</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Get coordinate value of a geometry (usually a point) </para>        </briefdescription>
        <detaileddescription>
<para>The free functions [*get] and [*set] are two of the most important functions of Boost.Geometry, both within the library, as also for the library user. With these two functions you normally get and set coordinate values from and for a point, box, segment or sphere.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Dimension</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension, this template parameter is required. Should contain \[0 .. n-1\] for an n-dimensional geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept (usually a Point Concept) </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept (usually a point) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The coordinate value of specified dimension of specified geometry</para></simplesect>
 <qbk>[include reference/core/get_point.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" line="274" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" bodystart="269" bodyend="287"/>
      </memberdef>
      <memberdef kind="function" id="group__get_1gabf9ceb2655358244b0348cef1f308288" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>Index</declname>
            <defname>Index</defname>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>Dimension</declname>
            <defname>Dimension</defname>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1coordinate__type" kindref="compound">coordinate_type</ref>&lt; Geometry &gt;::type</type>
        <definition>coordinate_type&lt;Geometry&gt;::type boost::geometry::get</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>get</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>get coordinate value of a Box or Segment </para>        </briefdescription>
        <detaileddescription>
<para>The free functions [*get] and [*set] are two of the most important functions of Boost.Geometry, both within the library, as also for the library user. With these two functions you normally get and set coordinate values from and for a point, box, segment or sphere. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>Index, this template parameter is required. For a Box: either min_corner or max_corner. For a Segment: either 0 or 1 for first or last point. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Dimension</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension, this template parameter is required. Should contain \[0 .. n-1\] for an n-dimensional geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Box Concept or a Segment Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>coordinate value</para></simplesect>
 <qbk.distinguish>with index</qbk.distinguish>   <qbk>[include reference/core/get_box.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" line="344" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" bodystart="339" bodyend="358"/>
      </memberdef>
      <memberdef kind="function" id="group__get_1ga599e31cfc2d3b5074bc3ac4cf24b9152" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>Dimension</declname>
            <defname>Dimension</defname>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1fp__coordinate__type" kindref="compound">fp_coordinate_type</ref>&lt; Geometry &gt;::type</type>
        <definition>fp_coordinate_type&lt;Geometry&gt;::type boost::geometry::get_as_radian</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>get_as_radian</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>get coordinate value of a point, result is in Radian </para>        </briefdescription>
        <detaileddescription>
<para>Result is in Radian, even if source coordinate system is in Degrees <simplesect kind="return"><para>coordinate value</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Dimension</parametername>
</parameternamelist>
<parameterdescription>
<para>dimension </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry to get coordinate value from </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Only applicable to coordinate systems templatized by units, e.g. spherical or geographic coordinate systems </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/radian_access.hpp" line="128" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/radian_access.hpp" bodystart="127" bodyend="131"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ad8660b0cfc5db2cf38ce39dc32172c8f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename RobustPolicy</type>
          </param>
          <param>
            <type>typename Turns</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::get_intersection_points</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, RobustPolicy const &amp;robust_policy, Turns &amp;turns)</argsstring>
        <name>get_intersection_points</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>RobustPolicy const &amp;</type>
          <declname>robust_policy</declname>
        </param>
        <param>
          <type>Turns &amp;</type>
          <declname>turns</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/get_intersection_points.hpp" line="111" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/get_intersection_points.hpp" bodystart="107" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="group__access_1ga1e0627c198b569ca7f278acce06120ee" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1radius__type" kindref="compound">radius_type</ref>&lt; Geometry &gt;::type</type>
        <definition>radius_type&lt;Geometry&gt;::type boost::geometry::get_radius</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>get_radius</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Function to get radius of a circle / sphere / ellipse / etc. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>radius The radius for a given axis</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>the geometry to get the radius from </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>index of the axis </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/radius.hpp" line="127" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/radius.hpp" bodystart="126" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a89288d6d8396b6b713099f502277ea04" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>Reverse1</declname>
            <defname>Reverse1</defname>
          </param>
          <param>
            <type>bool</type>
            <declname>Reverse2</declname>
            <defname>Reverse2</defname>
          </param>
          <param>
            <type>typename AssignPolicy</type>
          </param>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename RobustPolicy</type>
          </param>
          <param>
            <type>typename Turns</type>
          </param>
          <param>
            <type>typename InterruptPolicy</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::get_turns</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, RobustPolicy const &amp;robust_policy, Turns &amp;turns, InterruptPolicy &amp;interrupt_policy)</argsstring>
        <name>get_turns</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>RobustPolicy const &amp;</type>
          <declname>robust_policy</declname>
        </param>
        <param>
          <type>Turns &amp;</type>
          <declname>turns</declname>
        </param>
        <param>
          <type>InterruptPolicy &amp;</type>
          <declname>interrupt_policy</declname>
        </param>
        <briefdescription>
<para>Calculate the turn points of two geometries. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Turns</parametername>
</parameternamelist>
<parameterdescription>
<para>type of turn-container (e.g. vector of &quot;intersection/turn point&quot;&apos;s) </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>robust_policy</parametername>
</parameternamelist>
<parameterdescription>
<para>policy to handle robustness issues </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>turns</parametername>
</parameternamelist>
<parameterdescription>
<para>container which will contain turn points </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>interrupt_policy</parametername>
</parameternamelist>
<parameterdescription>
<para>policy determining if process is stopped when intersection is found </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/get_turns.hpp" line="974" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/get_turns.hpp" bodystart="969" bodyend="1004"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a591a8b3ec94a359069e5e07d8a238b2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::has_infinite_coordinate</definition>
        <argsstring>(Point const &amp;point)</argsstring>
        <name>has_infinite_coordinate</name>
        <param>
          <type>Point const &amp;</type>
          <declname>point</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/util/has_infinite_coordinate.hpp" line="41" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/util/has_infinite_coordinate.hpp" bodystart="40" bodyend="51"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ad4a419817fdd2bf57433c6a0d9e47595" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::has_nan_coordinate</definition>
        <argsstring>(Point const &amp;point)</argsstring>
        <name>has_nan_coordinate</name>
        <param>
          <type>Point const &amp;</type>
          <declname>point</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/util/has_nan_coordinate.hpp" line="85" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/util/has_nan_coordinate.hpp" bodystart="84" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a2f950b91e4e331aff1235ddd25deef72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::has_non_finite_coordinate</definition>
        <argsstring>(Point const &amp;point)</argsstring>
        <name>has_non_finite_coordinate</name>
        <param>
          <type>Point const &amp;</type>
          <declname>point</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/util/has_non_finite_coordinate.hpp" line="41" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/util/has_non_finite_coordinate.hpp" bodystart="40" bodyend="51"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a1949f8f89274f3b53f6129638f8efc14" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Iterator</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::has_one_element</definition>
        <argsstring>(Iterator first, Iterator beyond)</argsstring>
        <name>has_one_element</name>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>beyond</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/iterators/has_one_element.hpp" line="21" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/iterators/has_one_element.hpp" bodystart="20" bodyend="23"/>
      </memberdef>
      <memberdef kind="function" id="group__interior__rings_1gac5980f18e5c2d400f598299104630c8f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Polygon</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1interior__return__type" kindref="compound">interior_return_type</ref>&lt; Polygon &gt;::type</type>
        <definition>interior_return_type&lt;Polygon&gt;::type boost::geometry::interior_rings</definition>
        <argsstring>(Polygon &amp;polygon)</argsstring>
        <name>interior_rings</name>
        <param>
          <type>Polygon &amp;</type>
          <declname>polygon</declname>
        </param>
        <briefdescription>
<para>Function to get the interior rings of a polygon (non const version) </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>OGC compliance: instead of InteriorRingN </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Polygon</parametername>
</parameternamelist>
<parameterdescription>
<para>polygon type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>polygon</parametername>
</parameternamelist>
<parameterdescription>
<para>the polygon to get the interior rings from </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the interior rings (possibly a reference) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/interior_rings.hpp" line="115" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/interior_rings.hpp" bodystart="114" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="group__interior__rings_1gace65f7563db807c7d2b2ad8bc4f7116b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Polygon</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1interior__return__type" kindref="compound">interior_return_type</ref>&lt; Polygon const  &gt;::type</type>
        <definition>interior_return_type&lt;Polygon const&gt;::type boost::geometry::interior_rings</definition>
        <argsstring>(Polygon const &amp;polygon)</argsstring>
        <name>interior_rings</name>
        <param>
          <type>Polygon const &amp;</type>
          <declname>polygon</declname>
        </param>
        <briefdescription>
<para>Function to get the interior rings of a polygon (const version) </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>OGC compliance: instead of InteriorRingN </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Polygon</parametername>
</parameternamelist>
<parameterdescription>
<para>polygon type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>polygon</parametername>
</parameternamelist>
<parameterdescription>
<para>the polygon to get the interior rings from </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the interior rings (possibly a const reference)</para></simplesect>
 <qbk.distinguish>const version</qbk.distinguish>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/interior_rings.hpp" line="137" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/interior_rings.hpp" bodystart="135" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="group__intersection_1gac78b88e0ea7af3453a626a0e6fc588d7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename GeometryOut</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::intersection</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, GeometryOut &amp;geometry_out)</argsstring>
        <name>intersection</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>GeometryOut &amp;</type>
          <declname>geometry_out</declname>
        </param>
        <briefdescription>
<para>Calculate the intersection of two geometries. </para>        </briefdescription>
        <detaileddescription>
<para>The free function intersection calculates the spatial set theoretic intersection of two geometries. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>GeometryOut</parametername>
</parameternamelist>
<parameterdescription>
<para>Collection of geometries (e.g. std::vector, std::deque, boost::geometry::multi*) of which the value_type fulfills a Point, LineString or Polygon concept, or it is the output geometry (e.g. for a box) </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry_out</parametername>
</parameternamelist>
<parameterdescription>
<para>The output geometry, either a multi_point, multi_polygon, multi_linestring, or a box (for intersection of two boxes)</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/intersection.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/intersection/interface.hpp" line="291" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/intersection/interface.hpp" bodystart="288" bodyend="301"/>
      </memberdef>
      <memberdef kind="function" id="group__intersects_1gacc0c6eb239493fc30afd057d7d56bb11" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::intersects</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>intersects</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Checks if a geometry \1. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>This function can be called for one geometry (self-intersection) and also for two geometries (intersection)</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns true if the geometry \1</para></simplesect>
 <qbk.distinguish>one geometry</qbk.distinguish>   <qbk>[def __one_parameter__]</qbk>   <qbk>[include reference/algorithms/intersects.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/intersects.hpp" line="51" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/intersects.hpp" bodystart="50" bodyend="78"/>
      </memberdef>
      <memberdef kind="function" id="group__intersects_1ga3d8bd9a2b73bb493d66cbcb37426a7be" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::intersects</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>intersects</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Checks if two geometries \1. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns true if two geometries \1</para></simplesect>
 <qbk.distinguish>two geometries</qbk.distinguish>   <qbk>[include reference/algorithms/intersects.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/intersects.hpp" line="95" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/intersects.hpp" bodystart="94" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a4168186cc06493d9628b2ee4cb8abaf0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::is_convex</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>is_convex</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/is_convex.hpp" line="152" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/is_convex.hpp" bodystart="151" bodyend="154"/>
      </memberdef>
      <memberdef kind="function" id="group__is__empty_1gad12981ac44661b053d1e23bbc50be1b5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::is_empty</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>is_empty</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Checks if a geometry \1. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns true if the geometry \1</para></simplesect>
 <qbk>[include reference/algorithms/is_empty.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/is_empty.hpp" line="199" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/is_empty.hpp" bodystart="198" bodyend="201"/>
      </memberdef>
      <memberdef kind="function" id="group__is__simple_1gadb32b5248d8b5ecedadcb05a4c9d7490" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::is_simple</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>is_simple</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Checks if a geometry \1. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns true if the geometry \1</para></simplesect>
 <qbk>[include reference/algorithms/is_simple.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/is_simple/interface.hpp" line="72" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/is_simple/interface.hpp" bodystart="71" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a183da81edb3b8b170da54b4d15b0d923" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename VisitPolicy</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::is_valid</definition>
        <argsstring>(Geometry const &amp;geometry, VisitPolicy &amp;visitor)</argsstring>
        <name>is_valid</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>VisitPolicy &amp;</type>
          <declname>visitor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/is_valid/interface.hpp" line="78" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/is_valid/interface.hpp" bodystart="77" bodyend="80"/>
      </memberdef>
      <memberdef kind="function" id="group__is__valid_1ga356cf864eac8d92b2b841419c945b03f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::is_valid</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>is_valid</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Checks if a geometry \1. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>{is valid (in the OGC sense); furthermore, the following geometries are considered valid: multi-geometries with no elements, linear geometries containing spikes, areal geometries with duplicate (consecutive) points}</para></simplesect>
 <qbk>[include reference/algorithms/is_valid.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/is_valid/interface.hpp" line="98" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/is_valid/interface.hpp" bodystart="97" bodyend="101"/>
      </memberdef>
      <memberdef kind="function" id="group__is__valid_1ga679fa00f8e9cc0a124fcdba608516dfc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::is_valid</definition>
        <argsstring>(Geometry const &amp;geometry, validity_failure_type &amp;failure)</argsstring>
        <name>is_valid</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type><ref refid="group__enum_1ga8f93f0b6945c2ebb9f8a4bb53019a0d8" kindref="member">validity_failure_type</ref> &amp;</type>
          <declname>failure</declname>
        </param>
        <briefdescription>
<para>Checks if a geometry \1. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>failure</parametername>
</parameternamelist>
<parameterdescription>
<para>An enumeration value indicating that the geometry is valid or not, and if not valid indicating the reason why </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>{is valid (in the OGC sense); furthermore, the following geometries are considered valid: multi-geometries with no elements, linear geometries containing spikes, areal geometries with duplicate (consecutive) points}</para></simplesect>
 <qbk.distinguish>with failure value</qbk.distinguish>   <qbk>[include reference/algorithms/is_valid_with_failure.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/is_valid/interface.hpp" line="122" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/is_valid/interface.hpp" bodystart="121" bodyend="127"/>
      </memberdef>
      <memberdef kind="function" id="group__is__valid_1gaf0867398eaeea60e5c004a8615c7c28c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::is_valid</definition>
        <argsstring>(Geometry const &amp;geometry, std::string &amp;message)</argsstring>
        <name>is_valid</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>message</declname>
        </param>
        <briefdescription>
<para>Checks if a geometry \1. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>message</parametername>
</parameternamelist>
<parameterdescription>
<para>A string containing a message stating if the geometry is valid or not, and if not valid a reason why </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>{is valid (in the OGC sense); furthermore, the following geometries are considered valid: multi-geometries with no elements, linear geometries containing spikes, areal geometries with duplicate (consecutive) points}</para></simplesect>
 <qbk.distinguish>with message</qbk.distinguish>   <qbk>[include reference/algorithms/is_valid_with_message.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/is_valid/interface.hpp" line="148" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/is_valid/interface.hpp" bodystart="147" bodyend="154"/>
      </memberdef>
      <memberdef kind="function" id="group__length_1ga38dff36b8deb6a1a8cb0a3d6387af8fc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1default__length__result" kindref="compound">default_length_result</ref>&lt; Geometry &gt;::type</type>
        <definition>default_length_result&lt;Geometry&gt;::type boost::geometry::length</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>length</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the length of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function length calculates the length (the sum of distances between consecutive points) of a geometry. It uses the default strategy, based on the coordinate system of the geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk>[include reference/algorithms/length.qbk]</qbk>   <qbk>[length] [length_output]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/length.hpp" line="253" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/length.hpp" bodystart="252" bodyend="265"/>
      </memberdef>
      <memberdef kind="function" id="group__length_1ga31c0f8fcd943475255e7ab329f2c2771" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1default__length__result" kindref="compound">default_length_result</ref>&lt; Geometry &gt;::type</type>
        <definition>default_length_result&lt;Geometry&gt;::type boost::geometry::length</definition>
        <argsstring>(Geometry const &amp;geometry, Strategy const &amp;strategy)</argsstring>
        <name>length</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Calculates the length of a geometry using the specified strategy. </para>        </briefdescription>
        <detaileddescription>
<para>The free function length calculates the length (the sum of distances between consecutive points) of a geometry using the specified strategy. Reasons to specify a strategy include: use another coordinate system for calculations; construct the strategy beforehand (e.g. with the radius of the Earth); select a strategy when there are more than one available for a calculation. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a distance Strategy Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The strategy which will be used for distance calculations </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk.distinguish>with strategy</qbk.distinguish>   <qbk>[include reference/algorithms/length.qbk]</qbk>   <qbk>[length_with_strategy] [length_with_strategy_output]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/length.hpp" line="285" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/length.hpp" bodystart="284" bodyend="291"/>
      </memberdef>
      <memberdef kind="function" id="group__make_1gab8c2f53b1696956874ed69114cef3a94" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>Geometry</type>
        <definition>Geometry boost::geometry::make</definition>
        <argsstring>(Type const &amp;c1, Type const &amp;c2)</argsstring>
        <name>make</name>
        <param>
          <type>Type const &amp;</type>
          <declname>c1</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c2</declname>
        </param>
        <briefdescription>
<para>Construct a geometry. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>It does not work with array-point types, like int[2] </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>numerical type (int, double, ttmath, ...) to specify the coordinates </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>c1</parametername>
</parameternamelist>
<parameterdescription>
<para>First coordinate (usually x-coordinate) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second coordinate (usually y-coordinate) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The constructed geometry, here: a 2D point</para></simplesect>
 <qbk.distinguish> 2 coordinate values</qbk.distinguish>   <qbk>
[heading Example]
[make_2d_point] [make_2d_point_output]

[heading See also]
\* [link geometry.reference.algorithms.assign.assign_values_3_2_coordinate_values assign]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/make.hpp" line="80" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/make.hpp" bodystart="79" bodyend="91"/>
      </memberdef>
      <memberdef kind="function" id="group__make_1gacab36dbf4f41c6994fb66600303dfe3b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>Geometry</type>
        <definition>Geometry boost::geometry::make</definition>
        <argsstring>(Type const &amp;c1, Type const &amp;c2, Type const &amp;c3)</argsstring>
        <name>make</name>
        <param>
          <type>Type const &amp;</type>
          <declname>c1</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c2</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c3</declname>
        </param>
        <briefdescription>
<para>Construct a geometry. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>numerical type (int, double, ttmath, ...) to specify the coordinates </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>c1</parametername>
</parameternamelist>
<parameterdescription>
<para>First coordinate (usually x-coordinate) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second coordinate (usually y-coordinate) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c3</parametername>
</parameternamelist>
<parameterdescription>
<para>Third coordinate (usually z-coordinate) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The constructed geometry, here: a 3D point</para></simplesect>
 <qbk.distinguish> 3 coordinate values</qbk.distinguish>   <qbk>
[heading Example]
[make_3d_point] [make_3d_point_output]

[heading See also]
\* [link geometry.reference.algorithms.assign.assign_values_4_3_coordinate_values assign]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/make.hpp" line="114" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/make.hpp" bodystart="113" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a84ea9e8996ff4c4a67339c0371042177" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Type</type>
          </param>
        </templateparamlist>
        <type>Geometry</type>
        <definition>Geometry boost::geometry::make</definition>
        <argsstring>(Type const &amp;c1, Type const &amp;c2, Type const &amp;c3, Type const &amp;c4)</argsstring>
        <name>make</name>
        <param>
          <type>Type const &amp;</type>
          <declname>c1</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c2</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c3</declname>
        </param>
        <param>
          <type>Type const &amp;</type>
          <declname>c4</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/make.hpp" line="129" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/make.hpp" bodystart="128" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="group__make_1gabf487e6de983091aa6003f792b1b05df" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>Geometry</type>
        <definition>Geometry boost::geometry::make_inverse</definition>
        <argsstring>()</argsstring>
        <name>make_inverse</name>
        <briefdescription>
<para>Construct a box with inverse infinite coordinates. </para>        </briefdescription>
        <detaileddescription>
<para>The make_inverse function initializes a 2D or 3D box with large coordinates, the min corner is very large, the max corner is very small. This is useful e.g. in combination with the expand function, to determine the bounding box of a series of geometries. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The constructed geometry, here: a box</para></simplesect>
 <qbk>
[heading Example]
[make_inverse] [make_inverse_output]

[heading See also]
\* [link geometry.reference.algorithms.assign.assign_inverse assign_inverse]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/make.hpp" line="165" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/make.hpp" bodystart="164" bodyend="175"/>
      </memberdef>
      <memberdef kind="function" id="group__make_1ga06bcbd65d487f8dad0ebdab1f08aefa6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>Geometry</type>
        <definition>Geometry boost::geometry::make_zero</definition>
        <argsstring>()</argsstring>
        <name>make_zero</name>
        <briefdescription>
<para>Construct a geometry with its coordinates initialized to zero. </para>        </briefdescription>
        <detaileddescription>
<para>The make_zero function initializes a 2D or 3D point or box with coordinates of zero <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The constructed and zero-initialized geometry </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/make.hpp" line="186" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/make.hpp" bodystart="185" bodyend="196"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a873bb153a6c2f37dd97e6a6b997e07ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename RangeOfIntervals</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>boost::range_value&lt; RangeOfIntervals &gt;::type::difference_type</type>
        <definition>boost::range_value&lt;RangeOfIntervals&gt;::type::difference_type boost::geometry::maximum_gap</definition>
        <argsstring>(RangeOfIntervals const &amp;range_of_intervals, T &amp;max_gap_left, T &amp;max_gap_right)</argsstring>
        <name>maximum_gap</name>
        <param>
          <type>RangeOfIntervals const &amp;</type>
          <declname>range_of_intervals</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>max_gap_left</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>max_gap_right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/max_interval_gap.hpp" line="228" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/max_interval_gap.hpp" bodystart="226" bodyend="253"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a5c2390572b9ac45d119a20fcf81b8876" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename RangeOfIntervals</type>
          </param>
        </templateparamlist>
        <type>boost::range_value&lt; RangeOfIntervals &gt;::type::difference_type</type>
        <definition>boost::range_value&lt;RangeOfIntervals&gt;::type::difference_type boost::geometry::maximum_gap</definition>
        <argsstring>(RangeOfIntervals const &amp;range_of_intervals)</argsstring>
        <name>maximum_gap</name>
        <param>
          <type>RangeOfIntervals const &amp;</type>
          <declname>range_of_intervals</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/max_interval_gap.hpp" line="258" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/max_interval_gap.hpp" bodystart="257" bodyend="273"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ac4e8d5a470810b2bfca824af100894d5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>char</type>
        <definition>char boost::geometry::method_char</definition>
        <argsstring>(detail::overlay::method_type const &amp;method)</argsstring>
        <name>method_char</name>
        <param>
          <type>detail::overlay::method_type const &amp;</type>
          <declname>method</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/debug_turn_info.hpp" line="20" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/debug_turn_info.hpp" bodystart="19" bodyend="34"/>
      </memberdef>
      <memberdef kind="function" id="group__arithmetic_1ga3ce5cfd812427c46ac5a319a34fe33b1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point1</type>
          </param>
          <param>
            <type>typename Point2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::multiply_point</definition>
        <argsstring>(Point1 &amp;p1, Point2 const &amp;p2)</argsstring>
        <name>multiply_point</name>
        <param>
          <type>Point1 &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>Point2 const &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
<para>Multiplies a point by another. </para>        </briefdescription>
        <detaileddescription>
<para>The coordinates of the first point will be multiplied by those of the second point. The second point is not modified. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Point2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p1</parametername>
</parameternamelist>
<parameterdescription>
<para>first point </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p2</parametername>
</parameternamelist>
<parameterdescription>
<para>second point </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This is *not* a dot, cross or wedge product. It is a mere field-by-field multiplication. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" line="245" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" bodystart="244" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="group__arithmetic_1gaee0fa23a64414a4781e08965653c0b81" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::multiply_value</definition>
        <argsstring>(Point &amp;p, typename detail::param&lt; Point &gt;::type value)</argsstring>
        <name>multiply_value</name>
        <param>
          <type>Point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>typename detail::param&lt; Point &gt;::type</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Multiplies each coordinate of a point by the same value. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>point </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>value to multiply by </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" line="221" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" bodystart="220" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="group__num__geometries_1gaa10343b9ce9a67688199e3da44a4af5d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>std::size_t</type>
        <definition>std::size_t boost::geometry::num_geometries</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>num_geometries</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the number of geometries of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function num_geometries calculates the number of geometries of a geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk>[include reference/algorithms/num_geometries.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/num_geometries.hpp" line="133" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/num_geometries.hpp" bodystart="132" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="group__num__interior__rings_1gad46daea8aff732fece897726c8a1eaf0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>std::size_t</type>
        <definition>std::size_t boost::geometry::num_interior_rings</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>num_interior_rings</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the number of interior rings of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function num_interior_rings calculates the number of interior rings of a geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk>[include reference/algorithms/num_interior_rings.qbk]</qbk> </para><para><simplesect kind="note"><para>Defined by OGC as &quot;numInteriorRing&quot;. To be consistent with &quot;numPoints&quot; letter &quot;s&quot; is appended </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/num_interior_rings.hpp" line="134" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/num_interior_rings.hpp" bodystart="133" bodyend="136"/>
      </memberdef>
      <memberdef kind="function" id="group__num__points_1ga4e90b249b3cf16e4ef8f486df042aacd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>std::size_t</type>
        <definition>std::size_t boost::geometry::num_points</definition>
        <argsstring>(Geometry const &amp;geometry, bool add_for_open=false)</argsstring>
        <name>num_points</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>add_for_open</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Calculates the number of points of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function num_points calculates the number of points of a geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>add_for_open</parametername>
</parameternamelist>
<parameterdescription>
<para>add one for open geometries (i.e. polygon types which are not closed) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk>[include reference/algorithms/num_points.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/num_points.hpp" line="200" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/num_points.hpp" bodystart="199" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="group__num__segments_1ga6d9d17a4691db85b4dacf8390dd14396" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>std::size_t</type>
        <definition>std::size_t boost::geometry::num_segments</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>num_segments</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the number of segments of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function num_segments calculates the number of segments of a geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk>[include reference/algorithms/num_segments.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/num_segments.hpp" line="196" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/num_segments.hpp" bodystart="195" bodyend="198"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a22abb7a9456a80327b223fbeee1027a6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>char</type>
        <definition>char boost::geometry::operation_char</definition>
        <argsstring>(detail::overlay::operation_type const &amp;operation)</argsstring>
        <name>operation_char</name>
        <param>
          <type>detail::overlay::operation_type const &amp;</type>
          <declname>operation</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/debug_turn_info.hpp" line="37" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/debug_turn_info.hpp" bodystart="36" bodyend="49"/>
      </memberdef>
      <memberdef kind="function" id="group__overlaps_1gacf8e51774babe694d39be3f049be6b39" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::overlaps</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>overlaps</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Checks if two geometries \1. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns true if two geometries \1</para></simplesect>
 <qbk>[include reference/algorithms/overlaps.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/overlaps.hpp" line="186" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/overlaps.hpp" bodystart="185" bodyend="195"/>
      </memberdef>
      <memberdef kind="function" id="group__perimeter_1gabf1b8b04c850eece3b57dcb5d95a0bd9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1default__length__result" kindref="compound">default_length_result</ref>&lt; Geometry &gt;::type</type>
        <definition>default_length_result&lt;Geometry&gt;::type boost::geometry::perimeter</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>perimeter</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the perimeter of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The function perimeter returns the perimeter of a geometry, using the default distance-calculation-strategy <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk>[include reference/algorithms/perimeter.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/perimeter.hpp" line="199" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/perimeter.hpp" bodystart="197" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="group__perimeter_1gad580959ac971e1617c5f8cd08e32c6df" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1default__length__result" kindref="compound">default_length_result</ref>&lt; Geometry &gt;::type</type>
        <definition>default_length_result&lt;Geometry&gt;::type boost::geometry::perimeter</definition>
        <argsstring>(Geometry const &amp;geometry, Strategy const &amp;strategy)</argsstring>
        <name>perimeter</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Calculates the perimeter of a geometry using the specified strategy. </para>        </briefdescription>
        <detaileddescription>
<para>The function perimeter returns the perimeter of a geometry, using specified strategy <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a distance Strategy Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>strategy to be used for distance calculations. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk.distinguish>with strategy</qbk.distinguish>   <qbk>[include reference/algorithms/perimeter.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/perimeter.hpp" line="221" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/perimeter.hpp" bodystart="219" bodyend="224"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1aad3c56fd589d630843eb5d095d2d8bfd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::point_on_border</definition>
        <argsstring>(Point &amp;point, Geometry const &amp;geometry, bool midpoint=false)</argsstring>
        <name>point_on_border</name>
        <param>
          <type>Point &amp;</type>
          <declname>point</declname>
        </param>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>midpoint</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Take point on a border. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry type. This also defines the type of the output point </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>point</parametername>
</parameternamelist>
<parameterdescription>
<para>to assign </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry to take point from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>midpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>boolean flag, true if the point should not be a vertex, but some point in between of two vertices </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>TRUE if successful, else false. It is only false if polygon/line have no points </para></simplesect>
<simplesect kind="note"><para>for a polygon, it is always a point on the exterior ring </para><simplesectsep/><para>for take_midpoint, it is not taken from two consecutive duplicate vertices, (unless there are no other). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/point_on_border.hpp" line="288" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/point_on_border.hpp" bodystart="285" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1abeacf9dce3785e034214937074a1f3cc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Point</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::point_on_surface</definition>
        <argsstring>(Geometry const &amp;geometry, Point &amp;point)</argsstring>
        <name>point_on_surface</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Point &amp;</type>
          <declname>point</declname>
        </param>
        <briefdescription>
<para>Assigns a Point guaranteed to lie on the surface of the Geometry. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry type. This also defines the type of the output point </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Geometry to take point from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>point</parametername>
</parameternamelist>
<parameterdescription>
<para>Point to assign </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/point_on_surface.hpp" line="297" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/point_on_surface.hpp" bodystart="296" bodyend="307"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a03db7eeb2de8c6f84c0ed09c480420c8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1point__iterator" kindref="compound">point_iterator</ref>&lt; Geometry &gt;</type>
        <definition>point_iterator&lt;Geometry&gt; boost::geometry::points_begin</definition>
        <argsstring>(Geometry &amp;geometry)</argsstring>
        <name>points_begin</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/iterators/point_iterator.hpp" line="292" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/iterators/point_iterator.hpp" bodystart="291" bodyend="294"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a6286ce2300b3917da4253f7b2c71dda5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1point__iterator" kindref="compound">point_iterator</ref>&lt; Geometry &gt;</type>
        <definition>point_iterator&lt;Geometry&gt; boost::geometry::points_end</definition>
        <argsstring>(Geometry &amp;geometry)</argsstring>
        <name>points_end</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/iterators/point_iterator.hpp" line="301" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/iterators/point_iterator.hpp" bodystart="300" bodyend="303"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ac56435cec379140e921fb5e8f955d292" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1point__reverse__iterator" kindref="compound">point_reverse_iterator</ref>&lt; Geometry &gt;</type>
        <definition>point_reverse_iterator&lt;Geometry&gt; boost::geometry::points_rbegin</definition>
        <argsstring>(Geometry &amp;geometry)</argsstring>
        <name>points_rbegin</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/iterators/point_reverse_iterator.hpp" line="67" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/iterators/point_reverse_iterator.hpp" bodystart="66" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a5984be872c96e65629dcb6156b293e0e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1point__reverse__iterator" kindref="compound">point_reverse_iterator</ref>&lt; Geometry &gt;</type>
        <definition>point_reverse_iterator&lt;Geometry&gt; boost::geometry::points_rend</definition>
        <argsstring>(Geometry &amp;geometry)</argsstring>
        <name>points_rend</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/iterators/point_reverse_iterator.hpp" line="79" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/iterators/point_reverse_iterator.hpp" bodystart="78" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ac434096877035540e71a7ad08bfe3a4b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Section</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1ring__return__type" kindref="compound">ring_return_type</ref>&lt; Geometry const  &gt;::type</type>
        <definition>ring_return_type&lt;Geometry const&gt;::type boost::geometry::range_by_section</definition>
        <argsstring>(Geometry const &amp;geometry, Section const &amp;section)</argsstring>
        <name>range_by_section</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Section const &amp;</type>
          <declname>section</declname>
        </param>
        <briefdescription>
<para>Get full ring (exterior, one of interiors, one from multi) indicated by the specified section. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Section</parametername>
</parameternamelist>
<parameterdescription>
<para>type of section to get from </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry to take section of </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>section</parametername>
</parameternamelist>
<parameterdescription>
<para>structure with section </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/sections/range_by_section.hpp" line="179" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/sections/range_by_section.hpp" bodystart="178" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="group__wkt_1ga972597e2ff21d50a85b19de43ed6cd76" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::read_wkt</definition>
        <argsstring>(std::string const &amp;wkt, Geometry &amp;geometry)</argsstring>
        <name>read_wkt</name>
        <param>
          <type>std::string const &amp;</type>
          <declname>wkt</declname>
        </param>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Parses OGC Well-Known Text (<ref refid="_w_k_t" kindref="compound">WKT (Well-Known Text)</ref>) into a geometry (any geometry) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>wkt</parametername>
</parameternamelist>
<parameterdescription>
<para>string containing <ref refid="_w_k_t" kindref="compound">WKT (Well-Known Text)</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept output geometry</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/io/read_wkt.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/io/wkt/read.hpp" line="896" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/io/wkt/read.hpp" bodystart="895" bodyend="899"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ae65cfdfcb0e698fba1370e9347960c66" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::recalculate</definition>
        <argsstring>(Geometry1 &amp;geometry1, Geometry2 const &amp;geometry2, Strategy const &amp;strategy)</argsstring>
        <name>recalculate</name>
        <param>
          <type>Geometry1 &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/recalculate.hpp" line="221" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/recalculate.hpp" bodystart="220" bodyend="228"/>
      </memberdef>
      <memberdef kind="function" id="group__relate_1gabe671b5a5c5cd468621a4605ca7e57c5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename Mask</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::relate</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Mask const &amp;mask)</argsstring>
        <name>relate</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>Mask const &amp;</type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Checks relation between a pair of geometries defined by a mask. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Mask</parametername>
</parameternamelist>
<parameterdescription>
<para>An intersection model Mask type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>An intersection model mask object. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if the relation is compatible with the mask, false otherwise.</para></simplesect>
 <qbk>[include reference/algorithms/relate.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/relate/interface.hpp" line="338" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/relate/interface.hpp" bodystart="335" bodyend="344"/>
      </memberdef>
      <memberdef kind="function" id="group__relation_1ga6a43ab4b83f66fb53c0dfe34981a6f4b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1de9im_1_1matrix" kindref="compound">de9im::matrix</ref></type>
        <definition>de9im::matrix boost::geometry::relation</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>relation</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Calculates the relation between a pair of geometries as defined in DE-9IM. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The DE-9IM matrix expressing the relation between geometries.</para></simplesect>
 <qbk>[include reference/algorithms/relation.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/relation/interface.hpp" line="175" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/relation/interface.hpp" bodystart="173" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ab9f805dce11277676f1de471ee87a14b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::remove_spikes</definition>
        <argsstring>(Geometry &amp;geometry)</argsstring>
        <name>remove_spikes</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>the geometry to make remove_spikes </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/remove_spikes.hpp" line="277" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/remove_spikes.hpp" bodystart="276" bodyend="279"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer_1ga8f897ad6face43210c41f8afedf526bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Output</type>
          </param>
          <param>
            <type>typename Input</type>
          </param>
          <param>
            <type>typename Distance</type>
          </param>
        </templateparamlist>
        <type>Output</type>
        <definition>Output boost::geometry::return_buffer</definition>
        <argsstring>(Input const &amp;geometry, Distance const &amp;distance, Distance const &amp;chord_length=-1)</argsstring>
        <name>return_buffer</name>
        <param>
          <type>Input const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Distance const &amp;</type>
          <declname>distance</declname>
        </param>
        <param>
          <type>Distance const &amp;</type>
          <declname>chord_length</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Calculates the buffer of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function return_buffer calculates the buffer (a polygon being the spatial point set collection within a specified maximum distance from a geometry) of a geometry. This version with the return_ prefix returns the buffer, and a template parameter must therefore be specified in the call.. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Input</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Output</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Distance</parametername>
</parameternamelist>
<parameterdescription>
<para>numerical type (int, double, ttmath, ...) </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>distance</parametername>
</parameternamelist>
<parameterdescription>
<para>The distance to be used for the buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>chord_length</parametername>
</parameternamelist>
<parameterdescription>
<para>(optional) The length of the chord&apos;s in the generated arcs around points or bends (RESERVED, NOT YET USED) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/buffer.hpp" line="206" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/buffer.hpp" bodystart="205" bodyend="215"/>
      </memberdef>
      <memberdef kind="function" id="group__centroid_1ga607a6c57dac30f7b2826f29f937a7fe4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>Point</type>
        <definition>Point boost::geometry::return_centroid</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>return_centroid</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the centroid of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function centroid calculates the geometric center (or: center of mass) of a geometry. This version with the return_ prefix returns the centroid, and a template parameter must therefore be specified in the call.. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk>[include reference/algorithms/centroid.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/centroid.hpp" line="647" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/centroid.hpp" bodystart="646" bodyend="651"/>
      </memberdef>
      <memberdef kind="function" id="group__centroid_1ga34a41b95d0bcc2ecb14e3093623386d3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type>Point</type>
        <definition>Point boost::geometry::return_centroid</definition>
        <argsstring>(Geometry const &amp;geometry, Strategy const &amp;strategy)</argsstring>
        <name>return_centroid</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Calculates the centroid of a geometry using the specified strategy. </para>        </briefdescription>
        <detaileddescription>
<para>The free function centroid calculates the geometric center (or: center of mass) of a geometry. This version with the return_ prefix returns the centroid, and a template parameter must therefore be specified in the call.. Reasons to specify a strategy include: use another coordinate system for calculations; construct the strategy beforehand (e.g. with the radius of the Earth); select a strategy when there are more than one available for a calculation. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a centroid Strategy Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The strategy which will be used for centroid calculations </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk.distinguish>with strategy</qbk.distinguish>   <qbk>[include reference/algorithms/centroid.qbk]</qbk>   <qbk>[include reference/algorithms/centroid_strategies.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/centroid.hpp" line="670" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/centroid.hpp" bodystart="669" bodyend="674"/>
      </memberdef>
      <memberdef kind="function" id="group__envelope_1ga4afb45ba6fb41e732a008a9e1e104347" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Box</type>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>Box</type>
        <definition>Box boost::geometry::return_envelope</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>return_envelope</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the envelope of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function return_envelope calculates the envelope (also known as axis aligned bounding box, aabb, or minimum bounding rectangle, mbr) of a geometry. This version with the return_ prefix returns the envelope, and a template parameter must therefore be specified in the call. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Box</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Box Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The calculated \1</para></simplesect>
 <qbk>[include reference/algorithms/envelope.qbk]</qbk>   <qbk>
[heading Example]
[return_envelope] [return_envelope_output]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/envelope/interface.hpp" line="118" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/envelope/interface.hpp" bodystart="117" bodyend="122"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a1922563e36f64c8dd031257ac58d4df3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1geometry_1_1point__type" kindref="compound">geometry::point_type</ref>&lt; Geometry &gt;::type</type>
        <definition>geometry::point_type&lt;Geometry&gt;::type boost::geometry::return_point_on_surface</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>return_point_on_surface</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Returns point guaranteed to lie on the surface of the Geometry. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry type. This also defines the type of the output point </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Geometry to take point from </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The Point guaranteed to lie on the surface of the Geometry </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/point_on_surface.hpp" line="318" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/point_on_surface.hpp" bodystart="317" bodyend="322"/>
      </memberdef>
      <memberdef kind="function" id="group__reverse_1ga9d0e06498236cee4517168b4cb231998" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::reverse</definition>
        <argsstring>(Geometry &amp;geometry)</argsstring>
        <name>reverse</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Reverses the points within a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>Generic function to reverse a geometry. It resembles the std::reverse functionality, but it takes the geometry type into account. Only for a ring or for a linestring it is the same as the std::reverse.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which will be reversed</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/reverse.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/reverse.hpp" line="179" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/reverse.hpp" bodystart="178" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ab8cd77a55d7479badca9ddb3379bce06" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>Reverse</declname>
            <defname>Reverse</defname>
          </param>
          <param>
            <type>typename DimensionVector</type>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Sections</type>
          </param>
          <param>
            <type>typename RobustPolicy</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::sectionalize</definition>
        <argsstring>(Geometry const &amp;geometry, RobustPolicy const &amp;robust_policy, Sections &amp;sections, int source_index=0, std::size_t max_count=10)</argsstring>
        <name>sectionalize</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>RobustPolicy const &amp;</type>
          <declname>robust_policy</declname>
        </param>
        <param>
          <type>Sections &amp;</type>
          <declname>sections</declname>
        </param>
        <param>
          <type>int</type>
          <declname>source_index</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>max_count</declname>
          <defval>10</defval>
        </param>
        <briefdescription>
<para>Split a geometry into monotonic sections. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>type of geometry to check </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Sections</parametername>
</parameternamelist>
<parameterdescription>
<para>type of sections to create </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry to create sections from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>robust_policy</parametername>
</parameternamelist>
<parameterdescription>
<para>policy to handle robustness issues </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sections</parametername>
</parameternamelist>
<parameterdescription>
<para>structure with sections </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>source_index</parametername>
</parameternamelist>
<parameterdescription>
<para>index to assign to the ring_identifiers </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_count</parametername>
</parameternamelist>
<parameterdescription>
<para>maximal number of points per section (defaults to 10, this seems to give the fastest results) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/sections/sectionalize.hpp" line="771" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/sections/sectionalize.hpp" bodystart="766" bodyend="808"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1af53a7cce3633298bd5fe47d6ce71b4ce" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1segment__iterator" kindref="compound">segment_iterator</ref>&lt; Geometry const  &gt;</type>
        <definition>segment_iterator&lt;Geometry const&gt; boost::geometry::segments_begin</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>segments_begin</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/iterators/segment_iterator.hpp" line="337" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/iterators/segment_iterator.hpp" bodystart="336" bodyend="339"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a947086a59a0e75d7918bda2e292d1a63" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1segment__iterator" kindref="compound">segment_iterator</ref>&lt; Geometry const  &gt;</type>
        <definition>segment_iterator&lt;Geometry const&gt; boost::geometry::segments_end</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>segments_end</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/iterators/segment_iterator.hpp" line="346" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/iterators/segment_iterator.hpp" bodystart="345" bodyend="348"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a7a2c5b63fa7d9e10d2c87650b05ade53" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename AssignPolicy</type>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename RobustPolicy</type>
          </param>
          <param>
            <type>typename Turns</type>
          </param>
          <param>
            <type>typename InterruptPolicy</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::self_turns</definition>
        <argsstring>(Geometry const &amp;geometry, RobustPolicy const &amp;robust_policy, Turns &amp;turns, InterruptPolicy &amp;interrupt_policy)</argsstring>
        <name>self_turns</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>RobustPolicy const &amp;</type>
          <declname>robust_policy</declname>
        </param>
        <param>
          <type>Turns &amp;</type>
          <declname>turns</declname>
        </param>
        <param>
          <type>InterruptPolicy &amp;</type>
          <declname>interrupt_policy</declname>
        </param>
        <briefdescription>
<para>Calculate self intersections of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Turns</parametername>
</parameternamelist>
<parameterdescription>
<para>type of intersection container (e.g. vector of &quot;intersection/turn point&quot;&apos;s) </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>robust_policy</parametername>
</parameternamelist>
<parameterdescription>
<para>policy to handle robustness issues </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>turns</parametername>
</parameternamelist>
<parameterdescription>
<para>container which will contain intersection points </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>interrupt_policy</parametername>
</parameternamelist>
<parameterdescription>
<para>policy determining if process is stopped when intersection is found </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/self_turn_points.hpp" line="278" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/self_turn_points.hpp" bodystart="275" bodyend="289"/>
      </memberdef>
      <memberdef kind="function" id="group__set_1ga547b9e2d42e58aab04949d056b795702" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>Dimension</declname>
            <defname>Dimension</defname>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::set</definition>
        <argsstring>(Geometry &amp;geometry, typename coordinate_type&lt; Geometry &gt;::type const &amp;value)</argsstring>
        <name>set</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>typename <ref refid="structboost_1_1geometry_1_1coordinate__type" kindref="compound">coordinate_type</ref>&lt; Geometry &gt;::type const &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Set coordinate value of a geometry (usually a point) </para>        </briefdescription>
        <detaileddescription>
<para>The free functions [*get] and [*set] are two of the most important functions of Boost.Geometry, both within the library, as also for the library user. With these two functions you normally get and set coordinate values from and for a point, box, segment or sphere. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Dimension</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension, this template parameter is required. Should contain \[0 .. n-1\] for an n-dimensional geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept (usually a Point Concept) </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry to assign coordinate to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept (usually a point) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The coordinate value to set</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/core/set_point.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" line="309" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" bodystart="303" bodyend="322"/>
      </memberdef>
      <memberdef kind="function" id="group__set_1gab344165e39efdf322c11f5b3205cb302" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>Index</declname>
            <defname>Index</defname>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>Dimension</declname>
            <defname>Dimension</defname>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::set</definition>
        <argsstring>(Geometry &amp;geometry, typename coordinate_type&lt; Geometry &gt;::type const &amp;value)</argsstring>
        <name>set</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>typename <ref refid="structboost_1_1geometry_1_1coordinate__type" kindref="compound">coordinate_type</ref>&lt; Geometry &gt;::type const &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>set coordinate value of a Box / Segment </para>        </briefdescription>
        <detaileddescription>
<para>The free functions [*get] and [*set] are two of the most important functions of Boost.Geometry, both within the library, as also for the library user. With these two functions you normally get and set coordinate values from and for a point, box, segment or sphere. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>Index, this template parameter is required. For a Box: either min_corner or max_corner. For a Segment: either 0 or 1 for first or last point. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Dimension</parametername>
</parameternamelist>
<parameterdescription>
<para>Dimension, this template parameter is required. Should contain \[0 .. n-1\] for an n-dimensional geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Box Concept or a Segment Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry to assign coordinate to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The coordinate value to set</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish>with index</qbk.distinguish>   <qbk>[include reference/core/set_box.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" line="381" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" bodystart="375" bodyend="395"/>
      </memberdef>
      <memberdef kind="function" id="group__set_1ga78f2e71135a76ccad3e37afab58b0f70" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>Dimension</declname>
            <defname>Dimension</defname>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::set_from_radian</definition>
        <argsstring>(Geometry &amp;geometry, typename fp_coordinate_type&lt; Geometry &gt;::type const &amp;radians)</argsstring>
        <name>set_from_radian</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>typename <ref refid="structboost_1_1geometry_1_1fp__coordinate__type" kindref="compound">fp_coordinate_type</ref>&lt; Geometry &gt;::type const &amp;</type>
          <declname>radians</declname>
        </param>
        <briefdescription>
<para>set coordinate value (in radian) to a point </para>        </briefdescription>
        <detaileddescription>
<para>Coordinate value will be set correctly, if coordinate system of point is in Degree, Radian value will be converted to Degree</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Dimension</parametername>
</parameternamelist>
<parameterdescription>
<para>dimension </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>geometry to assign coordinate to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>radians</parametername>
</parameternamelist>
<parameterdescription>
<para>coordinate value to assign </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Only applicable to coordinate systems templatized by units, e.g. spherical or geographic coordinate systems </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/radian_access.hpp" line="149" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/radian_access.hpp" bodystart="147" bodyend="152"/>
      </memberdef>
      <memberdef kind="function" id="group__access_1ga6c403657f606b2a4d3f64d6e4ae74437" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::set_radius</definition>
        <argsstring>(Geometry &amp;geometry, typename radius_type&lt; Geometry &gt;::type const &amp;radius)</argsstring>
        <name>set_radius</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>typename <ref refid="structboost_1_1geometry_1_1radius__type" kindref="compound">radius_type</ref>&lt; Geometry &gt;::type const &amp;</type>
          <declname>radius</declname>
        </param>
        <briefdescription>
<para>Function to set the radius of a circle / sphere / ellipse / etc. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>index of the axis </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>the geometry to change </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>radius</parametername>
</parameternamelist>
<parameterdescription>
<para>the radius to set </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/core/radius.hpp" line="147" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/core/radius.hpp" bodystart="145" bodyend="155"/>
      </memberdef>
      <memberdef kind="function" id="group__simplify_1ga8f1c13c0fe844ffdaa6196ce3854849f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Distance</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::simplify</definition>
        <argsstring>(Geometry const &amp;geometry, Geometry &amp;out, Distance const &amp;max_distance, Strategy const &amp;strategy)</argsstring>
        <name>simplify</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Geometry &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>Distance const &amp;</type>
          <declname>max_distance</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Simplify a geometry using a specified strategy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Distance</parametername>
</parameternamelist>
<parameterdescription>
<para>A numerical distance measure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>A type fulfilling a SimplifyStrategy concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>A strategy to calculate simplification </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>input geometry, to be simplified </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>output geometry, simplified version of the input geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_distance</parametername>
</parameternamelist>
<parameterdescription>
<para>distance (in units of input coordinates) of a vertex to other segments to be removed </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>simplify strategy to be used for simplification, might include point-distance strategy</para></parameterdescription>
</parameteritem>
</parameterlist>
<image type="html" name="svg_simplify_country.png">The image below presents the simplified country</image>
  <qbk.distinguish>with strategy</qbk.distinguish>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/simplify.hpp" line="463" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/simplify.hpp" bodystart="461" bodyend="469"/>
      </memberdef>
      <memberdef kind="function" id="group__simplify_1ga7f1ed83b2a595dc644205374eddf0057" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename Distance</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::simplify</definition>
        <argsstring>(Geometry const &amp;geometry, Geometry &amp;out, Distance const &amp;max_distance)</argsstring>
        <name>simplify</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>Geometry &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>Distance const &amp;</type>
          <declname>max_distance</declname>
        </param>
        <briefdescription>
<para>Simplify a geometry. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Distance</parametername>
</parameternamelist>
<parameterdescription>
<para>numerical type (int, double, ttmath, ...) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This version of simplify simplifies a geometry using the default strategy (Douglas Peucker), </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>input geometry, to be simplified </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>output geometry, simplified version of the input geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_distance</parametername>
</parameternamelist>
<parameterdescription>
<para>distance (in units of input coordinates) of a vertex to other segments to be removed</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/simplify.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/simplify.hpp" line="491" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/simplify.hpp" bodystart="489" bodyend="495"/>
      </memberdef>
      <memberdef kind="function" id="group__arithmetic_1ga2aaca98906e1978d00ea55b40a1a39ea" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point1</type>
          </param>
          <param>
            <type>typename Point2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::subtract_point</definition>
        <argsstring>(Point1 &amp;p1, Point2 const &amp;p2)</argsstring>
        <name>subtract_point</name>
        <param>
          <type>Point1 &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>Point2 const &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
<para>Subtracts a point to another. </para>        </briefdescription>
        <detaileddescription>
<para>The coordinates of the second point will be subtracted to those of the first point. The second point is not modified. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Point2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p1</parametername>
</parameternamelist>
<parameterdescription>
<para>first point </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p2</parametername>
</parameternamelist>
<parameterdescription>
<para>second point </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" line="204" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" bodystart="203" bodyend="209"/>
      </memberdef>
      <memberdef kind="function" id="group__arithmetic_1gaf0ffb395ff5f6359d8da055decddd385" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Point</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::subtract_value</definition>
        <argsstring>(Point &amp;p, typename detail::param&lt; Point &gt;::type value)</argsstring>
        <name>subtract_value</name>
        <param>
          <type>Point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>typename detail::param&lt; Point &gt;::type</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Subtracts the same value to each coordinate of a point. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Point Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>point </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>value to subtract </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" line="181" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/arithmetic/arithmetic.hpp" bodystart="180" bodyend="190"/>
      </memberdef>
      <memberdef kind="function" id="group__svg_1gaf2dffff92f8bbb5ddb246560b324988a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1svg__manipulator" kindref="compound">svg_manipulator</ref>&lt; Geometry &gt;</type>
        <definition>svg_manipulator&lt;Geometry&gt; boost::geometry::svg</definition>
        <argsstring>(Geometry const &amp;geometry, std::string const &amp;style, int size=-1)</argsstring>
        <name>svg</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>style</declname>
        </param>
        <param>
          <type>int</type>
          <declname>size</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Manipulator to stream geometries as SVG. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>style</parametername>
</parameternamelist>
<parameterdescription>
<para>String containing verbatim SVG style information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional size (used for SVG points) in SVG pixels. For linestrings, specify linewidth in the SVG style information </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/io/svg/write_svg.hpp" line="297" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/io/svg/write_svg.hpp" bodystart="296" bodyend="301"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ad17275bdcc3409e08b6efeac43ceed98" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
          <param>
            <type>typename TransformStrategy</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::svg_map</definition>
        <argsstring>(std::ostream &amp;stream, std::string const &amp;style, int size, Geometry const &amp;geometry, TransformStrategy const &amp;strategy)</argsstring>
        <name>svg_map</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>style</declname>
        </param>
        <param>
          <type>int</type>
          <declname>size</declname>
        </param>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <param>
          <type>TransformStrategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/io/svg/svg_mapper.hpp" line="202" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/io/svg/svg_mapper.hpp" bodystart="199" bodyend="212"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a85ba136cb1836c9107108597ad3ae909" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Range</type>
          </param>
          <param>
            <type>typename PriorityQueue</type>
          </param>
          <param>
            <type>typename InitializationVisitor</type>
          </param>
          <param>
            <type>typename EventVisitor</type>
          </param>
          <param>
            <type>typename InterruptPolicy</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::sweep</definition>
        <argsstring>(Range const &amp;range, PriorityQueue &amp;queue, InitializationVisitor &amp;initialization_visitor, EventVisitor &amp;event_visitor, InterruptPolicy const &amp;interrupt_policy)</argsstring>
        <name>sweep</name>
        <param>
          <type>Range const &amp;</type>
          <declname>range</declname>
        </param>
        <param>
          <type>PriorityQueue &amp;</type>
          <declname>queue</declname>
        </param>
        <param>
          <type>InitializationVisitor &amp;</type>
          <declname>initialization_visitor</declname>
        </param>
        <param>
          <type>EventVisitor &amp;</type>
          <declname>event_visitor</declname>
        </param>
        <param>
          <type>InterruptPolicy const &amp;</type>
          <declname>interrupt_policy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/sweep.hpp" line="50" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/sweep.hpp" bodystart="46" bodyend="66"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1a0d1ffc8d5508af3bb4fa044b38ea282e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Range</type>
          </param>
          <param>
            <type>typename PriorityQueue</type>
          </param>
          <param>
            <type>typename InitializationVisitor</type>
          </param>
          <param>
            <type>typename EventVisitor</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::sweep</definition>
        <argsstring>(Range const &amp;range, PriorityQueue &amp;queue, InitializationVisitor &amp;initialization_visitor, EventVisitor &amp;event_visitor)</argsstring>
        <name>sweep</name>
        <param>
          <type>Range const &amp;</type>
          <declname>range</declname>
        </param>
        <param>
          <type>PriorityQueue &amp;</type>
          <declname>queue</declname>
        </param>
        <param>
          <type>InitializationVisitor &amp;</type>
          <declname>initialization_visitor</declname>
        </param>
        <param>
          <type>EventVisitor &amp;</type>
          <declname>event_visitor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/sweep.hpp" line="79" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/sweep.hpp" bodystart="76" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="group__sym__difference_1gab9e6f8b5e8d14cd699f54e79f60b1871" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename Collection</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::sym_difference</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Collection &amp;output_collection)</argsstring>
        <name>sym_difference</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>Collection &amp;</type>
          <declname>output_collection</declname>
        </param>
        <briefdescription>
<para>Calculate the symmetric difference of two geometries. </para>        </briefdescription>
        <detaileddescription>
<para>The free function symmetric difference calculates the spatial set theoretic symmetric difference (XOR) of two geometries. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Collection</parametername>
</parameternamelist>
<parameterdescription>
<para>output collection, either a multi-geometry, or a std::vector&lt;Geometry&gt; / std::deque&lt;Geometry&gt; etc </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output_collection</parametername>
</parameternamelist>
<parameterdescription>
<para>the output collection</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/sym_difference.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/sym_difference.hpp" line="317" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/sym_difference.hpp" bodystart="315" bodyend="336"/>
      </memberdef>
      <memberdef kind="function" id="group__touches_1ga34c4c58f9757ecd08dbd413701a59fac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::touches</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>touches</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Checks if a geometry \1. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>This function can be called for one geometry (self-tangency) and also for two geometries (touch)</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns true if the geometry \1</para></simplesect>
 <qbk.distinguish>one geometry</qbk.distinguish>   <qbk>[def __one_parameter__]</qbk>   <qbk>[include reference/algorithms/touches.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/touches.hpp" line="561" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/touches.hpp" bodystart="560" bodyend="563"/>
      </memberdef>
      <memberdef kind="function" id="group__touches_1gabbb053b4c78edc40a6c37f1f0f71ddbe" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::touches</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>touches</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Checks if two geometries \1. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns true if two geometries \1</para></simplesect>
 <qbk.distinguish>two geometries</qbk.distinguish>   <qbk>[include reference/algorithms/touches.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/touches.hpp" line="580" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/touches.hpp" bodystart="579" bodyend="582"/>
      </memberdef>
      <memberdef kind="function" id="group__transform_1ga396a7207dc2e9dbc3c15c1c174e0e5a0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::transform</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 &amp;geometry2, Strategy const &amp;strategy)</argsstring>
        <name>transform</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Transforms from one geometry to another geometry using the specified strategy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>strategy </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>The strategy to be used for transformation </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the transformation could be done</para></simplesect>
 <qbk.distinguish>with strategy</qbk.distinguish> </para><para> <qbk>[include reference/algorithms/transform_with_strategy.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/transform.hpp" line="453" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/transform.hpp" bodystart="451" bodyend="456"/>
      </memberdef>
      <memberdef kind="function" id="group__transform_1ga5f8dab51e6972613f20878beb34feb36" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::transform</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 &amp;geometry2)</argsstring>
        <name>transform</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Transforms from one geometry to another geometry using a strategy. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the transformation could be done</para></simplesect>
 <qbk>[include reference/algorithms/transform.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/transform.hpp" line="472" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/transform.hpp" bodystart="471" bodyend="474"/>
      </memberdef>
      <memberdef kind="function" id="group__union_1gaa300b8994725c85cc71b304713a75501" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename Collection</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::union_</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Collection &amp;output_collection)</argsstring>
        <name>union_</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>Collection &amp;</type>
          <declname>output_collection</declname>
        </param>
        <briefdescription>
<para>Combines two geometries which each other. </para>        </briefdescription>
        <detaileddescription>
<para>The free function union calculates the spatial set theoretic union of two geometries. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Collection</parametername>
</parameternamelist>
<parameterdescription>
<para>output collection, either a multi-geometry, or a std::vector&lt;Geometry&gt; / std::deque&lt;Geometry&gt; etc </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output_collection</parametername>
</parameternamelist>
<parameterdescription>
<para>the output collection </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Called union_ because union is a reserved word.</para></simplesect>
 <qbk>[include reference/algorithms/union.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/union.hpp" line="266" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/union.hpp" bodystart="263" bodyend="275"/>
      </memberdef>
      <memberdef kind="function" id="group__unique_1ga122eb540d5b35cf6b3c8c28f0c7fcc45" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void boost::geometry::unique</definition>
        <argsstring>(Geometry &amp;geometry)</argsstring>
        <name>unique</name>
        <param>
          <type>Geometry &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Calculates the minimal set of a geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function unique calculates the minimal set (where duplicate consecutive points are removed) of a geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which will be made unique</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/algorithms/unique.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/unique.hpp" line="168" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/unique.hpp" bodystart="167" bodyend="179"/>
      </memberdef>
      <memberdef kind="function" id="namespaceboost_1_1geometry_1ae1082d5256a30c0e6fe7ab657486f444" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>char</type>
        <definition>char boost::geometry::visited_char</definition>
        <argsstring>(detail::overlay::visit_info const &amp;v)</argsstring>
        <name>visited_char</name>
        <param>
          <type>detail::overlay::visit_info const &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/debug_turn_info.hpp" line="52" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/detail/overlay/debug_turn_info.hpp" bodystart="51" bodyend="59"/>
      </memberdef>
      <memberdef kind="function" id="group__within_1gaf8f597c0a7352f0a6808944db2a549b7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::within</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2)</argsstring>
        <name>within</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <briefdescription>
<para>Checks if the first geometry is completely inside the second geometry. </para>        </briefdescription>
        <detaileddescription>
<para>The free function within checks if the first geometry is completely inside the second geometry. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which might be within the second geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which might contain the first geometry </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if geometry1 is completely contained within geometry2, else false </para></simplesect>
<simplesect kind="note"><para>The default strategy is used for within detection</para></simplesect>
 <qbk>[include reference/algorithms/within.qbk]</qbk> </para><para> <qbk>
[heading Example]
[within]
[within_output]
</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/within.hpp" line="485" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/within.hpp" bodystart="484" bodyend="491"/>
      </memberdef>
      <memberdef kind="function" id="group__within_1ga4e277994f726a9e5076429e99a6cd3b8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry1</type>
          </param>
          <param>
            <type>typename Geometry2</type>
          </param>
          <param>
            <type>typename Strategy</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool boost::geometry::within</definition>
        <argsstring>(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, Strategy const &amp;strategy)</argsstring>
        <name>within</name>
        <param>
          <type>Geometry1 const &amp;</type>
          <declname>geometry1</declname>
        </param>
        <param>
          <type>Geometry2 const &amp;</type>
          <declname>geometry2</declname>
        </param>
        <param>
          <type>Strategy const &amp;</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Checks if the first geometry is completely inside the second geometry using the specified strategy. </para>        </briefdescription>
        <detaileddescription>
<para>The free function within checks if the first geometry is completely inside the second geometry, using the specified strategy. Reasons to specify a strategy include: use another coordinate system for calculations; construct the strategy beforehand (e.g. with the radius of the Earth); select a strategy when there are more than one available for a calculation. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry1</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which might be within the second geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geometry2</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept which might contain the first geometry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strategy</parametername>
</parameternamelist>
<parameterdescription>
<para>strategy to be used </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if geometry1 is completely contained within geometry2, else false</para></simplesect>
 <qbk.distinguish>with strategy</qbk.distinguish>   <qbk>[include reference/algorithms/within.qbk]</qbk>   <qbk>
[heading Available Strategies]
\* [link geometry.reference.strategies.strategy_within_winding Winding (coordinate system agnostic)]
\* [link geometry.reference.strategies.strategy_within_franklin Franklin (cartesian)]
\* [link geometry.reference.strategies.strategy_within_crossings_multiply Crossings Multiply (cartesian)]

[heading Example]
[within_strategy]
[within_strategy_output]

</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/algorithms/within.hpp" line="522" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/algorithms/within.hpp" bodystart="520" bodyend="528"/>
      </memberdef>
      <memberdef kind="function" id="group__wkt_1ga32f68b63c9c15ed3c31f386001c4ec29" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Geometry</type>
          </param>
        </templateparamlist>
        <type><ref refid="classboost_1_1geometry_1_1wkt__manipulator" kindref="compound">wkt_manipulator</ref>&lt; Geometry &gt;</type>
        <definition>wkt_manipulator&lt;Geometry&gt; boost::geometry::wkt</definition>
        <argsstring>(Geometry const &amp;geometry)</argsstring>
        <name>wkt</name>
        <param>
          <type>Geometry const &amp;</type>
          <declname>geometry</declname>
        </param>
        <briefdescription>
<para>Main WKT-streaming function. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type fulfilling a Geometry Concept </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>geometry</parametername>
</parameternamelist>
<parameterdescription>
<para>A model of the specified concept</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[include reference/io/wkt.qbk]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/boostorg/boost/boost/geometry/io/wkt/write.hpp" line="503" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/io/wkt/write.hpp" bodystart="502" bodyend="507"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/travis/build/boostorg/boost/boost/geometry/core/access.hpp" line="32"/>
  </compounddef>
</doxygen>
