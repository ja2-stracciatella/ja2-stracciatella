<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="robustness" kind="page">
    <compoundname>robustness</compoundname>
    <title>Boost.Geometry and Robustness</title>
    <detaileddescription>
<sect1 id="robustness_1robustness_par1">
<title>Introduction</title>
<para>Floating point coordinates have limited precision. Geometry algorithms have to take this into account.</para><para>If differences between points are very small, it may lead to false result of a mathematical calculation performed on such points, what in turn, may cause algorithm result as inadequate to actual geometric situation. For example, a point which is located left from a segment, but <bold>very</bold> close to it, can be reported on that segment or right from it. Also if differences are a little larger, artifacts can be shown in geometric algorithms.</para><para>See for more backgrounds e.g.:</para><para><itemizedlist>
<listitem><para><ulink url="http://www.mpi-inf.mpg.de/~kettner/pub/nonrobust_cgta_06.pdf">Classroom Examples of Robustness Problems in Geometric Computations</ulink></para></listitem><listitem><para><ulink url="http://groups.csail.mit.edu/graphics/classes/6.838/S98/meetings/m12/pred/m12.html">Robust Predicates and Degeneracy</ulink></para></listitem></itemizedlist>
</para><para>Boost.Geometry is aware of these issues and provides several approaches to minimize the problems, or avoid them completely using</para><para><itemizedlist>
<listitem><para><ulink url="http://en.wikipedia.org/wiki/GNU_Multi-Precision_Library">GMP</ulink></para></listitem><listitem><para><ulink url="http://en.wikipedia.org/wiki/Class_Library_for_Numbers">CLN</ulink></para></listitem></itemizedlist>
</para></sect1>
<sect1 id="robustness_1robustness_par2">
<title>Example</title>
<para>An example. Consider the elongated triangle and box below.</para><para><image type="html" name="robust_triangle_box.png"></image>
</para><para>The left edge of the triangle has a length of about the precision of the floating point grid. It is not possible to do this intersection correctly, using floating point. No library (using floating point) can do that, by nature of float point numerical representation. It is not possible to express the four different coordinates in the resulting intersected polygon. Theoretically distinct points will be assigned to the very same location.</para><para>Also if the left edge is longer than that, or using double coordinates, those effects will be there. And of course not only in triangles, but any spiky feature in a polygon can result in non representable coordinates or zero-length edges.</para></sect1>
<sect1 id="robustness_1robustness_par3">
<title>Coordinate types</title>
<para>All geometry types provided by Boost.Geometry, and types by the user, do have a coordinate type. For example</para><para><programlisting><codeline><highlight class="normal">boost::geometry::point_xy&lt;float&gt;<sp/>p1;</highlight></codeline>
<codeline><highlight class="normal">boost::geometry::point_xy&lt;double&gt;<sp/>p2;</highlight></codeline>
<codeline><highlight class="normal">boost::geometry::point_xy&lt;long<sp/>double&gt;<sp/>p3;</highlight></codeline>
</programlisting></para><para>describes three points with different coordinate types, a 32 bits <ulink url="http://en.wikipedia.org/wiki/Single_precision">float</ulink>, a 64 bits <ulink url="http://en.wikipedia.org/wiki/Double_precision_floating-point_format">double</ulink>, a <ulink url="http://en.wikipedia.org/wiki/Long_double">long double</ulink>, not standardized by IEEE and is on some machines 96 bits (using a MSVC compiler it is a synonym for a double).</para><para>By default, algorithms select the coordinate type of the input geometries. If there are two input geometries, and they have different coordinate types, the coordinate type with the most precision is selected. This is done by the meta-function <bold>select_most_precise</bold>.</para><para>Boost.Geometry supports also high precision arithmetic types, by adaption. The numeric_adaptor, used for adaption, is not part of Boost.Geometry itself but developed by us and sent (as preview) to the Boost List (as it turned out, that functionality might also be provided by Boost.Math bindings, but the mechanism is the same). Types from the following libraries are supported:</para><para><itemizedlist>
<listitem><para>GMP (<ulink url="http://gmplib.org">http://gmplib.org</ulink>)</para></listitem><listitem><para>CLN (<ulink url="http://www.ginac.de/CLN">http://www.ginac.de/CLN</ulink>)</para></listitem></itemizedlist>
</para><para>Note that the libraries themselves are not included in Boost.Geometry, they are completely independant of each other.</para><para>These numeric types can be used as following: <programlisting><codeline><highlight class="normal">boost::geometry::point_xy&lt;boost::numeric_adaptor::gmp_value_type&gt;<sp/>p4;</highlight></codeline>
<codeline><highlight class="normal">boost::geometry::point_xy&lt;boost::numeric_adaptor::cln_value_type&gt;<sp/>p5;</highlight></codeline>
</programlisting></para><para>All algorithms using these points will use the <bold>GMP</bold> resp. <bold>CLN</bold> library for calculations.</para></sect1>
<sect1 id="robustness_1robustness_par4">
<title>Calculation types</title>
<para>If high precision arithmetic types are used as shown above, coordinates are stored in these points. That is not always necessary. Therefore, Boost.Geometry provides a second approach. It is possible to specify that only the calculation is done in high precision. This is done by specifying a strategy. For example, in area:</para><para>Example: The code below shows the calculation of the area. Points are stored in double; calculation is done using <bold>GMP</bold> </para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::geometry::point_xy&lt;double&gt;<sp/>point_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::geometry::linear_ring&lt;point_type&gt;<sp/>ring;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ring.push_back(boost::geometry::make&lt;point_type&gt;(0.0,<sp/>0.0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ring.push_back(boost::geometry::make&lt;point_type&gt;(0.0,<sp/>0.0012));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ring.push_back(boost::geometry::make&lt;point_type&gt;(1234567.89012345,<sp/>0.0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ring.push_back(ring.front());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::numeric_adaptor::gmp_value_type<sp/>gmp;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gmp<sp/><ref refid="group__area_1gaf7a1c34467f74f290d0b090adb27db62" kindref="member" tooltip="Calculates the area of a geometry.">area</ref><sp/>=<sp/><ref refid="group__area_1gaf7a1c34467f74f290d0b090adb27db62" kindref="member" tooltip="Calculates the area of a geometry.">boost::geometry::area</ref>(ring,<sp/>boost::geometry::strategy::area::by_triangles&lt;point_type,<sp/>gmp&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>area<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
</programlisting></para><para>Above shows how this is used to use <bold>GMP</bold> or <bold>CLN</bold> for double coordinates. Exactly the same mechanism works (of course) also to do calculation in double, where coordinates are stored in float.</para></sect1>
<sect1 id="robustness_1robustness_par5">
<title>Strategies</title>
<para>In the previous section was shown that strategies have an optional template parameter <bold>CalculationType</bold> so enhance precision. However, the design of Boost.Geometry also allows that the user can implement a strategy himself. In that case he can implement the necessary predicates, or use the necessary floating point types, or even go to integer and back. Whatever he prefers.</para></sect1>
<sect1 id="robustness_1robustness_par6">
<title>Examples</title>
<para>We show here some things which can occur in challenging domains.</para><para>The image below is drawn in PowerPoint to predict what would happen at an intersection of two triangles using float coordinates in the range 1e-45.</para><para><image type="html" name="robust_float.png"></image>
</para><para>If we perform the intersection using Boost.Geometry, we get the effect that is presented on the pictures below, using float (left) and using double (right).</para><para><image type="html" name="robust_triangles.png"></image>
</para><para>This shows how double can solve issues which might be present in float. However, there are also cases which cannot be solved by double or long double. And there are also cases which give more deviations than just a move of the intersection points.</para><para>We investigated this and created an artificial case. In this case, there are two stars, they are the same but one of them is rotated over an interval of about 1e-44. When those stars are intersected, the current Boost.Geometry implementation using float, double or long double will give some artifacts.</para><para>Those artifacts are caused by taking the wrong paths on points where distances are zero (because they cannot be expressed in the used coordinate systems).</para><para>If using <bold>GMP</bold> or <bold>CLN</bold>, the intersection is correct.</para><para><image type="html" name="robust_stars.png"></image>
</para><para>Note again, these things happen in differences of about 1e-45. We can investigate if they can be reduced or sometimes even solved. However, they belong to the floating point approach, which is not exact.</para><para>For many users, this all is not relevant. Using double they will be able to do all operations without any problems or artefacts. They can occur in real life, where differences are very small, or very large. Those users can use <bold>GMP</bold> to use Boost.Geometry without any problem.</para></sect1>
<sect1 id="robustness_1robustness_par7">
<title>Future work</title>
<para>There are several methods to avoid instability and we don&apos;t know them all, some of them might be applicable to our algorithms. Therefore is stated that Boost.Geometry is &quot;not checked on 100% robustness&quot;. As pointed out in the discussions on the Boost mailing list in spring &apos;09 (a.o. <emphasis>&quot;The dependent concept should explicitely require unlimited precision since the library specifically uses it to *guarantee* robustness. [...] Users should be left with no choice but to pick some external component fulfilling the unlimited precision requirement&quot;</emphasis>), it seems that it is not possible to solve all these issues using any FP number, that it is necessary to use a library as GMP or CLN for this guarantee.</para><para>Therefore we decided to go for supporting high precision numeric types first, and they are currently supported in most algorithms (a.o. area, length, perimeter, distance, centroid, intersection, union). However, we certainly are willing to take other measures as well.</para></sect1>
<sect1 id="robustness_1robustness_par8">
<title>Summary</title>
<para>Boost.Geometry approach to support high precision:</para><para><itemizedlist>
<listitem><para>library users can use points with float, double, or long double coordinates (the default)</para></listitem><listitem><para>for higher numerical robustness: users can call algorithms using another calculation type (e.g. <bold>GMP</bold> or <bold>CLN</bold>, ...)</para></listitem><listitem><para>for higher numerical robustness: users can use points with <bold>GMP</bold> or <bold>CLN</bold> coordinates</para></listitem><listitem><para>users can implement their own implementation and provide this as a strategy, the Boost.Geometry design allows this</para></listitem><listitem><para>other measures can be implemented, described as future work. </para></listitem></itemizedlist>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
