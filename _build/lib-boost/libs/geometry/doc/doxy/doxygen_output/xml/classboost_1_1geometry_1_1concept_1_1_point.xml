<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="classboost_1_1geometry_1_1concept_1_1_point" kind="class" prot="public">
    <compoundname>boost::geometry::concept::Point</compoundname>
    <includes local="no">point_concept.hpp</includes>
    <templateparamlist>
      <param>
        <type>typename Geometry</type>
      </param>
    </templateparamlist>
    <briefdescription>
<para><ref refid="classboost_1_1geometry_1_1concept_1_1_point" kindref="compound">Point</ref> concept. </para>    </briefdescription>
    <detaileddescription>
<para><simplesect kind="par"><title>Formal definition:</title><para>The point concept is defined as following:<itemizedlist>
<listitem><para>there must be a specialization of <ref refid="structboost_1_1geometry_1_1traits_1_1tag" kindref="compound">traits::tag</ref> defining <ref refid="structboost_1_1geometry_1_1point__tag" kindref="compound">point_tag</ref> as type</para></listitem><listitem><para>there must be a specialization of <ref refid="structboost_1_1geometry_1_1traits_1_1coordinate__type" kindref="compound">traits::coordinate_type</ref> defining the type of its coordinates</para></listitem><listitem><para>there must be a specialization of <ref refid="structboost_1_1geometry_1_1traits_1_1coordinate__system" kindref="compound">traits::coordinate_system</ref> defining its coordinate system (cartesian, spherical, etc)</para></listitem><listitem><para>there must be a specialization of <ref refid="structboost_1_1geometry_1_1traits_1_1dimension" kindref="compound">traits::dimension</ref> defining its number of dimensions (2, 3, ...) (derive it conveniently from boost::mpl::int_&lt;X&gt; for X-D)</para></listitem><listitem><para>there must be a specialization of <ref refid="structboost_1_1geometry_1_1traits_1_1access" kindref="compound">traits::access</ref>, per dimension, with two functions:<itemizedlist>
<listitem><para><bold>get</bold> to get a coordinate value</para></listitem><listitem><para><bold>set</bold> to set a coordinate value (this one is not checked for <ref refid="classboost_1_1geometry_1_1concept_1_1_const_point" kindref="compound">ConstPoint</ref>)</para></listitem></itemizedlist>
</para></listitem><listitem><para>for non-Cartesian coordinate systems, the coordinate system&apos;s units must either be <ref refid="structboost_1_1geometry_1_1degree" kindref="compound">boost::geometry::degree</ref> or <ref refid="structboost_1_1geometry_1_1radian" kindref="compound">boost::geometry::radian</ref></para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="par"><title>Example:</title><para></para></simplesect>
A legacy point, defining the necessary specializations to fulfil to the concept.</para><para>Suppose that the following point is defined:  <programlisting><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">legacy_point1</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x,<sp/>y;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>It can then be adapted to the concept as following:  <programlisting><codeline><highlight class="comment">//<sp/>adapt<sp/>legacy_point1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">boost<sp/>{<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">geometry<sp/>{<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">traits</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;&gt;<sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">tag&lt;legacy_point1&gt;<sp/>{<sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>point_tag<sp/>type;<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;&gt;<sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">coordinate_type&lt;legacy_point1&gt;<sp/>{<sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>type;<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;&gt;<sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">coordinate_system&lt;legacy_point1&gt;<sp/>{<sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>cs::cartesian<sp/>type;<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;&gt;<sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">dimension&lt;legacy_point1&gt;:<sp/>boost::mpl::int_&lt;2&gt;<sp/>{};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;&gt;<sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">access&lt;legacy_point1,<sp/>0&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(legacy_point1<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>p)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.x;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">set</highlight><highlight class="normal">(legacy_point1&amp;<sp/>p,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>value)<sp/>{<sp/>p.x<sp/>=<sp/>value;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;&gt;<sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">access&lt;legacy_point1,<sp/>1&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">get</highlight><highlight class="normal">(legacy_point1<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>p)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.y;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">set</highlight><highlight class="normal">(legacy_point1&amp;<sp/>p,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>value)<sp/>{<sp/>p.y<sp/>=<sp/>value;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal">}}}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>boost::geometry::traits</highlight></codeline>
</programlisting></para><para>Note that it is done like above to show the system. Users will normally use the registration macro.</para><para><simplesect kind="par"><title>Example:</title><para></para></simplesect>
A read-only legacy point, using a macro to fulfil to the <ref refid="classboost_1_1geometry_1_1concept_1_1_const_point" kindref="compound">ConstPoint</ref> concept. It cannot be modified by the library but can be used in all algorithms where points are not modified.</para><para>The point looks like the following:</para><para> <programlisting><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">legacy_point2</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>It uses the macro as following:  <programlisting><codeline><highlight class="comment">//<sp/>adapt<sp/>legacy_point2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__register_1ga3a3e97175ef92eed648707933c3fbeaa" kindref="member" tooltip="Macro to register a \1 (const version)">BOOST_GEOMETRY_REGISTER_POINT_2D_CONST</ref>(legacy_point2,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">,<sp/><ref refid="structboost_1_1geometry_1_1cs_1_1cartesian" kindref="compound" tooltip="Cartesian coordinate system.">boost::geometry::cs::cartesian</ref>,<sp/>x(),<sp/>y()<sp/>)</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>end<sp/>adaptation</highlight></codeline>
</programlisting> </para>    </detaileddescription>
    <location file="/home/travis/build/boostorg/boost/boost/geometry/geometries/concepts/point_concept.hpp" line="95" bodyfile="/home/travis/build/boostorg/boost/boost/geometry/geometries/concepts/point_concept.hpp" bodystart="94" bodyend="134"/>
    <listofallmembers>
    </listofallmembers>
  </compounddef>
</doxygen>
