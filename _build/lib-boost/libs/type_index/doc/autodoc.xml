<?xml version="1.0" standalone="yes"?>
<library-reference id="boost_typeindex_header_reference"><title>Boost.TypeIndex Header Reference</title><header name="boost/type_index.hpp">
<para>Includes minimal set of headers required to use the Boost.TypeIndex library. </para><para>By inclusion of this file most optimal type index classes will be included and used as a boost::typeindex::type_index and boost::typeindex::type_info. </para><namespace name="boost">
<namespace name="typeindex">
<typedef name="type_index"><description><para>Depending on a compiler flags, optimal implementation of type_index will be used as a default boost::typeindex::type_index.</para><para>Could be a <classname alt="boost::typeindex::stl_type_index">boost::typeindex::stl_type_index</classname>, <classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname> or user defined type_index class.</para><para><emphasis role="bold">See</emphasis> <classname alt="boost::typeindex::type_index_facade">boost::typeindex::type_index_facade</classname> for a full description of type_index functions. </para></description><type>platform_specific</type></typedef>
<typedef name="type_info"><description><para>Depending on a compiler flags, optimal implementation of type_info will be used as a default boost::typeindex::type_info.</para><para>Could be a std::type_info, <classname alt="boost::typeindex::detail::ctti_data">boost::typeindex::detail::ctti_data</classname> or some user defined class.</para><para>type_info <emphasis role="bold">is</emphasis> <emphasis role="bold">not</emphasis> copyable or default constructible. It is <emphasis role="bold">not</emphasis> assignable too! </para></description><type>type_index::type_info_t</type></typedef>
<function name="type_id"><type>type_index</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>Function to get boost::typeindex::type_index for a type T. Removes const, volatile &amp;&amp; and &amp; modifiers from T.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++"> type_index ti = type_id&lt;int&amp;&gt;();
 std::cout &lt;&lt; ti.pretty_name();  // Outputs 'int'
</programlisting></para><para>


</para></description><returns><para>boost::typeindex::type_index with information about the specified type T. </para></returns><throws><simpara><classname>Nothing.</classname> </simpara></throws></function>
<function name="type_id_with_cvr"><type>type_index</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>Function for constructing boost::typeindex::type_index instance for type T. Does not remove const, volatile, &amp; and &amp;&amp; modifiers from T.</para><para>If T has no const, volatile, &amp; and &amp;&amp; modifiers, then returns exactly the same result as in case of calling `type_id&lt;T&gt;()`.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++"> type_index ti = type_id_with_cvr&lt;int&amp;&gt;();
 std::cout &lt;&lt; ti.pretty_name();  // Outputs 'int&amp;'
</programlisting></para><para>


</para></description><returns><para>boost::typeindex::type_index with information about the specified type T. </para></returns><throws><simpara><classname>Nothing.</classname> </simpara></throws></function>
<function name="type_id_runtime"><type>type_index</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="runtime_val"><paramtype>const T &amp;</paramtype><description><para>Varaible which runtime type must be returned. </para></description></parameter><description><para>Function that works exactly like C++ typeid(rtti_val) call, but returns boost::type_index.</para><para>Retunrs runtime information about specified type.</para><para><emphasis role="bold">Requirements:</emphasis> RTTI available or Base and Derived classes must be marked with BOOST_TYPE_INDEX_REGISTER_CLASS.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++"> struct Base { virtual ~Base(){} };
 struct Derived: public Base  {};
 ...
 Derived d;
 Base&amp; b = d;
 type_index ti = type_id_runtime(b);
 std::cout &lt;&lt; ti.pretty_name();  // Outputs 'Derived'
</programlisting></para><para>


</para></description><returns><para>boost::typeindex::type_index with information about the specified variable. </para></returns><throws><simpara><classname>Nothing.</classname> </simpara></throws></function>






</namespace>

</namespace>
<macro name="BOOST_TYPE_INDEX_REGISTER_CLASS"><description><para>BOOST_TYPE_INDEX_REGISTER_CLASS is used to help to emulate RTTI. Put this macro into the public section of polymorphic class to allow runtime type detection.</para><para>Depending on the typeid() availability this macro will expand to nothing or to virtual helper function `virtual const type_info&amp; boost_type_info_type_id_runtime_() const noexcept`.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++"> class A {
 public:
     BOOST_TYPE_INDEX_REGISTER_CLASS
     virtual ~A(){}
 };

 struct B: public A {
     BOOST_TYPE_INDEX_REGISTER_CLASS
 };

 struct C: public B {
     BOOST_TYPE_INDEX_REGISTER_CLASS
 };

 ...

 C c1;
 A* pc1 = &amp;c1;
 assert(boost::typeindex::type_id&lt;C&gt;() == boost::typeindex::type_id_runtime(*pc1));
</programlisting> </para></description></macro>
<macro name="BOOST_TYPE_INDEX_FUNCTION_SIGNATURE"><description><para>BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is used by <classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname> class to deduce the name of a type. If your compiler is not recognized by the TypeIndex library and you wish to work with <classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname>, you may define this macro by yourself.</para><para>BOOST_TYPE_INDEX_FUNCTION_SIGNATURE must be defined to a compiler specific macro that outputs the <emphasis role="bold">whole</emphasis> function signature <emphasis role="bold">including</emphasis> <emphasis role="bold">template</emphasis> <emphasis role="bold">parameters</emphasis>.</para><para>If your compiler is not recognised and BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is not defined, then a compile-time error will arise at any attempt to use <classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname> classes.</para><para>See BOOST_TYPE_INDEX_REGISTER_CTTI_PARSING_PARAMS and BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING for an information of how to tune the implementation to make a nice pretty_name() output. </para></description></macro>
<macro name="BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING"><description><para>This is a helper macro for making correct pretty_names() with RTTI off.</para><para>BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING macro may be defined to '(begin_skip, end_skip, runtime_skip, runtime_skip_until)' with parameters for adding a support for compilers, that by default are not recognized by TypeIndex library.</para><para><emphasis role="bold">Example:</emphasis> </para><para>Imagine the situation when <programlisting language="c++"> boost::typeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name() 
</programlisting> returns the following string: <programlisting language="c++"> "static const char *boost::detail::ctti&lt;int&gt;::n() [T = int]" 
</programlisting> and <programlisting language="c++"> boost::typeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name() 
</programlisting> returns the following: <programlisting language="c++"> "static const char *boost::detail::ctti&lt;short&gt;::n() [T = short]" 
</programlisting></para><para>As we may see first 39 characters are "static const char *boost::detail::ctti&lt;" and they do not depend on the type T. After first 39 characters we have a human readable type name which is duplicated at the end of a string. String always ends on ']', which consumes 1 character.</para><para>Now if we define `BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING` to `(39, 1, false, "")` we'll be getting <programlisting language="c++"> "int&gt;::n() [T = int" 
</programlisting> for `boosttypeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name()` and <programlisting language="c++"> "short&gt;::n() [T = short" 
</programlisting> for `boosttypeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name()`.</para><para>Now we need to take additional care of the characters that go before the last mention of our type. We'll do that by telling the macro that we need to cut off everything that goes before the "T = " including the "T = " itself:</para><para><programlisting language="c++"> (39, 1, true, "T = ") 
</programlisting></para><para>In case of GCC or Clang command line we need to add the following line while compiling all the sources:</para><para><programlisting language="c++"> -DBOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING='(39, 1, true, "T = ")'
</programlisting> 
See [RTTI emulation limitations](boost_typeindex/rtti_emulation_limitations.html) for more info. </para></description></macro>
<macro name="BOOST_TYPE_INDEX_USER_TYPEINDEX"><description><para>BOOST_TYPE_INDEX_USER_TYPEINDEX can be defined to the path to header file with user provided implementation of type_index.</para><para>See [Making a custom type_index](boost_typeindex/making_a_custom_type_index.html) section of documentation for usage example. </para></description></macro>
<macro name="BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY"><description><para>BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY is a helper macro that must be defined if mixing RTTI on/off modules. See [Mixing sources with RTTI on and RTTI off](boost_typeindex/mixing_sources_with_rtti_on_and_.html) section of documentation for more info. </para></description></macro>
</header>
<header name="boost/type_index/ctti_type_index.hpp">
<para>Contains <classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname> class. </para><para><classname alt="boost::typeindex::ctti_type_index">boost::typeindex::ctti_type_index</classname> class can be used as a drop-in replacement for std::type_index.</para><para>It is used in situations when typeid() method is not available or BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY macro is defined. </para><namespace name="boost">
<namespace name="typeindex">
<class name="ctti_type_index"><description><para>This class is a wrapper that pretends to work exactly like <classname alt="boost::typeindex::stl_type_index">stl_type_index</classname>, but does not require RTTI support. <emphasis role="bold">For</emphasis> <emphasis role="bold">description</emphasis> <emphasis role="bold">of</emphasis> <emphasis role="bold">functions</emphasis> <emphasis role="bold">see</emphasis> <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>.</para><para>This class produces slightly longer type names, so consider using <classname alt="boost::typeindex::stl_type_index">stl_type_index</classname> in situations when typeid() is working. </para></description><typedef name="type_info_t"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="private member functions">
<method name="get_raw_name_length" cv="const noexcept"><type>std::size_t</type></method>
</method-group>
<method-group name="public member functions">
<method name="type_info" cv="const noexcept"><type>const <classname>type_info_t</classname> &amp;</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Const reference to underlying low level type_info_t. </para></returns></method>
<method name="raw_name" cv="const noexcept"><type>const char *</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">must</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Pointer to unredable/raw type name. </para></returns></method>
<method name="pretty_name" cv="const"><type>std::string</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides may throw. 
</para></description><returns><para>Human readable type name. By default returns Derived::name(). </para></returns></method>
<method name="hash_code" cv="const noexcept"><type>std::size_t</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
<note><para>&lt;boost/functional/hash.hpp&gt; has to be included if this function is used. </para></note>
</para></description><returns><para>Hash code of a type. By default hashes types by raw_name(). </para></returns></method>
</method-group>
<constructor cv="noexcept"/>
<constructor cv="noexcept"><parameter name="data"><paramtype>const <classname>type_info_t</classname> &amp;</paramtype></parameter></constructor>
<method-group name="public static functions">
<method name="type_id" cv="noexcept" specifiers="static"><type><classname>ctti_type_index</classname></type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id() will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. Overrides <emphasis role="bold">must</emphasis> remove const, volatile &amp;&amp; and &amp; modifiers from T. 

</para></description><returns><para>type_index for type T. </para></returns></method>
<method name="type_id_with_cvr" cv="noexcept" specifiers="static"><type><classname>ctti_type_index</classname></type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id_with_cvr() will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. Overrides <emphasis role="bold">must</emphasis> <emphasis role="bold">not</emphasis> remove const, volatile &amp;&amp; and &amp; modifiers from T. 

</para></description><returns><para>type_index for type T. </para></returns></method>
<method name="type_id_runtime" cv="noexcept" specifiers="static"><type><classname>ctti_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="variable"><paramtype>const T &amp;</paramtype><description><para>Variable which runtime type will be stored in type_index. </para></description></parameter><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id_runtime(const T&amp;) will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. 

</para></description><returns><para>type_index with runtime type of variable. </para></returns></method>
</method-group>
</class>







<function name="ctti_construct"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><purpose>Helper method for getting <classname alt="boost::typeindex::detail::ctti_data">detail::ctti_data</classname> of a template parameter T. </purpose></function>
</namespace>

</namespace>
</header>
<header name="boost/type_index/stl_type_index.hpp">
<para>Contains <classname alt="boost::typeindex::stl_type_index">boost::typeindex::stl_type_index</classname> class. </para><para><classname alt="boost::typeindex::stl_type_index">boost::typeindex::stl_type_index</classname> class can be used as a drop-in replacement for std::type_index.</para><para>It is used in situations when RTTI is enabled or typeid() method is available. When typeid() is disabled or BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY macro is defined boost::typeindex::ctti is usually used instead of <classname alt="boost::typeindex::stl_type_index">boost::typeindex::stl_type_index</classname>. </para><namespace name="boost">
<namespace name="typeindex">
<class name="stl_type_index"><inherit access="public">boost::typeindex::type_index_facade&lt; stl_type_index, std::type_info &gt;</inherit><description><para>This class is a wrapper around std::type_info, that workarounds issues and provides much more rich interface. <emphasis role="bold">For</emphasis> <emphasis role="bold">description</emphasis> <emphasis role="bold">of</emphasis> <emphasis role="bold">functions</emphasis> <emphasis role="bold">see</emphasis> <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>.</para><para>This class requires typeid() to work. For cases when RTTI is disabled see <classname alt="boost::typeindex::ctti_type_index">ctti_type_index</classname>. </para></description><typedef name="type_info_t"><type>std::type_info</type></typedef>
<method-group name="public member functions">
<method name="type_info" cv="const noexcept"><type>const type_info_t &amp;</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Const reference to underlying low level type_info_t. </para></returns></method>
<method name="raw_name" cv="const noexcept"><type>const char *</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">must</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Pointer to unredable/raw type name. </para></returns></method>
<method name="name" cv="const noexcept"><type>const char *</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Name of a type. By default returns Derived::raw_name(). </para></returns></method>
<method name="pretty_name" cv="const"><type>std::string</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides may throw. 
</para></description><returns><para>Human readable type name. By default returns Derived::name(). </para></returns></method>
<method name="hash_code" cv="const noexcept"><type>std::size_t</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
<note><para>&lt;boost/functional/hash.hpp&gt; has to be included if this function is used. </para></note>
</para></description><returns><para>Hash code of a type. By default hashes types by raw_name(). </para></returns></method>
<method name="equal" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const <classname>stl_type_index</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>True if two types are equal. By default compares types by raw_name(). </para></returns></method>
<method name="before" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const <classname>stl_type_index</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>True if rhs is greater than this. By default compares types by raw_name(). </para></returns></method>
</method-group>
<constructor cv="noexcept"/>
<constructor cv="noexcept"><parameter name="data"><paramtype>const type_info_t &amp;</paramtype></parameter></constructor>
<method-group name="public static functions">
<method name="type_id" cv="noexcept" specifiers="static"><type><classname>stl_type_index</classname></type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id() will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. Overrides <emphasis role="bold">must</emphasis> remove const, volatile &amp;&amp; and &amp; modifiers from T. 

</para></description><returns><para>type_index for type T. </para></returns></method>
<method name="type_id_with_cvr" cv="noexcept" specifiers="static"><type><classname>stl_type_index</classname></type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id_with_cvr() will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. Overrides <emphasis role="bold">must</emphasis> <emphasis role="bold">not</emphasis> remove const, volatile &amp;&amp; and &amp; modifiers from T. 

</para></description><returns><para>type_index for type T. </para></returns></method>
<method name="type_id_runtime" cv="noexcept" specifiers="static"><type><classname>stl_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="variable"><paramtype>const T &amp;</paramtype><description><para>Variable which runtime type will be stored in type_index. </para></description></parameter><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id_runtime(const T&amp;) will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. 

</para></description><returns><para>type_index with runtime type of variable. </para></returns></method>
</method-group>
</class>








</namespace>

</namespace>
</header>
<header name="boost/type_index/type_index_facade.hpp">
<namespace name="boost">
<namespace name="typeindex">
<class name="type_index_facade"><template>
      <template-type-parameter name="Derived"><purpose><para>Class derived from <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>. </para></purpose></template-type-parameter>
      <template-type-parameter name="TypeInfo"><purpose><para>Class that will be used as a base type_info class. </para></purpose></template-type-parameter>
    </template><description><para>This class takes care about the comparison operators, hash functions and ostream operators. Use this class as a public base class for defining new type_info-conforming classes.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++"> class stl_type_index: public type_index_facade&lt;stl_type_index, std::type_info&gt; 
 {
 public:
     typedef std::type_info type_info_t;
 private:
     const type_info_t* data_;

 public:
     stl_type_index(const type_info_t&amp; data) noexcept
         : data_(&amp;data)
     {}
 // ...
 };
</programlisting></para><para>
<note><para>Take a look at the protected methods. They are <emphasis role="bold">not</emphasis> <emphasis role="bold">defined</emphasis> in <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>. Protected member functions raw_name() <emphasis role="bold">must</emphasis> be defined in Derived class. All the other methods are mandatory. </para></note>
<para><emphasis role="bold">See Also:</emphasis><para>'Making a custom type_index' section for more information about creating your own type_index using <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>. </para></para>
</para></description><typedef name="type_info_t"><type>TypeInfo</type></typedef>
<method-group name="public member functions">
<method name="name" cv="const noexcept"><type>const char *</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Name of a type. By default returns Derived::raw_name(). </para></returns></method>
<method name="pretty_name" cv="const"><type>std::string</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides may throw. 
</para></description><returns><para>Human readable type name. By default returns Derived::name(). </para></returns></method>
<method name="equal" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const Derived &amp;</paramtype></parameter><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>True if two types are equal. By default compares types by raw_name(). </para></returns></method>
<method name="before" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const Derived &amp;</paramtype></parameter><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>True if rhs is greater than this. By default compares types by raw_name(). </para></returns></method>
<method name="hash_code" cv="const noexcept"><type>std::size_t</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
<note><para>&lt;boost/functional/hash.hpp&gt; has to be included if this function is used. </para></note>
</para></description><returns><para>Hash code of a type. By default hashes types by raw_name(). </para></returns></method>
</method-group>
<method-group name="protected member functions">
<method name="raw_name" cv="const noexcept"><type>const char *</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">must</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Pointer to unredable/raw type name. </para></returns></method>
<method name="type_info" cv="const noexcept"><type>const type_info_t &amp;</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Const reference to underlying low level type_info_t. </para></returns></method>
</method-group>
<method-group name="protected static functions">
<method name="type_id" cv="noexcept" specifiers="static"><type>Derived</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id() will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. Overrides <emphasis role="bold">must</emphasis> remove const, volatile &amp;&amp; and &amp; modifiers from T. 

</para></description><returns><para>type_index for type T. </para></returns></method>
<method name="type_id_with_cvr" cv="noexcept" specifiers="static"><type>Derived</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id_with_cvr() will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. Overrides <emphasis role="bold">must</emphasis> <emphasis role="bold">not</emphasis> remove const, volatile &amp;&amp; and &amp; modifiers from T. 

</para></description><returns><para>type_index for type T. </para></returns></method>
<method name="type_id_runtime" cv="noexcept" specifiers="static"><type>Derived</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="variable"><paramtype>const T &amp;</paramtype><description><para>Variable which runtime type will be stored in type_index. </para></description></parameter><description><para>This is a factory method that is used to create instances of Derived classes. boost::typeindex::type_id_runtime(const T&amp;) will call this method, if Derived has same type as boost::typeindex::type_index.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. 

</para></description><returns><para>type_index with runtime type of variable. </para></returns></method>
</method-group>
</class>


<function name="operator==,!=,&lt;,..."><type>bool</type><parameter name="lhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><description><para>noexcept comparison operators for <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname> classes. </para></description></function>
<function name="operator==,!=,&lt;,..."><type>bool</type><parameter name="lhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const TypeInfo &amp;</paramtype></parameter><purpose>noexcept comparison operators for <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname> and it's TypeInfo classes. </purpose></function>
<function name="operator==,!=,&lt;,..."><type>bool</type><parameter name="lhs"><paramtype>const TypeInfo &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><purpose>noexcept comparison operators for <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname>'s TypeInfo and <classname alt="boost::typeindex::type_index_facade">type_index_facade</classname> classes. </purpose></function>
<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, TriatT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TriatT"/>
          <template-type-parameter name="Derived"/>
          <template-type-parameter name="TypeInfo"/>
        </template><parameter name="ostr"><paramtype>std::basic_ostream&lt; CharT, TriatT &gt; &amp;</paramtype></parameter><parameter name="ind"><paramtype>const <classname>type_index_facade</classname>&lt; Derived, TypeInfo &gt; &amp;</paramtype></parameter><purpose>Ostream operator that will output demangled name. </purpose></function>
<function name="hash_value"><type>std::size_t</type><template>
          <template-type-parameter name="Derived"/>
          <template-type-parameter name="TypeInfo"/>
        </template><parameter name="lhs"><paramtype>const <classname>type_index_facade</classname>&lt; Derived, TypeInfo &gt; &amp;</paramtype></parameter><description><para>This free function is used by Boost's unordered containers. <note><para>&lt;boost/functional/hash.hpp&gt; has to be included if this function is used. </para></note>
</para></description></function>

</namespace>
<function name="hash_range"><type>std::size_t</type><template>
          <template-type-parameter name="It"/>
        </template><parameter name=""><paramtype>It</paramtype></parameter><parameter name=""><paramtype>It</paramtype></parameter></function>
</namespace>
</header>
</library-reference>
