<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Proto's Built-In Transforms</title>
<link rel="stylesheet" href="../../../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../../../index.html" title="Chapter&#160;1.&#160;Boost.Proto">
<link rel="up" href="../expression_transformation.html" title="Expression Transformation: Semantic Actions">
<link rel="prev" href="external_transforms.html" title="Separating Grammars And Transforms">
<link rel="next" href="primitives.html" title="Building Custom Primitive Transforms">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="external_transforms.html"><img src="../../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../expression_transformation.html"><img src="../../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../index.html"><img src="../../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="primitives.html"><img src="../../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms"></a><a class="link" href="canned_transforms.html" title="Proto's Built-In Transforms">Proto's
          Built-In Transforms</a>
</h5></div></div></div>
<p>
            Primitive transforms are the building blocks for more interesting composite
            transforms. Proto defines a bunch of generally useful primitive transforms.
            They are summarized below.
          </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/_value.html" title="Struct _value">proto::_value</a></code></span></dt>
<dd><p>
                  Given a terminal expression, return the value of the terminal.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/_child_c.html" title="Struct template _child_c">proto::_child_c&lt;&gt;</a></code></span></dt>
<dd><p>
                  Given a non-terminal expression, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span><em class="replaceable"><code>N</code></em><span class="special">&gt;</span></code> returns the <em class="replaceable"><code>N</code></em>-th
                  child.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../header/boost/proto/proto_fwd_hpp.html#boost.proto._child">proto::_child</a></code></span></dt>
<dd><p>
                  A synonym for <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code>.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../header/boost/proto/proto_fwd_hpp.html#boost.proto._left">proto::_left</a></code></span></dt>
<dd><p>
                  A synonym for <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code>.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../header/boost/proto/proto_fwd_hpp.html#boost.proto._right">proto::_right</a></code></span></dt>
<dd><p>
                  A synonym for <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span></code>.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/_expr.html" title="Struct _expr">proto::_expr</a></code></span></dt>
<dd><p>
                  Returns the current expression unmodified.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/_state.html" title="Struct _state">proto::_state</a></code></span></dt>
<dd><p>
                  Returns the current state unmodified.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/_data.html" title="Struct _data">proto::_data</a></code></span></dt>
<dd><p>
                  Returns the current data unmodified.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/call.html" title="Struct template call">proto::call&lt;&gt;</a></code></span></dt>
<dd><p>
                  For a given callable transform <code class="computeroutput"><em class="replaceable"><code>CT</code></em></code>,
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;</span><em class="replaceable"><code>CT</code></em><span class="special">&gt;</span></code> turns the callable transform
                  into a primitive transform. This is useful for disambiguating callable
                  transforms from object transforms, and also for working around
                  compiler bugs with nested function types.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/make.html" title="Struct template make">proto::make&lt;&gt;</a></code></span></dt>
<dd><p>
                  For a given object transform <code class="computeroutput"><em class="replaceable"><code>OT</code></em></code>,
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">make</span><span class="special">&lt;</span><em class="replaceable"><code>OT</code></em><span class="special">&gt;</span></code> turns the object transform
                  into a primitive transform. This is useful for disambiguating object
                  transforms from callable transforms, and also for working around
                  compiler bugs with nested function types.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/_default.html" title="Struct template _default">proto::_default&lt;&gt;</a></code></span></dt>
<dd><p>
                  Given a grammar <em class="replaceable"><code>G</code></em>, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_default</span><span class="special">&lt;</span><em class="replaceable"><code>G</code></em><span class="special">&gt;</span></code> evaluates the current node
                  according to the standard C++ meaning of the operation the node
                  represents. For instance, if the current node is a binary plus
                  node, the two children will both be evaluated according to <code class="computeroutput"><em class="replaceable"><code>G</code></em></code>
                  and the results will be added and returned. The return type is
                  deduced with the help of the Boost.Typeof library.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/fold.html" title="Struct template fold">proto::fold&lt;&gt;</a></code></span></dt>
<dd><p>
                  Given three transforms <code class="computeroutput"><em class="replaceable"><code>ET</code></em></code>,
                  <code class="computeroutput"><em class="replaceable"><code>ST</code></em></code>, and <code class="computeroutput"><em class="replaceable"><code>FT</code></em></code>,
                  <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">fold</span><span class="special">&lt;</span><em class="replaceable"><code>ET</code></em><span class="special">,</span> <em class="replaceable"><code>ST</code></em><span class="special">,</span> <em class="replaceable"><code>FT</code></em><span class="special">&gt;</span></code> first evaluates <code class="computeroutput"><em class="replaceable"><code>ET</code></em></code>
                  to obtain a Fusion sequence and <code class="computeroutput"><em class="replaceable"><code>ST</code></em></code>
                  to obtain an initial state for the fold, and then evaluates <code class="computeroutput"><em class="replaceable"><code>FT</code></em></code>
                  for each element in the sequence to generate the next state from
                  the previous.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/reverse_fold.html" title="Struct template reverse_fold">proto::reverse_fold&lt;&gt;</a></code></span></dt>
<dd><p>
                  Like <code class="computeroutput"><a class="link" href="../../../../boost/proto/fold.html" title="Struct template fold">proto::fold&lt;&gt;</a></code>, except the
                  elements in the Fusion sequence are iterated in reverse order.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/fold_tree.html" title="Struct template fold_tree">proto::fold_tree&lt;&gt;</a></code></span></dt>
<dd><p>
                  Like <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">fold</span><span class="special">&lt;</span><em class="replaceable"><code>ET</code></em><span class="special">,</span> <em class="replaceable"><code>ST</code></em><span class="special">,</span> <em class="replaceable"><code>FT</code></em><span class="special">&gt;</span></code>, except that the result of
                  the <code class="computeroutput"><em class="replaceable"><code>ET</code></em></code> transform is treated
                  as an expression tree that is <span class="emphasis"><em>flattened</em></span> to
                  generate the sequence to be folded. Flattening an expression tree
                  causes child nodes with the same tag type as the parent to be put
                  into sequence. For instance, <code class="computeroutput"><span class="identifier">a</span>
                  <span class="special">&gt;&gt;</span> <span class="identifier">b</span>
                  <span class="special">&gt;&gt;</span> <span class="identifier">c</span></code>
                  would be flattened to the sequence [<code class="computeroutput"><span class="identifier">a</span></code>,
                  <code class="computeroutput"><span class="identifier">b</span></code>, <code class="computeroutput"><span class="identifier">c</span></code>], and this is the sequence
                  that would be folded.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/reverse_fold_tree.html" title="Struct template reverse_fold_tree">proto::reverse_fold_tree&lt;&gt;</a></code></span></dt>
<dd><p>
                  Like <code class="computeroutput"><a class="link" href="../../../../boost/proto/fold_tree.html" title="Struct template fold_tree">proto::fold_tree&lt;&gt;</a></code>, except that
                  the flattened sequence is iterated in reverse order.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/lazy.html" title="Struct template lazy">proto::lazy&lt;&gt;</a></code></span></dt>
<dd><p>
                  A combination of <code class="computeroutput"><a class="link" href="../../../../boost/proto/make.html" title="Struct template make">proto::make&lt;&gt;</a></code>
                  and <code class="computeroutput"><a class="link" href="../../../../boost/proto/call.html" title="Struct template call">proto::call&lt;&gt;</a></code> that is useful
                  when the nature of the transform depends on the expression, state
                  and/or data parameters. <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">lazy</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">...</span><span class="identifier">An</span><span class="special">)&gt;</span></code> first evaluates <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">make</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">()&gt;</span></code>
                  to compute a callable type <code class="computeroutput"><span class="identifier">R2</span></code>.
                  Then, it evaluates <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">call</span><span class="special">&lt;</span><span class="identifier">R2</span><span class="special">(</span><span class="identifier">A0</span><span class="special">,</span><span class="identifier">A1</span><span class="special">...</span><span class="identifier">An</span><span class="special">)&gt;</span></code>.
                </p></dd>
</dl>
</div>
<h6>
<a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms.h0"></a>
            <span><a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms.all_grammars_are_primitive_transforms"></a></span><a class="link" href="canned_transforms.html#boost_proto.users_guide.back_end.expression_transformation.canned_transforms.all_grammars_are_primitive_transforms">All
            Grammars Are Primitive Transforms</a>
          </h6>
<p>
            In addition to the above primitive transforms, all of Proto's grammar
            elements are also primitive transforms. Their behaviors are described
            below.
          </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/_.html" title="Struct _">proto::_</a></code></span></dt>
<dd><p>
                  Return the current expression unmodified.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code></span></dt>
<dd><p>
                  For the specified set of alternate sub-grammars, find the one that
                  matches the given expression and apply its associated transform.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/and_.html" title="Struct template and_">proto::and_&lt;&gt;</a></code></span></dt>
<dd><p>
                  For the given set of sub-grammars, apply all the associated transforms
                  and return the result of the last.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/not_.html" title="Struct template not_">proto::not_&lt;&gt;</a></code></span></dt>
<dd><p>
                  Return the current expression unmodified.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/if_.html" title="Struct template if_">proto::if_&lt;&gt;</a></code></span></dt>
<dd><p>
                  Given three transforms, evaluate the first and treat the result
                  as a compile-time Boolean value. If it is true, evaluate the second
                  transform. Otherwise, evaluate the third.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/switch_.html" title="Struct template switch_">proto::switch_&lt;&gt;</a></code></span></dt>
<dd><p>
                  As with <code class="computeroutput"><a class="link" href="../../../../boost/proto/or_.html" title="Struct template or_">proto::or_&lt;&gt;</a></code>, find the sub-grammar
                  that matches the given expression and apply its associated transform.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code></span></dt>
<dd><p>
                  Return the current terminal expression unmodified.
                </p></dd>
<dt><span class="term"> <code class="computeroutput"><a class="link" href="../../../../boost/proto/plus.html" title="Struct template plus">proto::plus&lt;&gt;</a></code>, <code class="computeroutput"><a class="link" href="../../../../boost/proto/nary_expr.html" title="Struct template nary_expr">proto::nary_expr&lt;&gt;</a></code>,
              et. al.</span></dt>
<dd><p>
                  A Proto grammar that matches a non-terminal such as <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><em class="replaceable"><code>G0</code></em><span class="special">,</span> <em class="replaceable"><code>G1</code></em><span class="special">&gt;</span></code>, when used as a primitive transform,
                  creates a new plus node where the left child is transformed according
                  to <code class="computeroutput"><em class="replaceable"><code>G0</code></em></code> and the right child
                  with <code class="computeroutput"><em class="replaceable"><code>G1</code></em></code>.
                </p></dd>
</dl>
</div>
<h6>
<a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms.h1"></a>
            <span><a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms.the_pass_through_transform"></a></span><a class="link" href="canned_transforms.html#boost_proto.users_guide.back_end.expression_transformation.canned_transforms.the_pass_through_transform">The
            Pass-Through Transform</a>
          </h6>
<p>
            Note the primitive transform associated with grammar elements such as
            <code class="computeroutput"><a class="link" href="../../../../boost/proto/plus.html" title="Struct template plus">proto::plus&lt;&gt;</a></code> described above.
            They possess a so-called <span class="emphasis"><em>pass-through</em></span> transform.
            The pass-through transform accepts an expression of a certain tag type
            (say, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span></code>) and creates a new expression
            of the same tag type, where each child expression is transformed according
            to the corresponding child grammar of the pass-through transform. So
            for instance this grammar ...
          </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span> <span class="identifier">X</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">vararg</span><span class="special">&lt;</span><span class="identifier">Y</span><span class="special">&gt;</span> <span class="special">&gt;</span>
</pre>
<p>
            ... matches function expressions where the first child matches the <code class="computeroutput"><span class="identifier">X</span></code> grammar and the rest match the <code class="computeroutput"><span class="identifier">Y</span></code> grammar. When used as a transform,
            the above grammar will create a new function expression where the first
            child is transformed according to <code class="computeroutput"><span class="identifier">X</span></code>
            and the rest are transformed according to <code class="computeroutput"><span class="identifier">Y</span></code>.
          </p>
<p>
            The following class templates in Proto can be used as grammars with pass-through
            transforms:
          </p>
<div class="table">
<a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms.t0"></a><p class="title"><b>Table&#160;1.11.&#160;Class Templates With Pass-Through Transforms</b></p>
<div class="table-contents"><table class="table" summary="Class Templates With Pass-Through Transforms">
<colgroup><col></colgroup>
<thead><tr><th>
                    <p>
                      Templates with Pass-Through Transforms
                    </p>
                  </th></tr></thead>
<tbody>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">unary_plus</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">negate</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">dereference</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">complement</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">address_of</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">logical_not</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">pre_inc</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">pre_dec</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">post_inc</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">post_dec</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">modulus</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">greater</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">less_equal</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">greater_equal</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_equal_to</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">logical_or</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">logical_and</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_and</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_or</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_xor</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">comma</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">mem_ptr</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">assign</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_left_assign</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">shift_right_assign</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies_assign</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides_assign</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">modulus_assign</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus_assign</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus_assign</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_and_assign</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_or_assign</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">bitwise_xor_assign</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">subscript</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">if_else_</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">unary_expr</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">binary_expr</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
<tr><td>
                    <p>
                      <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;&gt;</span></code>
                    </p>
                  </td></tr>
</tbody>
</table></div>
</div>
<br class="table-break"><h6>
<a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms.h2"></a>
            <span><a name="boost_proto.users_guide.back_end.expression_transformation.canned_transforms.the_many_roles_of_proto_operator_metafunctions"></a></span><a class="link" href="canned_transforms.html#boost_proto.users_guide.back_end.expression_transformation.canned_transforms.the_many_roles_of_proto_operator_metafunctions">The
            Many Roles of Proto Operator Metafunctions</a>
          </h6>
<p>
            We've seen templates such as <code class="computeroutput"><a class="link" href="../../../../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code>,
            <code class="computeroutput"><a class="link" href="../../../../boost/proto/plus.html" title="Struct template plus">proto::plus&lt;&gt;</a></code> and <code class="computeroutput"><a class="link" href="../../../../boost/proto/nary_expr.html" title="Struct template nary_expr">proto::nary_expr&lt;&gt;</a></code>
            fill many roles. They are metafunction that generate expression types.
            They are grammars that match expression types. And they are primitive
            transforms. The following code samples show examples of each.
          </p>
<p>
            <span class="bold"><strong>As Metafunctions ...</strong></span>
          </p>
<pre class="programlisting"><span class="comment">// proto::terminal&lt;&gt; and proto::plus&lt;&gt; are metafunctions</span>
<span class="comment">// that generate expression types:</span>
<span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">int_</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">int_</span><span class="special">,</span> <span class="identifier">int_</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">plus_</span><span class="special">;</span>

<span class="identifier">int_</span> <span class="identifier">i</span> <span class="special">=</span> <span class="special">{</span><span class="number">42</span><span class="special">},</span> <span class="identifier">j</span> <span class="special">=</span> <span class="special">{</span><span class="number">24</span><span class="special">};</span>
<span class="identifier">plus_</span> <span class="identifier">p</span> <span class="special">=</span> <span class="special">{</span><span class="identifier">i</span><span class="special">,</span> <span class="identifier">j</span><span class="special">};</span>
</pre>
<p>
            <span class="bold"><strong>As Grammars ...</strong></span>
          </p>
<pre class="programlisting"><span class="comment">// proto::terminal&lt;&gt; and proto::plus&lt;&gt; are grammars that</span>
<span class="comment">// match expression types</span>
<span class="keyword">struct</span> <span class="identifier">Int</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">Plus</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">Int</span><span class="special">,</span> <span class="identifier">Int</span><span class="special">&gt;</span> <span class="special">{};</span>

<span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">int_</span><span class="special">,</span> <span class="identifier">Int</span> <span class="special">&gt;</span> <span class="special">));</span>
<span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span> <span class="identifier">plus_</span><span class="special">,</span> <span class="identifier">Plus</span> <span class="special">&gt;</span> <span class="special">));</span>
</pre>
<p>
            <span class="bold"><strong>As Primitive Transforms ...</strong></span>
          </p>
<pre class="programlisting"><span class="comment">// A transform that removes all unary_plus nodes in an expression</span>
<span class="keyword">struct</span> <span class="identifier">RemoveUnaryPlus</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">when</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">unary_plus</span><span class="special">&lt;</span><span class="identifier">RemoveUnaryPlus</span><span class="special">&gt;</span>
          <span class="special">,</span> <span class="identifier">RemoveUnaryPlus</span><span class="special">(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_child</span><span class="special">)</span>
        <span class="special">&gt;</span>
        <span class="comment">// Use proto::terminal&lt;&gt; and proto::nary_expr&lt;&gt;</span>
        <span class="comment">// both as grammars and as primitive transforms.</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">nary_expr</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">vararg</span><span class="special">&lt;</span><span class="identifier">RemoveUnaryPlus</span><span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">literal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">i</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>

    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">display_expr</span><span class="special">(</span>
        <span class="special">+</span><span class="identifier">i</span> <span class="special">-</span> <span class="special">+(</span><span class="identifier">i</span> <span class="special">-</span> <span class="special">+</span><span class="identifier">i</span><span class="special">)</span>
    <span class="special">);</span>

    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">display_expr</span><span class="special">(</span>
        <span class="identifier">RemoveUnaryPlus</span><span class="special">()(</span> <span class="special">+</span><span class="identifier">i</span> <span class="special">-</span> <span class="special">+(</span><span class="identifier">i</span> <span class="special">-</span> <span class="special">+</span><span class="identifier">i</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            The above code displays the following, which shows that unary plus nodes
            have been stripped from the expression:
          </p>
<pre class="programlisting">minus(
    unary_plus(
        terminal(0)
    )
  , unary_plus(
        minus(
            terminal(0)
          , unary_plus(
                terminal(0)
            )
        )
    )
)
minus(
    terminal(0)
  , minus(
        terminal(0)
      , terminal(0)
    )
)
</pre>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2008 Eric Niebler<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="external_transforms.html"><img src="../../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../expression_transformation.html"><img src="../../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../index.html"><img src="../../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="primitives.html"><img src="../../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
