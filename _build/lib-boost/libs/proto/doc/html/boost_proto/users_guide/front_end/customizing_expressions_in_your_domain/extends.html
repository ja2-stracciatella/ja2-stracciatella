<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>The extends&lt;&gt; Expression Wrapper</title>
<link rel="stylesheet" href="../../../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../../../index.html" title="Chapter&#160;1.&#160;Boost.Proto">
<link rel="up" href="../customizing_expressions_in_your_domain.html" title="Customizing Expressions in Your Domain">
<link rel="prev" href="domains.html" title="Domains">
<link rel="next" href="expression_generators.html" title="Expression Generators">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="domains.html"><img src="../../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../customizing_expressions_in_your_domain.html"><img src="../../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../index.html"><img src="../../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="expression_generators.html"><img src="../../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends"></a><a class="link" href="extends.html" title="The extends&lt;&gt; Expression Wrapper">The
          <code class="literal">extends&lt;&gt;</code> Expression Wrapper</a>
</h5></div></div></div>
<p>
            The first step to giving your calculator expressions extra behaviors
            is to define a calculator domain. All expressions within the calculator
            domain will be imbued with calculator-ness, as we'll see.
          </p>
<pre class="programlisting"><span class="comment">// A type to be used as a domain tag (to be defined below)</span>
<span class="keyword">struct</span> <span class="identifier">calculator_domain</span><span class="special">;</span>
</pre>
<p>
            We use this domain type when extending the <code class="computeroutput"><a class="link" href="../../../../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>
            type, which we do with the <code class="computeroutput"><a class="link" href="../../../../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            class template. Here is our expression wrapper, which imbues an expression
            with calculator-ness. It is described below.
          </p>
<pre class="programlisting"><span class="comment">// The calculator&lt;&gt; expression wrapper makes expressions</span>
<span class="comment">// function objects.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">Expr</span> <span class="special">&gt;,</span> <span class="identifier">calculator_domain</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">Expr</span> <span class="special">&gt;,</span> <span class="identifier">calculator_domain</span> <span class="special">&gt;</span>
    <span class="identifier">base_type</span><span class="special">;</span>

    <span class="identifier">calculator</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">Expr</span><span class="special">()</span> <span class="special">)</span>
      <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span> <span class="identifier">expr</span> <span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// This is usually needed because by default, the compiler-</span>
    <span class="comment">// generated assignment operator hides extends&lt;&gt;::operator=</span>
    <span class="identifier">BOOST_PROTO_EXTENDS_USING_ASSIGN</span><span class="special">(</span><span class="identifier">calculator</span><span class="special">)</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Hide base_type::operator() by defining our own which</span>
    <span class="comment">// evaluates the calculator expression with a calculator context.</span>
    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.0</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">// As defined in the Hello Calculator section.</span>
        <span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>

        <span class="comment">// ctx.args is a vector&lt;double&gt; that holds the values</span>
        <span class="comment">// with which we replace the placeholders (e.g., _1 and _2)</span>
        <span class="comment">// in the expression.</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">d1</span> <span class="special">);</span> <span class="comment">// _1 gets the value of d1</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">d2</span> <span class="special">);</span> <span class="comment">// _2 gets the value of d2</span>

        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span> <span class="special">);</span> <span class="comment">// evaluate the expression</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            We want calculator expressions to be function objects, so we have to
            define an <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            that takes and returns doubles. The <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> wrapper above does that with
            the help of the <code class="computeroutput"><a class="link" href="../../../../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            template. The first template to <code class="computeroutput"><a class="link" href="../../../../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            parameter is the expression type we are extending. The second is the
            type of the wrapped expression. The third parameter is the domain that
            this wrapper is associated with. A wrapper type like <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> that inherits from <code class="computeroutput"><a class="link" href="../../../../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code> behaves just like
            the expression type it has extended, with any additional behaviors you
            choose to give it.
          </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
              <span class="bold"><strong>Why not just inherit from <code class="literal">proto::expr&lt;&gt;</code>?</strong></span>
            </p>
<p>
              You might be thinking that this expression extension business is unnecessarily
              complicated. After all, isn't this why C++ supports inheritance? Why
              can't <code class="literal">calculator&lt;Expr&gt;</code> just inherit from
              <code class="literal">Expr</code> directly? The reason is because <code class="literal">Expr</code>,
              which presumably is an instantiation of <code class="computeroutput"><a class="link" href="../../../../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>,
              has expression template-building operator overloads that will be incorrect
              for derived types. They will store <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by reference to <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;&gt;</span></code>, effectively slicing off any
              derived parts. <code class="computeroutput"><a class="link" href="../../../../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
              gives your derived types operator overloads that don't slice off your
              additional members.
            </p>
</td></tr>
</table></div>
<p>
            Although not strictly necessary in this case, we bring <code class="computeroutput"><span class="identifier">extends</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">=</span></code>
            into scope with the <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS_USING_ASSIGN</span><span class="special">()</span></code> macro. This is really only necessary
            if you want expressions like <code class="computeroutput"><span class="identifier">_1</span>
            <span class="special">=</span> <span class="number">3</span></code>
            to create a lazily evaluated assignment. <code class="computeroutput"><a class="link" href="../../../../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            defines the appropriate <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code> for you, but the compiler-generated
            <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">=</span></code>
            will hide it unless you make it available with the macro.
          </p>
<p>
            Note that in the implementation of <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">()</span></code>, we evaluate the expression with the
            <code class="computeroutput"><span class="identifier">calculator_context</span></code> we
            defined earlier. As we saw before, the context is what gives the operators
            their meaning. In the case of the calculator, the context is also what
            defines the meaning of the placeholder terminals.
          </p>
<p>
            Now that we have defined the <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> expression wrapper, we need to
            wrap the placeholders to imbue them with calculator-ness:
          </p>
<pre class="programlisting"><span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span><span class="special">;</span>
<span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span><span class="special">;</span>
</pre>
<h6>
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends.h0"></a>
            <span><a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends.retaining_pod_ness_with__literal_boost_proto_extends____literal_"></a></span><a class="link" href="extends.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends.retaining_pod_ness_with__literal_boost_proto_extends____literal_">Retaining
            POD-ness with <code class="literal">BOOST_PROTO_EXTENDS()</code></a>
          </h6>
<p>
            To use <code class="computeroutput"><a class="link" href="../../../../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>, your extension type
            must derive from <code class="computeroutput"><a class="link" href="../../../../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>.
            Unfortunately, that means that your extension type is no longer POD and
            its instances cannot be <span class="emphasis"><em>statically initialized</em></span>.
            (See the <a class="link" href="../../../appendices/rationale/static_initialization.html" title="Static Initialization">Static
            Initialization</a> section in the <a class="link" href="../../../appendices/rationale.html" title="Appendix C: Rationale">Rationale</a>
            appendix for why this matters.) In particular, as defined above, the
            global placeholder objects <code class="computeroutput"><span class="identifier">_1</span></code>
            and <code class="computeroutput"><span class="identifier">_2</span></code> will need to be
            initialized at runtime, which could lead to subtle order of initialization
            bugs.
          </p>
<p>
            There is another way to make an expression extension that doesn't sacrifice
            POD-ness : the <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>
            macro. You can use it much like you use <code class="computeroutput"><a class="link" href="../../../../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>.
            We can use <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>
            to keep <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>
            a POD and our placeholders statically initialized.
          </p>
<pre class="programlisting"><span class="comment">// The calculator&lt;&gt; expression wrapper makes expressions</span>
<span class="comment">// function objects.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
<span class="special">{</span>
    <span class="comment">// Use BOOST_PROTO_EXTENDS() instead of proto::extends&lt;&gt; to</span>
    <span class="comment">// make this type a Proto expression extension.</span>
    <span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">(</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">)</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.0</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">/* ... as before ... */</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            With the new <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> type, we can redefine our placeholders
            to be statically initialized:
          </p>
<pre class="programlisting"><span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{{}}};</span>
<span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span> <span class="special">=</span> <span class="special">{{{}}};</span>
</pre>
<p>
            We need to make one additional small change to accommodate the POD-ness
            of our expression extension, which we'll describe below in the section
            on expression generators.
          </p>
<p>
            What does <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>
            do? It defines a data member of the expression type being extended; some
            nested typedefs that Proto requires; <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>, <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code> and <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> overloads for building expression templates;
            and a nested <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
            template for calculating the return type of <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>. In this case, however, the <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            overloads and the <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code> template are not needed because
            we are defining our own <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> in the <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> type. Proto provides additional
            macros for finer control over which member functions are defined. We
            could improve our <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> type as follows:
          </p>
<pre class="programlisting"><span class="comment">// The calculator&lt;&gt; expression wrapper makes expressions</span>
<span class="comment">// function objects.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
<span class="special">{</span>
    <span class="comment">// Use BOOST_PROTO_BASIC_EXTENDS() instead of proto::extends&lt;&gt; to</span>
    <span class="comment">// make this type a Proto expression extension:</span>
    <span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">(</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">)</span>

    <span class="comment">// Define operator[] to build expression templates:</span>
    <span class="identifier">BOOST_PROTO_EXTENDS_SUBSCRIPT</span><span class="special">()</span>

    <span class="comment">// Define operator= to build expression templates:</span>
    <span class="identifier">BOOST_PROTO_EXTENDS_ASSIGN</span><span class="special">()</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.0</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">/* ... as before ... */</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Notice that we are now using <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code>()</code>
            instead of <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>.
            This just adds the data member and the nested typedefs but not any of
            the overloaded operators. Those are added separately with <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS_ASSIGN.html" title="Macro BOOST_PROTO_EXTENDS_ASSIGN">BOOST_PROTO_EXTENDS_ASSIGN</a></code>()</code>
            and <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS_SUBSCRIPT.html" title="Macro BOOST_PROTO_EXTENDS_SUBSCRIPT">BOOST_PROTO_EXTENDS_SUBSCRIPT</a></code>()</code>.
            We are leaving out the function call operator and the nested <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
            template that could have been defined with Proto's <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS_FUNCTION.html" title="Macro BOOST_PROTO_EXTENDS_FUNCTION">BOOST_PROTO_EXTENDS_FUNCTION</a></code>()</code>
            macro.
          </p>
<p>
            In summary, here are the macros you can use to define expression extensions,
            and a brief description of each.
          </p>
<div class="table">
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends.t0"></a><p class="title"><b>Table&#160;1.2.&#160;Expression Extension Macros</b></p>
<div class="table-contents"><table class="table" summary="Expression Extension Macros">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      Macro
                    </p>
                  </th>
<th>
                    <p>
                      Purpose
                    </p>
                  </th>
</tr></thead>
<tbody>
<tr>
<td>
                    <p>
</p>
<pre class="programlisting"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code><span class="special">(</span>
    <em class="replaceable"><code>expression</code></em>
  <span class="special">,</span> <em class="replaceable"><code>extension</code></em>
  <span class="special">,</span> <em class="replaceable"><code>domain</code></em>
<span class="special">)</span></pre>
<p>
                    </p>
                  </td>
<td>
                    <p>
                      Defines a data member of type <code class="computeroutput"><em class="replaceable"><code>expression</code></em></code>
                      and some nested typedefs that Proto requires.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS_ASSIGN.html" title="Macro BOOST_PROTO_EXTENDS_ASSIGN">BOOST_PROTO_EXTENDS_ASSIGN</a></code>()</code>
                    </p>
                  </td>
<td>
                    <p>
                      Defines <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>. Only valid when preceded
                      by <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code>()</code>.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS_SUBSCRIPT.html" title="Macro BOOST_PROTO_EXTENDS_SUBSCRIPT">BOOST_PROTO_EXTENDS_SUBSCRIPT</a></code>()</code>
                    </p>
                  </td>
<td>
                    <p>
                      Defines <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>. Only valid when preceded
                      by <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code>()</code>.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS_FUNCTION.html" title="Macro BOOST_PROTO_EXTENDS_FUNCTION">BOOST_PROTO_EXTENDS_FUNCTION</a></code>()</code>
                    </p>
                  </td>
<td>
                    <p>
                      Defines <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> and a nested <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
                      template for return type calculation. Only valid when preceded
                      by <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code>()</code>.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
</p>
<pre class="programlisting"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code><span class="special">(</span>
    <em class="replaceable"><code>expression</code></em>
  <span class="special">,</span> <em class="replaceable"><code>extension</code></em>
  <span class="special">,</span> <em class="replaceable"><code>domain</code></em>
<span class="special">)</span></pre>
<p>
                    </p>
                  </td>
<td>
                    <p>
                      Equivalent to:
</p>
<pre class="programlisting"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code><span class="special">(</span><em class="replaceable"><code>expression</code></em><span class="special">,</span> <em class="replaceable"><code>extension</code></em><span class="special">,</span> <em class="replaceable"><code>domain</code></em><span class="special">)</span>

  <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS_ASSIGN.html" title="Macro BOOST_PROTO_EXTENDS_ASSIGN">BOOST_PROTO_EXTENDS_ASSIGN</a></code>()</code>

  <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS_SUBSCRIPT.html" title="Macro BOOST_PROTO_EXTENDS_SUBSCRIPT">BOOST_PROTO_EXTENDS_SUBSCRIPT</a></code>()</code>

  <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS_FUNCTION.html" title="Macro BOOST_PROTO_EXTENDS_FUNCTION">BOOST_PROTO_EXTENDS_FUNCTION</a></code>()</code></pre>
<p>
                    </p>
                  </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../../../../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
              <span class="bold"><strong>Argument-Dependent Lookup and <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code></strong></span>
            </p>
<p>
              Proto's operator overloads are defined in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
              namespace and are found by argument-dependent lookup (ADL). This usually
              just works because expressions are made up of types that live in the
              <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code> namespace. However, sometimes
              when you use <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>
              that is not the case. Consider:
            </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">my_complex</span>
<span class="special">{</span>
    <span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">(</span>
        <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">,</span> <span class="identifier">my_complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_domain</span>
    <span class="special">)</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">my_complex</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">c0</span><span class="special">,</span> <span class="identifier">c1</span><span class="special">;</span>

    <span class="identifier">c0</span> <span class="special">+</span> <span class="identifier">c1</span><span class="special">;</span> <span class="comment">// ERROR: operator+ not found</span>
<span class="special">}</span>
</pre>
<p>
            </p>
<p>
              The problem has to do with how argument-dependent lookup works. The
              type <code class="computeroutput"><span class="identifier">my_complex</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>
              is not associated in any way with the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
              namespace, so the operators defined there are not considered. (Had
              we inherited from <code class="computeroutput"><a class="link" href="../../../../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
              instead of used <code class="literal"><code class="computeroutput"><a class="link" href="../../../../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>,
              we would have avoided the problem because inheriting from a type in
              <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code> namespace is enough to get
              ADL to kick in.)
            </p>
<p>
              So what can we do? By adding an extra dummy template parameter that
              defaults to a type in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
              namespace, we can trick ADL into finding the right operator overloads.
              The solution looks like this:
            </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Dummy</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_proto_expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">my_complex</span>
<span class="special">{</span>
    <span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">(</span>
        <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">,</span> <span class="identifier">my_complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_domain</span>
    <span class="special">)</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">my_complex</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">c0</span><span class="special">,</span> <span class="identifier">c1</span><span class="special">;</span>

    <span class="identifier">c0</span> <span class="special">+</span> <span class="identifier">c1</span><span class="special">;</span> <span class="comment">// OK, operator+ found now!</span>
<span class="special">}</span>
</pre>
<p>
            </p>
<p>
              The type <code class="computeroutput"><a class="link" href="../../../../boost/proto/is_proto_expr.html" title="Struct is_proto_expr">proto::is_proto_expr</a></code> is nothing
              but an empty struct, but by making it a template parameter we make
              <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code> an associated namespace of
              <code class="computeroutput"><span class="identifier">my_complex</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>.
              Now ADL can successfully find Proto's operator overloads.
            </p>
</td></tr>
</table></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2008 Eric Niebler<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="domains.html"><img src="../../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../customizing_expressions_in_your_domain.html"><img src="../../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../index.html"><img src="../../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="expression_generators.html"><img src="../../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
