<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Hello Calculator</title>
<link rel="stylesheet" href="../../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../../index.html" title="Chapter&#160;1.&#160;Boost.Proto">
<link rel="up" href="../getting_started.html" title="Getting Started">
<link rel="prev" href="hello_world.html" title="Hello World">
<link rel="next" href="../front_end.html" title="Fronts Ends: Defining Terminals and Non-Terminals of Your EDSL">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="hello_world.html"><img src="../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../getting_started.html"><img src="../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../front_end.html"><img src="../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.getting_started.hello_calculator"></a><a class="link" href="hello_calculator.html" title="Hello Calculator">Hello
        Calculator</a>
</h4></div></div></div>
<p>
          "Hello, world" is nice, but it doesn't get you very far. Let's
          use Proto to build a EDSL (embedded domain-specific language) for a lazily-evaluated
          calculator. We'll see how to define the terminals in your mini-language,
          how to compose them into larger expressions, and how to define an evaluation
          context so that your expressions can do useful work. When we're done, we'll
          have a mini-language that will allow us to declare a lazily-evaluated arithmetic
          expression, such as <code class="computeroutput"><span class="special">(</span><span class="identifier">_2</span>
          <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span>
          <span class="special">*</span> <span class="number">100</span></code>,
          where <code class="computeroutput"><span class="identifier">_1</span></code> and <code class="computeroutput"><span class="identifier">_2</span></code> are placeholders for values to be
          passed in when the expression is evaluated.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h0"></a>
          <span><a name="boost_proto.users_guide.getting_started.hello_calculator.defining_terminals"></a></span><a class="link" href="hello_calculator.html#boost_proto.users_guide.getting_started.hello_calculator.defining_terminals">Defining
          Terminals</a>
        </h6>
<p>
          The first order of business is to define the placeholders <code class="computeroutput"><span class="identifier">_1</span></code> and <code class="computeroutput"><span class="identifier">_2</span></code>.
          For that, we'll use the <code class="computeroutput"><a class="link" href="../../../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code>
          metafunction.
        </p>
<pre class="programlisting"><span class="comment">// Define a placeholder type</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">placeholder</span>
<span class="special">{};</span>

<span class="comment">// Define the Protofied placeholder terminals</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{}};</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_2</span> <span class="special">=</span> <span class="special">{{}};</span>
</pre>
<p>
          The initialization may look a little odd at first, but there is a good
          reason for doing things this way. The objects <code class="computeroutput"><span class="identifier">_1</span></code>
          and <code class="computeroutput"><span class="identifier">_2</span></code> above do not require
          run-time construction -- they are <span class="emphasis"><em>statically initialized</em></span>,
          which means they are essentially initialized at compile time. See the
          <a class="link" href="../../appendices/rationale/static_initialization.html" title="Static Initialization">Static
          Initialization</a> section in the <a class="link" href="../../appendices/rationale.html" title="Appendix C: Rationale">Rationale</a>
          appendix for more information.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h1"></a>
          <span><a name="boost_proto.users_guide.getting_started.hello_calculator.constructing_expression_trees"></a></span><a class="link" href="hello_calculator.html#boost_proto.users_guide.getting_started.hello_calculator.constructing_expression_trees">Constructing
          Expression Trees</a>
        </h6>
<p>
          Now that we have terminals, we can use Proto's operator overloads to combine
          these terminals into larger expressions. So, for instance, we can immediately
          say things like:
        </p>
<pre class="programlisting"><span class="comment">// This builds an expression template</span>
<span class="special">(</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">;</span>
</pre>
<p>
          This creates an expression tree with a node for each operator. The type
          of the resulting object is large and complex, but we are not terribly interested
          in it right now.
        </p>
<p>
          So far, the object is just a tree representing the expression. It has no
          behavior. In particular, it is not yet a calculator. Below we'll see how
          to make it a calculator by defining an evaluation context.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h2"></a>
          <span><a name="boost_proto.users_guide.getting_started.hello_calculator.evaluating_expression_trees"></a></span><a class="link" href="hello_calculator.html#boost_proto.users_guide.getting_started.hello_calculator.evaluating_expression_trees">Evaluating
          Expression Trees</a>
        </h6>
<p>
          No doubt you want your expression templates to actually <span class="emphasis"><em>do</em></span>
          something. One approach is to define an <span class="emphasis"><em>evaluation context</em></span>.
          The context is like a function object that associates behaviors with the
          node types in your expression tree. The following example should make it
          clear. It is explained below.
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">calculator_context</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span> <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// Values to replace the placeholders</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">args</span><span class="special">;</span>

    <span class="comment">// Define the result type of the calculator.</span>
    <span class="comment">// (This makes the calculator_context "callable".)</span>
    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Handle the placeholders:</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">args</span><span class="special">[</span><span class="identifier">I</span><span class="special">];</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          In <code class="computeroutput"><span class="identifier">calculator_context</span></code>,
          we specify how Proto should evaluate the placeholder terminals by defining
          the appropriate overloads of the function call operator. For any other
          nodes in the expression tree (e.g., arithmetic operations or non-placeholder
          terminals), Proto will evaluate the expression in the "default"
          way. For example, a binary plus node is evaluated by first evaluating the
          left and right operands and adding the results. Proto's default evaluator
          uses the <a href="../../../../../libs/typeof/index.html" target="_top">Boost.Typeof</a>
          library to compute return types.
        </p>
<p>
          Now that we have an evaluation context for our calculator, we can use it
          to evaluate our arithmetic expressions, as below:
        </p>
<pre class="programlisting"><span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
<span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">45</span><span class="special">);</span> <span class="comment">// the value of _1 is 45</span>
<span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">50</span><span class="special">);</span> <span class="comment">// the value of _2 is 50</span>

<span class="comment">// Create an arithmetic expression and immediately evaluate it</span>
<span class="keyword">double</span> <span class="identifier">d</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span> <span class="special">(</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">,</span> <span class="identifier">ctx</span> <span class="special">);</span>

<span class="comment">// This prints "10"</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">d</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
          Later, we'll see how to define more interesting evaluation contexts and
          expression transforms that give you total control over how your expressions
          are evaluated.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h3"></a>
          <span><a name="boost_proto.users_guide.getting_started.hello_calculator.customizing_expression_trees"></a></span><a class="link" href="hello_calculator.html#boost_proto.users_guide.getting_started.hello_calculator.customizing_expression_trees">Customizing
          Expression Trees</a>
        </h6>
<p>
          Our calculator EDSL is already pretty useful, and for many EDSL scenarios,
          no more would be needed. But let's keep going. Imagine how much nicer it
          would be if all calculator expressions overloaded <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> so that they could be used as function
          objects. We can do that by creating a calculator <span class="emphasis"><em>domain</em></span>
          and telling Proto that all expressions in the calculator domain have extra
          members. Here is how to define a calculator domain:
        </p>
<pre class="programlisting"><span class="comment">// Forward-declare an expression wrapper</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span><span class="special">;</span>

<span class="comment">// Define a calculator domain. Expression within</span>
<span class="comment">// the calculator domain will be wrapped in the</span>
<span class="comment">// calculator&lt;&gt; expression wrapper.</span>
<span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">calculator</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
          The <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>
          type will be an expression wrapper. It will behave just like the expression
          that it wraps, but it will have extra member functions that we will define.
          The <code class="computeroutput"><span class="identifier">calculator_domain</span></code> is
          what informs Proto about our wrapper. It is used below in the definition
          of <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>.
          Read on for a description.
        </p>
<pre class="programlisting"><span class="comment">// Define a calculator expression wrapper. It behaves just like</span>
<span class="comment">// the expression it wraps, but with an extra operator() member</span>
<span class="comment">// function that evaluates the expression.    </span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
    <span class="identifier">base_type</span><span class="special">;</span>

    <span class="identifier">calculator</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">Expr</span><span class="special">())</span>
      <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Overload operator() to invoke proto::eval() with</span>
    <span class="comment">// our calculator_context.</span>
    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="identifier">a1</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">a2</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">a1</span><span class="special">);</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">a2</span><span class="special">);</span>

        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          The <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>
          struct is an expression <span class="emphasis"><em>extension</em></span>. It uses <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;&gt;</span></code>
          to effectively add additional members to an expression type. When composing
          larger expressions from smaller ones, Proto notes what domain the smaller
          expressions are in. The larger expression is in the same domain and is
          automatically wrapped in the domain's extension wrapper.
        </p>
<p>
          All that remains to be done is to put our placeholders in the calculator
          domain. We do that by wrapping them in our <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> wrapper, as below:
        </p>
<pre class="programlisting"><span class="comment">// Define the Protofied placeholder terminals, in the</span>
<span class="comment">// calculator domain.</span>
<span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span><span class="special">;</span>
<span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span><span class="special">;</span>
</pre>
<p>
          Any larger expression that contain these placeholders will automatically
          be wrapped in the <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> wrapper and have our <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
          overload. That means we can use them as function objects as follows.
        </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">result</span> <span class="special">=</span> <span class="special">((</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">)(</span><span class="number">45.0</span><span class="special">,</span> <span class="number">50.0</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="special">(</span><span class="number">50.0</span> <span class="special">-</span> <span class="number">45.0</span><span class="special">)</span> <span class="special">/</span> <span class="number">50.0</span> <span class="special">*</span> <span class="number">100</span><span class="special">));</span>
</pre>
<p>
          Since calculator expressions are now valid function objects, we can use
          them with standard algorithms, as shown below:
        </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">a1</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">56</span><span class="special">,</span> <span class="number">84</span><span class="special">,</span> <span class="number">37</span><span class="special">,</span> <span class="number">69</span> <span class="special">};</span>
<span class="keyword">double</span> <span class="identifier">a2</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">65</span><span class="special">,</span> <span class="number">120</span><span class="special">,</span> <span class="number">60</span><span class="special">,</span> <span class="number">70</span> <span class="special">};</span>
<span class="keyword">double</span> <span class="identifier">a3</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">0</span> <span class="special">};</span>

<span class="comment">// Use std::transform() and a calculator expression</span>
<span class="comment">// to calculate percentages given two input sequences:</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">a1</span><span class="special">,</span> <span class="identifier">a1</span><span class="special">+</span><span class="number">4</span><span class="special">,</span> <span class="identifier">a2</span><span class="special">,</span> <span class="identifier">a3</span><span class="special">,</span> <span class="special">(</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">);</span>
</pre>
<p>
          Now, let's use the calculator example to explore some other useful features
          of Proto.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h4"></a>
          <span><a name="boost_proto.users_guide.getting_started.hello_calculator.detecting_invalid_expressions"></a></span><a class="link" href="hello_calculator.html#boost_proto.users_guide.getting_started.hello_calculator.detecting_invalid_expressions">Detecting
          Invalid Expressions</a>
        </h6>
<p>
          You may have noticed that you didn't have to define an overloaded <code class="computeroutput"><span class="keyword">operator</span><span class="special">-()</span></code>
          or <code class="computeroutput"><span class="keyword">operator</span><span class="special">/()</span></code>
          -- Proto defined them for you. In fact, Proto overloads <span class="emphasis"><em>all</em></span>
          the operators for you, even though they may not mean anything in your domain-specific
          language. That means it may be possible to create expressions that are
          invalid in your domain. You can detect invalid expressions with Proto by
          defining the <span class="emphasis"><em>grammar</em></span> of your domain-specific language.
        </p>
<p>
          For simplicity, assume that our calculator EDSL should only allow addition,
          subtraction, multiplication and division. Any expression involving any
          other operator is invalid. Using Proto, we can state this requirement by
          defining the grammar of the calculator EDSL. It looks as follows:
        </p>
<pre class="programlisting"><span class="comment">// Define the grammar of calculator expressions</span>
<span class="keyword">struct</span> <span class="identifier">calculator_grammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
          You can read the above grammar as follows: an expression tree conforms
          to the calculator grammar if it is a binary plus, minus, multiplies or
          divides node, where both child nodes also conform to the calculator grammar;
          or if it is a terminal. In a Proto grammar, <code class="computeroutput"><a class="link" href="../../../boost/proto/_.html" title="Struct _">proto::_</a></code> is a wildcard that matches
          any type, so <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span>
          <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span></code>
          matches any terminal, whether it is a placeholder or a literal.
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            This grammar is actually a little looser than we would like. Only placeholders
            and literals that are convertible to doubles are valid terminals. Later
            on we'll see how to express things like that in Proto grammars.
          </p></td></tr>
</table></div>
<p>
          Once you have defined the grammar of your EDSL, you can use the <code class="computeroutput"><a class="link" href="../../../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code> metafunction to check
          whether a given expression type conforms to the grammar. For instance,
          we might add the following to our <code class="computeroutput"><span class="identifier">calculator</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> overload:
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span> <span class="comment">/* ... as before ... */</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">/* ... */</span>
    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="identifier">a1</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">a2</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">// Check here that the expression we are about to</span>
        <span class="comment">// evaluate actually conforms to the calculator grammar.</span>
        <span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator_grammar</span><span class="special">&gt;));</span>
        <span class="comment">/* ... */</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          The addition of the <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code> line enforces at compile time that we
          only evaluate expressions that conform to the calculator EDSL's grammar.
          With Proto grammars, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code> and <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code> it is very easy to give the users of
          your EDSL short and readable compile-time errors when they accidentally
          misuse your EDSL.
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code>
            is part of the Boost Metaprogramming Library. To use it, just <code class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="identifier">assert</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>.
          </p></td></tr>
</table></div>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h5"></a>
          <span><a name="boost_proto.users_guide.getting_started.hello_calculator.controlling_operator_overloads"></a></span><a class="link" href="hello_calculator.html#boost_proto.users_guide.getting_started.hello_calculator.controlling_operator_overloads">Controlling
          Operator Overloads</a>
        </h6>
<p>
          Grammars and <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code>
          make it possible to detect when a user has created an invalid expression
          and issue a compile-time error. But what if you want to prevent users from
          creating invalid expressions in the first place? By using grammars and
          domains together, you can disable any of Proto's operator overloads that
          would create an invalid expression. It is as simple as specifying the EDSL's
          grammar when you define the domain, as shown below:
        </p>
<pre class="programlisting"><span class="comment">// Define a calculator domain. Expression within</span>
<span class="comment">// the calculator domain will be wrapped in the</span>
<span class="comment">// calculator&lt;&gt; expression wrapper.</span>
<span class="comment">// NEW: Any operator overloads that would create an</span>
<span class="comment">//      expression that does not conform to the</span>
<span class="comment">//      calculator grammar is automatically disabled.</span>
<span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">calculator</span><span class="special">&gt;,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
          The only thing we changed is we added <code class="computeroutput"><span class="identifier">calculator_grammar</span></code>
          as the second template parameter to the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code> template when defining <code class="computeroutput"><span class="identifier">calculator_domain</span></code>. With this simple addition,
          we disable any of Proto's operator overloads that would create an invalid
          calculator expression.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h6"></a>
          <span><a name="boost_proto.users_guide.getting_started.hello_calculator.____and_much_more"></a></span><a class="link" href="hello_calculator.html#boost_proto.users_guide.getting_started.hello_calculator.____and_much_more">...
          And Much More</a>
        </h6>
<p>
          Hopefully, this gives you an idea of what sorts of things Proto can do
          for you. But this only scratches the surface. The rest of this users' guide
          will describe all these features and others in more detail.
        </p>
<p>
          Happy metaprogramming!
        </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2008 Eric Niebler<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="hello_world.html"><img src="../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../getting_started.html"><img src="../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../front_end.html"><img src="../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
