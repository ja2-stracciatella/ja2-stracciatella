<?xml version="1.0" standalone="yes"?>
<library-reference id="utilities"><title>Utilities</title><header name="boost/log/utility/exception_handler.hpp">
<para><para>Andrey Semashev </para>
<para>12.07.2009</para>
This header contains tools for exception handlers support in different parts of the library. </para><namespace name="boost">
<namespace name="log">
<class name="exception_handler"><template>
      <template-type-parameter name="SequenceT"/>
      <template-type-parameter name="HandlerT"/>
    </template><description><para>An exception handler functional object. The handler aggregates a user-defined functional object that will be called when one of the specified exception types is caught. </para></description><typedef name="handler_type"><purpose>The exception handler type. </purpose><type>HandlerT</type></typedef>
<typedef name="result_type"><purpose>The handler result type. </purpose><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><description><para>Exception launcher. Rethrows the current exception in order to detect its type and pass it to the aggregated function object.</para><para><note><para>Must be called from within a <computeroutput>catch</computeroutput> statement. </para></note>
</para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="handler"><paramtype>handler_type const &amp;</paramtype></parameter><description><para>Initializing constructor. Creates an exception handler with the specified function object that will receive the exception. </para></description></constructor>
</class><class name="nothrow_exception_handler"><template>
      <template-type-parameter name="SequenceT"/>
      <template-type-parameter name="HandlerT"/>
    </template><inherit access="public">boost::log::exception_handler&lt; SequenceT, HandlerT &gt;</inherit><description><para>A no-throw exception handler functional object. Acts similar to <computeroutput><classname alt="boost::log::exception_handler">exception_handler</classname></computeroutput>, but in case if the exception cannot be handled the exception is not propagated from the handler. Instead the user-defined functional object is called with no parameters. </para></description><typedef name="handler_type"><purpose>The exception handler type. </purpose><type>HandlerT</type></typedef>
<typedef name="result_type"><purpose>The handler result type. </purpose><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><description><para>Exception launcher. Rethrows the current exception in order to detect its type and pass it to the aggregated function object. If the type of the exception could not be detected, the user-defined handler is called with no arguments.</para><para><note><para>Must be called from within a <computeroutput>catch</computeroutput> statement. </para></note>
</para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="handler"><paramtype>handler_type const &amp;</paramtype></parameter><description><para>Initializing constructor. Creates an exception handler with the specified function object that will receive the exception. </para></description></constructor>
</class>































<function name="make_exception_suppressor"><type><classname>nop</classname></type><description><para>The function creates an empty exception handler that effectively suppresses any exception </para></description></function>
<function name="make_exception_handler"><type><classname>exception_handler</classname>&lt; typename HandlerT::exception_types, HandlerT &gt;</type><template>
          <template-type-parameter name="HandlerT"/>
        </template><parameter name="handler"><paramtype>HandlerT const &amp;</paramtype><description><para>User-defined functional object that will receive exceptions. </para></description></parameter><description><para>The function creates an exception handler functional object. The handler will call to the user-specified functional object with an exception as its argument.</para><para>

<note><para>This form requires the user-defined functional object to have an <computeroutput>exception_types</computeroutput> nested type. This type should be an MPL sequence of all expected exception types. </para></note>
</para></description><returns><para>A nullary functional object that should be called from within a <computeroutput>catch</computeroutput> statement.</para></returns></function>
<function name="make_exception_handler"><type><classname>nothrow_exception_handler</classname>&lt; typename HandlerT::exception_types, HandlerT &gt;</type><template>
          <template-type-parameter name="HandlerT"/>
        </template><parameter name="handler"><paramtype>HandlerT const &amp;</paramtype><description><para>User-defined functional object that will receive exceptions. </para></description></parameter><parameter name=""><paramtype>std::nothrow_t const &amp;</paramtype></parameter><description><para>The function creates an exception handler functional object. The handler will call to the user-specified functional object with an exception as its argument. If the exception type cannot be identified, the handler will call the user-defined functor with no arguments, instead of propagating exception to the caller.</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

<note><para>This form requires the user-defined functional object to have an <computeroutput>exception_types</computeroutput> nested type. This type should be an MPL sequence of all expected exception types. </para></note>
</para></description><returns><para>A nullary functional object that should be called from within a <computeroutput>catch</computeroutput> statement.</para></returns></function>
<function name="make_exception_handler"><type><classname>exception_handler</classname>&lt; MPL_sequence_of_ExceptionsT, HandlerT &gt;</type><template>
          <template-nontype-parameter name="ExceptionsT"><type>typename...</type></template-nontype-parameter>
          <template-type-parameter name="HandlerT"/>
        </template><parameter name="handler"><paramtype>HandlerT const &amp;</paramtype><description><para>User-defined functional object that will receive exceptions. </para></description></parameter><description><para>The function creates an exception handler functional object. The handler will call to the user-specified functional object with an exception as its argument. All expected exception types should be specified as first template parameters explicitly, in the order they would be specified in a corresponding <computeroutput>try/catch</computeroutput> statement.</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

</para></description><returns><para>A nullary functional object that should be called from within a <computeroutput>catch</computeroutput> statement. </para></returns></function>
<function name="make_exception_handler"><type><classname>nothrow_exception_handler</classname>&lt; MPL_sequence_of_ExceptionsT, HandlerT &gt;</type><template>
          <template-nontype-parameter name="ExceptionsT"><type>typename...</type></template-nontype-parameter>
          <template-type-parameter name="HandlerT"/>
        </template><parameter name="handler"><paramtype>HandlerT const &amp;</paramtype><description><para>User-defined functional object that will receive exceptions. </para></description></parameter><parameter name=""><paramtype>std::nothrow_t const &amp;</paramtype></parameter><description><para>The function creates an exception handler functional object. The handler will call to the user-specified functional object with an exception as its argument. If the exception type cannot be identified, the handler will call the user-defined functor with no arguments, instead of propagating exception to the caller. All expected exception types should be specified as first template parameters explicitly, in the order they would be specified in a corresponding <computeroutput>try/catch</computeroutput> statement.</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

</para></description><returns><para>A nullary functional object that should be called from within a <computeroutput>catch</computeroutput> statement. </para></returns></function>




























































</namespace>
</namespace>
<macro name="BOOST_LOG_MAX_EXCEPTION_TYPES"><purpose>Maximum number of exception types that can be specified for exception handlers. </purpose></macro>
</header>
<header name="boost/log/utility/formatting_ostream.hpp">
<para><para>Andrey Semashev </para>
<para>11.07.2012</para>
The header contains implementation of a string stream used for log record formatting. </para><namespace name="boost">
<namespace name="log">
<class name="basic_formatting_ostream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="TraitsT"/>
      <template-type-parameter name="AllocatorT"/>
    </template><purpose>Stream wrapper for log records formatting. </purpose><description><para>This stream wrapper is used by the library for log record formatting. It implements the standard string stream interface with a few differences:</para><para><itemizedlist>
<listitem><para>It does not derive from standard types <computeroutput>std::basic_ostream</computeroutput>, <computeroutput>std::basic_ios</computeroutput> and <computeroutput>std::ios_base</computeroutput>, although it tries to implement their interfaces closely. There are a few small differences, mostly regarding <computeroutput>rdbuf</computeroutput> and <computeroutput>str</computeroutput> signatures, as well as the supported insertion operator overloads. The actual wrapped stream can be accessed through the <computeroutput>stream</computeroutput> methods. </para></listitem>
<listitem><para>By default, <computeroutput>bool</computeroutput> values are formatted using alphabetical representation rather than numeric. </para></listitem>
<listitem><para>The stream supports writing strings of character types different from the stream character type. The stream will perform character code conversion as needed using the imbued locale. </para></listitem>
<listitem><para>The stream operates on an external string object rather than on the embedded one. The string can be attached or detached from the stream dynamically.</para></listitem>
</itemizedlist>
Although <computeroutput><classname alt="boost::log::basic_formatting_ostream">basic_formatting_ostream</classname></computeroutput> does not derive from <computeroutput>std::basic_ostream</computeroutput>, users are not required to add special overloads of <computeroutput>operator&lt;&lt;</computeroutput> for it since the stream will by default reuse the operators for <computeroutput>std::basic_ostream</computeroutput>. However, one can define special overloads of <computeroutput>operator&lt;&lt;</computeroutput> for <computeroutput><classname alt="boost::log::basic_formatting_ostream">basic_formatting_ostream</classname></computeroutput> if a certain type needs special formatting when output to log. </para></description><class name="sentry"><method-group name="public member functions">
<method name="conversion-operator" cv="const" specifiers="explicit"><type>bool</type></method>
<method name="operator!" cv="const"><type>bool</type></method>
</method-group>
<constructor specifiers="explicit"><parameter name="strm"><paramtype><classname>basic_formatting_ostream</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name=""><paramtype>sentry const &amp;</paramtype></parameter></constructor>
<copy-assignment><type>sentry &amp;</type><parameter name=""><paramtype>sentry const &amp;</paramtype></parameter></copy-assignment>
</class><typedef name="char_type"><purpose>Character type. </purpose><type>CharT</type></typedef>
<typedef name="traits_type"><purpose>Character traits. </purpose><type>TraitsT</type></typedef>
<typedef name="allocator_type"><purpose>Memory allocator. </purpose><type>AllocatorT</type></typedef>
<typedef name="streambuf_type"><purpose>Stream buffer type. </purpose><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="string_type"><purpose>Target string type. </purpose><type>streambuf_type::string_type</type></typedef>
<typedef name="ostream_type"><purpose>Stream type. </purpose><type>std::basic_ostream&lt; char_type, traits_type &gt;</type></typedef>
<typedef name="pos_type"><purpose>Stream position type. </purpose><type>ostream_type::pos_type</type></typedef>
<typedef name="off_type"><purpose>Stream offset type. </purpose><type>ostream_type::off_type</type></typedef>
<typedef name="int_type"><purpose>Integer type for characters. </purpose><type>ostream_type::int_type</type></typedef>
<typedef name="failure"><type>ostream_type::failure</type></typedef>
<typedef name="fmtflags"><type>ostream_type::fmtflags</type></typedef>
<typedef name="iostate"><type>ostream_type::iostate</type></typedef>
<typedef name="openmode"><type>ostream_type::openmode</type></typedef>
<typedef name="seekdir"><type>ostream_type::seekdir</type></typedef>
<typedef name="Init"><type>ostream_type::Init</type></typedef>
<typedef name="event"><type>ostream_type::event</type></typedef>
<typedef name="event_callback"><type>ostream_type::event_callback</type></typedef>
<data-member name="boolalpha" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="dec" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="fixed" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="hex" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="internal" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="left" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="oct" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="right" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="scientific" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="showbase" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="showpoint" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="skipws" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="unitbuf" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="uppercase" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="adjustfield" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="basefield" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="floatfield" specifiers="static"><type>constexpr fmtflags</type></data-member>
<data-member name="badbit" specifiers="static"><type>constexpr iostate</type></data-member>
<data-member name="eofbit" specifiers="static"><type>constexpr iostate</type></data-member>
<data-member name="failbit" specifiers="static"><type>constexpr iostate</type></data-member>
<data-member name="goodbit" specifiers="static"><type>constexpr iostate</type></data-member>
<data-member name="app" specifiers="static"><type>constexpr openmode</type></data-member>
<data-member name="ate" specifiers="static"><type>constexpr openmode</type></data-member>
<data-member name="binary" specifiers="static"><type>constexpr openmode</type></data-member>
<data-member name="in" specifiers="static"><type>constexpr openmode</type></data-member>
<data-member name="out" specifiers="static"><type>constexpr openmode</type></data-member>
<data-member name="trunc" specifiers="static"><type>constexpr openmode</type></data-member>
<data-member name="beg" specifiers="static"><type>constexpr seekdir</type></data-member>
<data-member name="cur" specifiers="static"><type>constexpr seekdir</type></data-member>
<data-member name="end" specifiers="static"><type>constexpr seekdir</type></data-member>
<data-member name="erase_event" specifiers="static"><type>constexpr event</type></data-member>
<data-member name="imbue_event" specifiers="static"><type>constexpr event</type></data-member>
<data-member name="copyfmt_event" specifiers="static"><type>constexpr event</type></data-member>
<method-group name="public member functions">
<method name="attach"><type>void</type><parameter name="str"><paramtype>string_type &amp;</paramtype><description><para>The string buffer to attach. </para></description></parameter><description><para>Attaches the stream to the string. The string will be used to store the formatted characters.</para><para>
</para></description></method>
<method name="detach"><type>void</type><description><para>Detaches the stream from the string. Any buffered data is flushed to the string. </para></description></method>
<method name="str" cv="const"><type>string_type const &amp;</type><description><para>
</para></description><returns><para>Reference to the attached string. The string must be attached before calling this method. </para></returns></method>
<method name="stream"><type>ostream_type &amp;</type><description><para>
</para></description><returns><para>Reference to the wrapped stream </para></returns></method>
<method name="stream" cv="const"><type>ostream_type const &amp;</type><description><para>
</para></description><returns><para>Reference to the wrapped stream </para></returns></method>
<method name="flags" cv="const"><type>fmtflags</type></method>
<method name="flags"><type>fmtflags</type><parameter name="f"><paramtype>fmtflags</paramtype></parameter></method>
<method name="setf"><type>fmtflags</type><parameter name="f"><paramtype>fmtflags</paramtype></parameter></method>
<method name="setf"><type>fmtflags</type><parameter name="f"><paramtype>fmtflags</paramtype></parameter><parameter name="mask"><paramtype>fmtflags</paramtype></parameter></method>
<method name="unsetf"><type>void</type><parameter name="f"><paramtype>fmtflags</paramtype></parameter></method>
<method name="precision" cv="const"><type>std::streamsize</type></method>
<method name="precision"><type>std::streamsize</type><parameter name="p"><paramtype>std::streamsize</paramtype></parameter></method>
<method name="width" cv="const"><type>std::streamsize</type></method>
<method name="width"><type>std::streamsize</type><parameter name="w"><paramtype>std::streamsize</paramtype></parameter></method>
<method name="getloc" cv="const"><type>std::locale</type></method>
<method name="imbue"><type>std::locale</type><parameter name="loc"><paramtype>std::locale const &amp;</paramtype></parameter></method>
<method name="iword"><type>long &amp;</type><parameter name="index"><paramtype>int</paramtype></parameter></method>
<method name="pword"><type>void *&amp;</type><parameter name="index"><paramtype>int</paramtype></parameter></method>
<method name="register_callback"><type>void</type><parameter name="fn"><paramtype>event_callback</paramtype></parameter><parameter name="index"><paramtype>int</paramtype></parameter></method>
<method name="conversion-operator" cv="const" specifiers="explicit"><type>bool</type></method>
<method name="operator!" cv="const"><type>bool</type></method>
<method name="rdstate" cv="const"><type>iostate</type></method>
<method name="clear"><type>void</type><parameter name="state"><paramtype>iostate</paramtype><default>goodbit</default></parameter></method>
<method name="setstate"><type>void</type><parameter name="state"><paramtype>iostate</paramtype></parameter></method>
<method name="good" cv="const"><type>bool</type></method>
<method name="eof" cv="const"><type>bool</type></method>
<method name="fail" cv="const"><type>bool</type></method>
<method name="bad" cv="const"><type>bool</type></method>
<method name="exceptions" cv="const"><type>iostate</type></method>
<method name="exceptions"><type>void</type><parameter name="s"><paramtype>iostate</paramtype></parameter></method>
<method name="tie" cv="const"><type>ostream_type *</type></method>
<method name="tie"><type>ostream_type *</type><parameter name="strm"><paramtype>ostream_type *</paramtype></parameter></method>
<method name="rdbuf" cv="const"><type>streambuf_type *</type></method>
<method name="copyfmt"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="rhs"><paramtype>std::basic_ios&lt; char_type, traits_type &gt; &amp;</paramtype></parameter></method>
<method name="copyfmt"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="rhs"><paramtype><classname>basic_formatting_ostream</classname> &amp;</paramtype></parameter></method>
<method name="fill" cv="const"><type>char_type</type></method>
<method name="fill"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype></parameter></method>
<method name="narrow" cv="const"><type>char</type><parameter name="ch"><paramtype>char_type</paramtype></parameter><parameter name="def"><paramtype>char</paramtype></parameter></method>
<method name="widen" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char</paramtype></parameter></method>
<method name="flush"><type><classname>basic_formatting_ostream</classname> &amp;</type></method>
<method name="tellp"><type>pos_type</type></method>
<method name="seekp"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="pos"><paramtype>pos_type</paramtype></parameter></method>
<method name="seekp"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="off"><paramtype>off_type</paramtype></parameter><parameter name="dir"><paramtype>std::ios_base::seekdir</paramtype></parameter></method>
<method name="put"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="c"><paramtype>char_type</paramtype></parameter></method>
<method name="put"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="OtherCharT"/>
        </template><parameter name="c"><paramtype>OtherCharT</paramtype></parameter></method>
<method name="write"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const char_type *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
<method name="write"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="OtherCharT"/>
        </template><parameter name="p"><paramtype>const OtherCharT *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="manip"><paramtype>ios_base_manip</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="manip"><paramtype>basic_ios_manip</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="manip"><paramtype>stream_manip</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="c"><paramtype>char</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const char *</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="c"><paramtype>wchar_t</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const wchar_t *</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="c"><paramtype>char16_t</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const char16_t *</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="c"><paramtype>char32_t</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const char32_t *</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>bool</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>signed char</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>unsigned char</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>short</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>unsigned short</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>int</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>unsigned int</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>long</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>unsigned long</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>long long</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>unsigned long long</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>float</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>double</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>long double</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>const void *</paramtype></parameter></method>
<method name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="buf"><paramtype>std::basic_streambuf&lt; char_type, traits_type &gt; *</paramtype></parameter></method>
</method-group>
<constructor><description><para>Default constructor. Creates an empty record that is equivalent to the invalid record handle. The stream capability is not available after construction.</para><para>
</para></description><postconditions><para><computeroutput>!*this == true</computeroutput> </para></postconditions></constructor>
<constructor specifiers="explicit"><parameter name="str"><paramtype>string_type &amp;</paramtype><description><para>The string buffer to attach. </para></description></parameter><description><para>Initializing constructor. Attaches the string to the constructed stream. The string will be used to store the formatted characters.</para><para>

</para></description><postconditions><para><computeroutput>!*this == false</computeroutput> </para></postconditions></constructor>
<destructor><description><para>Destructor. Destroys the record, releases any sinks and attribute values that were involved in processing this record. </para></description></destructor>
<method-group name="public static functions">
<method name="xalloc" specifiers="static"><type>int</type></method>
<method name="sync_with_stdio" specifiers="static"><type>bool</type><parameter name="sync"><paramtype>bool</paramtype><default>true</default></parameter></method>
</method-group>
<method-group name="private member functions">
<method name="init_stream"><type>void</type></method>
<method name="formatted_write"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const char_type *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
<method name="formatted_write"><type><classname>basic_formatting_ostream</classname> &amp;</type><template>
          <template-type-parameter name="OtherCharT"/>
        </template><parameter name="p"><paramtype>const OtherCharT *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
<method name="aligned_write"><type>void</type><parameter name="p"><paramtype>const char_type *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
<method name="aligned_write"><type>void</type><template>
          <template-type-parameter name="OtherCharT"/>
        </template><parameter name="p"><paramtype>const OtherCharT *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
</method-group>
<constructor><parameter name="that"><paramtype><classname>basic_formatting_ostream</classname> const &amp;</paramtype></parameter><purpose>Copy constructor (closed) </purpose></constructor>
<copy-assignment><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="that"><paramtype><classname>basic_formatting_ostream</classname> const &amp;</paramtype></parameter><purpose>Assignment (closed) </purpose></copy-assignment>
</class>




































<function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="value"><paramtype>T const &amp;</paramtype></parameter></function>
<function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="value"><paramtype>T &amp;</paramtype></parameter></function>
<function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;&amp;</paramtype></parameter><parameter name="value"><paramtype>T const &amp;</paramtype></parameter></function>
<function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;&amp;</paramtype></parameter><parameter name="value"><paramtype>T &amp;</paramtype></parameter></function>
























































</namespace>
</namespace>
</header>
<header name="boost/log/utility/formatting_ostream_fwd.hpp">
<para><para>Andrey Semashev </para>
<para>11.07.2012</para>
The header contains forward declaration of a string stream used for log record formatting. </para><namespace name="boost">
<namespace name="log">
<typedef name="formatting_ostream"><type><classname>basic_formatting_ostream</classname>&lt; char &gt;</type></typedef>
<typedef name="wformatting_ostream"><type><classname>basic_formatting_ostream</classname>&lt; wchar_t &gt;</type></typedef>

































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header includes all functional helpers. </para></header>
<header name="boost/log/utility/functional/as_action.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains function object adapter for compatibility with Boost.Spirit actions interface requirements. </para><namespace name="boost">
<namespace name="log">
<struct name="as_action_adapter"><template>
      <template-type-parameter name="FunT"/>
    </template><purpose>Function object adapter for Boost.Spirit actions. </purpose><typedef name="result_type"><type>FunT::result_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="AttributeT"/>
          <template-type-parameter name="ContextT"/>
        </template><parameter name="attr"><paramtype>AttributeT const &amp;</paramtype></parameter><parameter name="ctx"><paramtype>ContextT const &amp;</paramtype></parameter><parameter name="pass"><paramtype>bool &amp;</paramtype></parameter></method>
</method-group>
<constructor/>
<constructor specifiers="explicit"><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter></constructor>
</struct>






































































<function name="as_action"><type><classname>as_action_adapter</classname>&lt; FunT &gt;</type><template>
          <template-type-parameter name="FunT"/>
        </template><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter></function>

























</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/begins_with.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains a predicate for checking if the provided string begins with a substring. </para><namespace name="boost">
<namespace name="log">
<struct name="begins_with_fun"><purpose>The <computeroutput>begins_with</computeroutput> functor. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
</struct>
































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/bind.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains function object adapters. This is a lightweight alternative to what Boost.Phoenix and Boost.Bind provides. </para><namespace name="boost">
<namespace name="log">
<struct name="binder1st"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="FirstArgT"/>
    </template><purpose>First argument binder. </purpose><typedef name="result_type"><type>FunT::result_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type></method>
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter></method>
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
</struct><struct-specialization name="binder1st"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="FirstArgT"/>
    </template><specialization><template-arg>FunT &amp;</template-arg><template-arg>FirstArgT</template-arg></specialization><purpose>First argument binder. </purpose><typedef name="result_type"><type>remove_cv&lt; FunT &gt;::type::result_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type></method>
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter></method>
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="fun"><paramtype>FunT &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
</struct-specialization><struct name="binder2nd"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="SecondArgT"/>
    </template><purpose>Second argument binder. </purpose><typedef name="result_type"><type>FunT::result_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="arg"><paramtype>T const &amp;</paramtype></parameter></method>
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
</struct><struct-specialization name="binder2nd"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="SecondArgT"/>
    </template><specialization><template-arg>FunT &amp;</template-arg><template-arg>SecondArgT</template-arg></specialization><purpose>Second argument binder. </purpose><typedef name="result_type"><type>remove_cv&lt; FunT &gt;::type::result_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="arg"><paramtype>T const &amp;</paramtype></parameter></method>
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="fun"><paramtype>FunT &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
</struct-specialization><struct name="binder3rd"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="ThirdArgT"/>
    </template><purpose>Third argument binder. </purpose><typedef name="result_type"><type>FunT::result_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
</struct><struct-specialization name="binder3rd"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="ThirdArgT"/>
    </template><specialization><template-arg>FunT &amp;</template-arg><template-arg>ThirdArgT</template-arg></specialization><purpose>Third argument binder. </purpose><typedef name="result_type"><type>remove_cv&lt; FunT &gt;::type::result_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="fun"><paramtype>FunT &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
</struct-specialization>












































































<function name="bind1st"><type><classname>binder1st</classname>&lt; FunT, FirstArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="FirstArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>FirstArgT const &amp;</paramtype></parameter></function>
<function name="bind1st"><type><classname>binder1st</classname>&lt; FunT, FirstArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="FirstArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>FirstArgT &amp;</paramtype></parameter></function>
<function name="bind2nd"><type><classname>binder2nd</classname>&lt; FunT, SecondArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="SecondArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>SecondArgT const &amp;</paramtype></parameter></function>
<function name="bind2nd"><type><classname>binder2nd</classname>&lt; FunT, SecondArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="SecondArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>SecondArgT &amp;</paramtype></parameter></function>
<function name="bind3rd"><type><classname>binder3rd</classname>&lt; FunT, ThirdArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="ThirdArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>ThirdArgT const &amp;</paramtype></parameter></function>
<function name="bind3rd"><type><classname>binder3rd</classname>&lt; FunT, ThirdArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="ThirdArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>ThirdArgT &amp;</paramtype></parameter></function>














</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/bind_assign.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains a function object that assigns the received value to the bound object. This is a lightweight alternative to what Boost.Phoenix and Boost.Lambda provides. </para><namespace name="boost">
<namespace name="log">
<struct name="assign_fun"><purpose>The function object that assigns its second operand to the first one. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="LeftT"/>
          <template-type-parameter name="RightT"/>
        </template><parameter name="assignee"><paramtype>LeftT &amp;</paramtype></parameter><parameter name="val"><paramtype>RightT const &amp;</paramtype></parameter></method>
</method-group>
</struct>





































































<function name="bind_assign"><type><classname>binder1st</classname>&lt; <classname>assign_fun</classname>, AssigneeT &amp; &gt;</type><template>
          <template-type-parameter name="AssigneeT"/>
        </template><parameter name="assignee"><paramtype>AssigneeT &amp;</paramtype></parameter></function>


























</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/bind_output.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains a function object that puts the received value to the bound stream. This is a lightweight alternative to what Boost.Phoenix and Boost.Lambda provides. </para><namespace name="boost">
<namespace name="log">
<struct name="output_fun"><purpose>The function object that outputs its second operand to the first one. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="val"><paramtype>T const &amp;</paramtype></parameter></method>
</method-group>
</struct>








































































<function name="bind_output"><type><classname>binder1st</classname>&lt; <classname>output_fun</classname>, StreamT &amp; &gt;</type><template>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter></function>























</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/bind_to_log.hpp">
<para><para>Andrey Semashev </para>
<para>06.11.2012</para>
This header contains a function object that puts the received value to the bound stream using the <computeroutput>to_log</computeroutput> manipulator. This is a lightweight alternative to what Boost.Phoenix and Boost.Lambda provides. </para><namespace name="boost">
<namespace name="log">
<struct name="to_log_fun"><template>
      <template-type-parameter name="TagT"><default>void</default></template-type-parameter>
    </template><purpose>The function object that outputs its second operand to the first one. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="val"><paramtype>T const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct-specialization name="to_log_fun"><template>
    </template><specialization><template-arg>void</template-arg></specialization><purpose>The function object that outputs its second operand to the first one. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="val"><paramtype>T const &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization>










































































<function name="bind_to_log"><type><classname>binder1st</classname>&lt; <classname>to_log_fun</classname>&lt;  &gt;, StreamT &amp; &gt;</type><template>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter></function>
<function name="bind_to_log"><type><classname>binder1st</classname>&lt; <classname>to_log_fun</classname>&lt; TagT &gt;, StreamT &amp; &gt;</type><template>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter></function>




















</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/contains.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains a predicate for checking if the provided string contains a substring. </para><namespace name="boost">
<namespace name="log">
<struct name="contains_fun"><purpose>The <computeroutput>contains</computeroutput> functor. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
</struct>
































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/ends_with.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains a predicate for checking if the provided string ends with a substring. </para><namespace name="boost">
<namespace name="log">
<struct name="ends_with_fun"><purpose>The <computeroutput>ends_with</computeroutput> functor. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
</struct>
































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/fun_ref.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains function object reference adapter. The adapter stores a reference to external function object and forwards all calls to the referred function. </para><namespace name="boost">
<namespace name="log">
<struct name="function_reference_wrapper"><template>
      <template-type-parameter name="FunT"/>
    </template><purpose>Reference wrapper for function objects. </purpose><typedef name="result_type"><type>FunT::result_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type></method>
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-nontype-parameter name="ArgsT"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>ArgsT const &amp;...</paramtype></parameter></method>
</method-group>
<constructor specifiers="explicit"><parameter name="fun"><paramtype>FunT &amp;</paramtype></parameter></constructor>
</struct>









































































<function name="fun_ref"><type><classname>function_reference_wrapper</classname>&lt; FunT &gt;</type><template>
          <template-type-parameter name="FunT"/>
        </template><parameter name="fun"><paramtype>FunT &amp;</paramtype></parameter></function>






















</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/in_range.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains a predicate for checking if the provided value is within a half-open range. </para><namespace name="boost">
<namespace name="log">
<struct name="in_range_fun"><purpose>The in_range functor. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="value"><paramtype>T const &amp;</paramtype></parameter><parameter name="rng"><paramtype>std::pair&lt; U, U &gt; const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="value"><paramtype>T const &amp;</paramtype></parameter><parameter name="rng"><paramtype>std::pair&lt; U, U &gt; const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_ const &amp;</paramtype></parameter></method>
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="value"><paramtype>T const &amp;</paramtype></parameter><parameter name="rng"><paramtype>std::pair&lt; U, U &gt; const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_ const &amp;</paramtype></parameter></method>
</method-group>
</struct>
































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/logical.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains logical predicates for value comparison, analogous to <computeroutput>std::less</computeroutput>, <computeroutput>std::greater</computeroutput> and others. The main difference from the standard equivalents is that the predicates defined in this header are not templates and therefore do not require a fixed argument type. Furthermore, both arguments may have different types, in which case the comparison is performed without type conversion.</para><para><note><para>In case if arguments are integral, the conversion is performed according to the standard C++ rules in order to avoid warnings from the compiler. </para></note>
</para><namespace name="boost">
<namespace name="log">
<struct name="equal_to"><purpose>Equality predicate. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_ const &amp;</paramtype></parameter></method>
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_ const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="not_equal_to"><purpose>Inequality predicate. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_ const &amp;</paramtype></parameter></method>
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_ const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="less"><purpose>Less predicate. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_ const &amp;</paramtype></parameter></method>
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_ const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="greater"><purpose>Greater predicate. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_ const &amp;</paramtype></parameter></method>
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_ const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="less_equal"><purpose>Less or equal predicate. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_ const &amp;</paramtype></parameter></method>
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_ const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="greater_equal"><purpose>Greater or equal predicate. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_ const &amp;</paramtype></parameter></method>
<method name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_ const &amp;</paramtype></parameter></method>
</method-group>
</struct>
































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/matches.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains a predicate for checking if the provided string matches a regular expression. </para><namespace name="boost">
<namespace name="log">
<struct name="matches_fun"><purpose>The regex matching functor. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="StringT"/>
          <template-type-parameter name="ExpressionT"/>
        </template><parameter name="str"><paramtype>StringT const &amp;</paramtype></parameter><parameter name="expr"><paramtype>ExpressionT const &amp;</paramtype></parameter></method>
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="StringT"/>
          <template-type-parameter name="ExpressionT"/>
          <template-type-parameter name="ArgT"/>
        </template><parameter name="str"><paramtype>StringT const &amp;</paramtype></parameter><parameter name="expr"><paramtype>ExpressionT const &amp;</paramtype></parameter><parameter name="arg"><paramtype>ArgT const &amp;</paramtype></parameter></method>
</method-group>
</struct>
































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/nop.hpp">
<para><para>Andrey Semashev </para>
<para>30.03.2008</para>
This header contains a function object that does nothing. </para><namespace name="boost">
<namespace name="log">
<struct name="nop"><purpose>The function object that does nothing. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const noexcept"><type>void</type></method>
<method name="operator()" cv="const noexcept"><type>void</type><template>
          <template-nontype-parameter name="ArgsT"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="..."><paramtype>ArgsT const &amp;</paramtype></parameter></method>
</method-group>
</struct>
































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/functional/save_result.hpp">
<para><para>Andrey Semashev </para>
<para>19.01.2013</para>
This header contains function object adapter that saves the result of the adopted function to an external variable. </para><namespace name="boost">
<namespace name="log">
<struct name="save_result_wrapper"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="AssigneeT"/>
    </template><purpose>Function object wrapper for saving the adopted function object result. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="ArgT"/>
        </template><parameter name="arg"><paramtype>ArgT const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="assignee"><paramtype>AssigneeT &amp;</paramtype></parameter></constructor>
</struct>







































































<function name="save_result"><type><classname>save_result_wrapper</classname>&lt; FunT, AssigneeT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="AssigneeT"/>
        </template><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><parameter name="assignee"><paramtype>AssigneeT &amp;</paramtype></parameter></function>
























</namespace>
</namespace>
</header>
<header name="boost/log/utility/manipulators.hpp">
<para><para>Andrey Semashev </para>
<para>06.11.2012</para>
This header includes all manipulators. </para></header>
<header name="boost/log/utility/manipulators/add_value.hpp">
<para><para>Andrey Semashev </para>
<para>26.11.2012</para>
This header contains the <computeroutput>add_value</computeroutput> manipulator. </para><namespace name="boost">
<namespace name="log">
<class name="add_value_manip"><template>
      <template-type-parameter name="RefT"/>
    </template><purpose>Attribute value manipulator. </purpose><typedef name="reference_type"><purpose>Stored reference type. </purpose><type>RefT</type></typedef>
<typedef name="value_type"><purpose>Attribute value type. </purpose><type>remove_cv&lt; typename remove_reference&lt; reference_type &gt;::type &gt;::type</type></typedef>
<method-group name="public member functions">
<method name="get_name" cv="const"><type>attribute_name</type><purpose>Returns attribute name. </purpose></method>
<method name="get_value" cv="const"><type>get_value_result_type</type><purpose>Returns attribute value. </purpose></method>
</method-group>
<constructor><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="value"><paramtype>reference_type</paramtype></parameter><purpose>Initializing constructor. </purpose></constructor>
</class>



























































































<function name="operator&lt;&lt;"><type>basic_record_ostream&lt; CharT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="RefT"/>
        </template><parameter name="strm"><paramtype>basic_record_ostream&lt; CharT &gt; &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>add_value_manip</classname>&lt; RefT &gt; const &amp;</paramtype></parameter><purpose>The operator attaches an attribute value to the log record. </purpose></function>
<overloaded-function name="add_value"><signature><type><classname>add_value_manip</classname>&lt; T &amp;&amp; &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="value"><paramtype>T &amp;&amp;</paramtype></parameter></signature><signature><type><classname>add_value_manip</classname>&lt; typename DescriptorT::value_type &amp;&amp; &gt;</type><template>
          <template-type-parameter name="DescriptorT"/>
          <template-nontype-parameter name="ActorT"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>expressions::attribute_keyword&lt; DescriptorT, ActorT &gt; const &amp;</paramtype></parameter><parameter name="value"><paramtype>typename DescriptorT::value_type &amp;&amp;</paramtype></parameter></signature><signature><type><classname>add_value_manip</classname>&lt; typename DescriptorT::value_type &amp; &gt;</type><template>
          <template-type-parameter name="DescriptorT"/>
          <template-nontype-parameter name="ActorT"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>expressions::attribute_keyword&lt; DescriptorT, ActorT &gt; const &amp;</paramtype></parameter><parameter name="value"><paramtype>typename DescriptorT::value_type &amp;</paramtype></parameter></signature><signature><type><classname>add_value_manip</classname>&lt; typename DescriptorT::value_type const &amp; &gt;</type><template>
          <template-type-parameter name="DescriptorT"/>
          <template-nontype-parameter name="ActorT"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>expressions::attribute_keyword&lt; DescriptorT, ActorT &gt; const &amp;</paramtype></parameter><parameter name="value"><paramtype>typename DescriptorT::value_type const &amp;</paramtype></parameter></signature><purpose>The function creates a manipulator that attaches an attribute value to a log record. </purpose></overloaded-function>



</namespace>
</namespace>
</header>
<header name="boost/log/utility/manipulators/dump.hpp">
<para><para>Andrey Semashev </para>
<para>03.05.2013</para>
This header contains the <computeroutput>dump</computeroutput> output manipulator. </para><namespace name="boost">
<namespace name="log">
<class name="dump_manip"><purpose>Manipulator for printing binary representation of the data. </purpose><method-group name="public member functions">
<method name="get_data" cv="const noexcept"><type>const void *</type></method>
<method name="get_size" cv="const noexcept"><type>std::size_t</type></method>
</method-group>
<constructor cv="noexcept"><parameter name="data"><paramtype>const void *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter></constructor>
<constructor cv="noexcept"><parameter name="that"><paramtype><classname>dump_manip</classname> const &amp;</paramtype></parameter></constructor>
</class><class name="bounded_dump_manip"><inherit access="public">dump_manip</inherit><purpose>Manipulator for printing binary representation of the data with a size limit. </purpose><method-group name="public member functions">
<method name="get_max_size" cv="const noexcept"><type>std::size_t</type></method>
</method-group>
<constructor cv="noexcept"><parameter name="data"><paramtype>const void *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="max_size"><paramtype>std::size_t</paramtype></parameter></constructor>
<constructor cv="noexcept"><parameter name="that"><paramtype><classname>bounded_dump_manip</classname> const &amp;</paramtype></parameter></constructor>
</class>


















































































<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
        </template><parameter name="strm"><paramtype>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>dump_manip</classname> const &amp;</paramtype></parameter><purpose>The operator outputs binary data to a stream. </purpose></function>
<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
        </template><parameter name="strm"><paramtype>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>bounded_dump_manip</classname> const &amp;</paramtype></parameter><purpose>The operator outputs binary data to a stream. </purpose></function>
<function name="dump"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="data"><paramtype>T *</paramtype><description><para>The pointer to the beginning of the region </para></description></parameter><parameter name="size"><paramtype>std::size_t</paramtype><description><para>The size of the region, in bytes </para></description></parameter><purpose>Creates a stream manipulator that will output contents of a memory region in hexadecimal form. </purpose><description><para>

</para></description><returns><para>The manipulator that is to be put to a stream </para></returns></function>
<function name="dump_elements"><type><classname>dump_manip</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="data"><paramtype>T *</paramtype><description><para>The pointer to the beginning of the array </para></description></parameter><parameter name="count"><paramtype>std::size_t</paramtype><description><para>The size of the region, in number of <computeroutput>T</computeroutput> elements </para></description></parameter><purpose>Creates a stream manipulator that will dump elements of an array in hexadecimal form. </purpose><description><para>

</para></description><returns><para>The manipulator that is to be put to a stream </para></returns></function>
<function name="dump"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="data"><paramtype>T *</paramtype><description><para>The pointer to the beginning of the region </para></description></parameter><parameter name="size"><paramtype>std::size_t</paramtype><description><para>The size of the region, in bytes  max_size The maximum number of bytes of the region to output </para></description></parameter><parameter name="max_size"><paramtype>std::size_t</paramtype></parameter><purpose>Creates a stream manipulator that will output contents of a memory region in hexadecimal form. </purpose><description><para>

</para></description><returns><para>The manipulator that is to be put to a stream </para></returns></function>
<function name="dump_elements"><type><classname>bounded_dump_manip</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="data"><paramtype>T *</paramtype><description><para>The pointer to the beginning of the array </para></description></parameter><parameter name="count"><paramtype>std::size_t</paramtype><description><para>The size of the region, in number of <computeroutput>T</computeroutput> elements  max_count The maximum number of elements to output </para></description></parameter><parameter name="max_count"><paramtype>std::size_t</paramtype></parameter><purpose>Creates a stream manipulator that will dump elements of an array in hexadecimal form. </purpose><description><para>

</para></description><returns><para>The manipulator that is to be put to a stream </para></returns></function>








</namespace>
</namespace>
</header>
<header name="boost/log/utility/manipulators/to_log.hpp">
<para><para>Andrey Semashev </para>
<para>06.11.2012</para>
This header contains the <computeroutput>to_log</computeroutput> output manipulator. </para><namespace name="boost">
<namespace name="log">
<class name="to_log_manip"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="TagT"><default>void</default></template-type-parameter>
    </template><purpose>Generic manipulator for customizing output to log. </purpose><typedef name="value_type"><purpose>Output value type. </purpose><type>T</type></typedef>
<typedef name="tag_type"><purpose>Value tag type. </purpose><type>TagT</type></typedef>
<method-group name="public member functions">
<method name="get" cv="const noexcept"><type>value_type const &amp;</type></method>
</method-group>
<constructor specifiers="explicit" cv="noexcept"><parameter name="value"><paramtype>value_type const &amp;</paramtype></parameter></constructor>
<constructor cv="noexcept"><parameter name="that"><paramtype><classname>to_log_manip</classname> const &amp;</paramtype></parameter></constructor>
</class>
























































































<function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>to_log_manip</classname>&lt; T, TagT &gt;</paramtype></parameter></function>
<function name="to_log"><type><classname>to_log_manip</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>T const &amp;</paramtype></parameter></function>
<function name="to_log"><type><classname>to_log_manip</classname>&lt; T, TagT &gt;</type><template>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>T const &amp;</paramtype></parameter></function>





</namespace>
</namespace>
</header>
<header name="boost/log/utility/once_block.hpp">
<para>The header defines classes and macros for once-blocks. </para><para><para>Andrey Semashev </para>
<para>23.06.2010 </para>
</para><namespace name="boost">
<namespace name="log">
<struct name="once_block_flag"><purpose>A flag to detect if a code block has already been executed. </purpose><description><para>This structure should be used in conjunction with the <computeroutput>BOOST_LOG_ONCE_BLOCK_FLAG</computeroutput> macro. Usage example:</para><para><computeroutput> <classname alt="boost::log::once_block_flag">once_block_flag</classname> flag = BOOST_LOG_ONCE_BLOCK_INIT;</computeroutput></para><para><computeroutput> void foo() { BOOST_LOG_ONCE_BLOCK_FLAG(flag) { puts("Hello, world once!"); } } </computeroutput> </para></description></struct>
































































































</namespace>
</namespace>
<macro name="BOOST_LOG_ONCE_BLOCK_INIT"><description><para>The static initializer for <computeroutput>once_block_flag</computeroutput>. </para></description></macro>
<macro name="BOOST_LOG_ONCE_BLOCK_FLAG" kind="functionlike"><macro-parameter name="flag_var"/><description><para>Begins a code block to be executed only once, with protection against thread concurrency. User has to provide the flag variable that controls whether the block has already been executed. </para></description></macro>
<macro name="BOOST_LOG_ONCE_BLOCK" kind="functionlike"><macro-parameter name=""/><description><para>Begins a code block to be executed only once, with protection against thread concurrency. </para></description></macro>
</header>
<header name="boost/log/utility/record_ordering.hpp">
<para><para>Andrey Semashev </para>
<para>23.08.2009</para>
This header contains ordering predicates for logging records. </para><namespace name="boost">
<namespace name="log">
<class name="abstract_ordering"><template>
      <template-type-parameter name="FunT"><default><classname alt="boost::log::less">less</classname></default></template-type-parameter>
    </template><purpose>Ordering predicate, based on opaque pointers to the record view implementation data. </purpose><description><para>Since record views only refer to a shared implementation data, this predicate is able to order the views by comparing the pointers to the data. Therefore two views are considered to be equivalent if they refer to the same implementation data. Otherwise it is not specified whether one record is ordered before the other until the predicate is applied. Note that the ordering may change every time the application runs.</para><para>This kind of ordering may be useful if log records are to be stored in an associative container with as least performance overhead as possible, when the particular order is not important.</para><para>The <computeroutput>FunT</computeroutput> template argument is the predicate that is used to actually compare pointers. It should be able to compare <computeroutput>const void*</computeroutput> pointers. The compared pointers may refer to distinct memory regions, the pointers must not be interpreted in any way. </para></description><typedef name="result_type"><purpose>Result type. </purpose><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>record_view const &amp;</paramtype></parameter><parameter name="right"><paramtype>record_view const &amp;</paramtype></parameter><description><para>Ordering operator </para></description></method>
</method-group>
<constructor><description><para>Default constructor. Requires <computeroutput>FunT</computeroutput> to be default constructible. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><description><para>Initializing constructor. Constructs <computeroutput>FunT</computeroutput> instance as a copy of the <emphasis>fun</emphasis> argument. </para></description></constructor>
</class><class name="attribute_value_ordering"><template>
      <template-type-parameter name="ValueT"/>
      <template-type-parameter name="FunT"><default><classname alt="boost::log::less">less</classname></default></template-type-parameter>
    </template><purpose>Ordering predicate, based on attribute values associated with records. </purpose><description><para>This predicate allows to order log records based on values of a specifically named attribute associated with them. Two given log records being compared should both have the specified attribute value of the specified type to be able to be ordered properly. As a special case, if neither of the records have the value, these records are considered equivalent. Otherwise, the ordering results are unspecified. </para></description><struct name="l1_visitor"><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="LeftT"/>
        </template><parameter name="left"><paramtype>LeftT const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="owner"><paramtype><classname>attribute_value_ordering</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype>record_view const &amp;</paramtype></parameter><parameter name="result"><paramtype>bool &amp;</paramtype></parameter></constructor>
</struct><struct name="l2_visitor"><template>
      <template-type-parameter name="LeftT"/>
    </template><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="RightT"/>
        </template><parameter name="right"><paramtype>RightT const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><parameter name="left"><paramtype>LeftT const &amp;</paramtype></parameter><parameter name="result"><paramtype>bool &amp;</paramtype></parameter></constructor>
</struct><typedef name="result_type"><purpose>Result type. </purpose><type>bool</type></typedef>
<typedef name="value_type"><purpose>Compared attribute value type. </purpose><type>ValueT</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>record_view const &amp;</paramtype></parameter><parameter name="right"><paramtype>record_view const &amp;</paramtype></parameter><description><para>Ordering operator </para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>The attribute value name to be compared </para></description></parameter><parameter name="fun"><paramtype>FunT const &amp;</paramtype><default>FunT()</default><description><para>The ordering functor </para></description></parameter><description><para>Initializing constructor.</para><para>
</para></description></constructor>
</class>


























<function name="make_attr_ordering"><type><classname>attribute_value_ordering</classname>&lt; ValueT, FunT &gt;</type><template>
          <template-type-parameter name="ValueT"/>
          <template-type-parameter name="FunT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><description><para>The function constructs a log record ordering predicate </para></description></function>
<function name="make_attr_ordering"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="FunT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><description><para>The function constructs a log record ordering predicate </para></description></function>




































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/setup.hpp">
<para><para>Andrey Semashev </para>
<para>16.02.2013</para>
This header includes all library setup helpers. </para></header>
<header name="boost/log/utility/setup/common_attributes.hpp">
<para><para>Andrey Semashev </para>
<para>16.05.2008</para>
The header contains implementation of convenience functions for registering commonly used attributes. </para><namespace name="boost">
<namespace name="log">

























































<function name="add_common_attributes"><type>void</type><purpose>Simple attribute initialization routine. </purpose><description><para>The function adds commonly used attributes to the logging system. Specifically, the following attributes are registered globally:</para><para><itemizedlist>
<listitem><para>LineID - logging records counter with value type <computeroutput>unsigned int</computeroutput> </para></listitem>
<listitem><para>TimeStamp - local time generator with value type <computeroutput>boost::posix_time::ptime</computeroutput> </para></listitem>
<listitem><para>ProcessID - current process identifier with value type <computeroutput>attributes::current_process_id::value_type</computeroutput> </para></listitem>
<listitem><para>ThreadID - in multithreaded builds, current thread identifier with value type <computeroutput>attributes::current_thread_id::value_type</computeroutput> </para></listitem>
</itemizedlist>
</para></description></function>







































</namespace>
</namespace>
</header>
<header name="boost/log/utility/setup/console.hpp">
<para><para>Andrey Semashev </para>
<para>16.05.2008</para>
The header contains implementation of convenience functions for enabling logging to console. </para><namespace name="boost">
<namespace name="log">

































































<function name="add_console_log"><type>shared_ptr&lt; sinks::synchronous_sink&lt; sinks::basic_text_ostream_backend&lt; CharT &gt; &gt;&gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-nontype-parameter name="ArgsT"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="strm"><paramtype>std::basic_ostream&lt; CharT &gt; &amp;</paramtype><description><para>One of the standard console streams: <computeroutput>std::cout</computeroutput>, <computeroutput>std::cerr</computeroutput> or <computeroutput>std::clog</computeroutput> (or the corresponding wide-character analogues). </para></description></parameter><parameter name="args"><paramtype>ArgsT...const &amp;</paramtype><description><para>Optional additional named arguments for the sink initialization. The following arguments are supported: <itemizedlist>
<listitem><para><computeroutput>filter</computeroutput> Specifies a filter to install into the sink. May be a string that represents a filter, or a filter lambda expression. </para></listitem>
<listitem><para><computeroutput>format</computeroutput> Specifies a formatter to install into the sink. May be a string that represents a formatter, or a formatter lambda expression (either streaming or Boost.Format-like notation). </para></listitem>
<listitem><para><computeroutput>auto_flush</computeroutput> A boolean flag that shows whether the sink should automatically flush the stream after each written record. </para></listitem>
</itemizedlist>
</para></description></parameter><description><para>The function constructs sink for the specified console stream and adds it to the core</para><para>

</para></description><returns><para>Pointer to the constructed sink. </para></returns></function>
<function name="add_console_log"><type>shared_ptr&lt; sinks::synchronous_sink&lt; sinks::basic_text_ostream_backend&lt; CharT &gt; &gt;&gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-nontype-parameter name="ArgsT"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>ArgsT...const &amp;</paramtype></parameter><description><para>Equivalent to: <computeroutput>add_console_log(std::clog);</computeroutput> or <computeroutput>add_console_log(std::wclog);</computeroutput>, depending on the <computeroutput>CharT</computeroutput> type.</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></function>
<function name="add_console_log"><type>shared_ptr&lt; sinks::synchronous_sink&lt; sinks::text_ostream_backend &gt;&gt;</type><description><para>The function constructs sink for the <computeroutput>std::clog</computeroutput> stream and adds it to the core</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 
</para></description><returns><para>Pointer to the constructed sink. </para></returns></function>
<function name="wadd_console_log"><type>shared_ptr&lt; sinks::synchronous_sink&lt; sinks::wtext_ostream_backend &gt;&gt;</type><description><para>The function constructs sink for the <computeroutput>std::wclog</computeroutput> stream and adds it to the core</para><para>
</para></description><returns><para>Pointer to the constructed sink. </para></returns></function>




























</namespace>
</namespace>
</header>
<header name="boost/log/utility/setup/file.hpp">
<para><para>Andrey Semashev </para>
<para>16.05.2008</para>
The header contains implementation of convenience functions for enabling logging to a file. </para><namespace name="boost">
<namespace name="log">










































<function name="add_file_log"><type>shared_ptr&lt; sinks::synchronous_sink&lt; sinks::text_file_backend &gt; &gt;</type><template>
          <template-nontype-parameter name="ArgsT"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>ArgsT...const &amp;</paramtype><description><para>A number of named arguments. The following parameters are supported: <itemizedlist>
<listitem><para><computeroutput>file_name</computeroutput> The file name or its pattern. This parameter is mandatory. </para></listitem>
<listitem><para><computeroutput>open_mode</computeroutput> The mask that describes the open mode for the file. See <computeroutput>std::ios_base::openmode</computeroutput>. </para></listitem>
<listitem><para><computeroutput>rotation_size</computeroutput> The size of the file at which rotation should occur. See <computeroutput>basic_text_file_backend</computeroutput>. </para></listitem>
<listitem><para><computeroutput>time_based_rotation</computeroutput> The predicate for time-based file rotations. See <computeroutput>basic_text_file_backend</computeroutput>. </para></listitem>
<listitem><para><computeroutput>auto_flush</computeroutput> A boolean flag that shows whether the sink should automatically flush the file after each written record. </para></listitem>
<listitem><para><computeroutput>target</computeroutput> The target directory to store rotated files in. See <computeroutput>sinks::file::make_collector</computeroutput>. </para></listitem>
<listitem><para><computeroutput>max_size</computeroutput> The maximum total size of rotated files in the target directory. See <computeroutput>sinks::file::make_collector</computeroutput>. </para></listitem>
<listitem><para><computeroutput>min_free_space</computeroutput> Minimum free space in the target directory. See <computeroutput>sinks::file::make_collector</computeroutput>. </para></listitem>
<listitem><para><computeroutput>max_files</computeroutput> The maximum total number of rotated files in the target directory. See <computeroutput>sinks::file::make_collector</computeroutput>. </para></listitem>
<listitem><para><computeroutput>scan_method</computeroutput> The method of scanning the target directory for log files. See <computeroutput>sinks::file::scan_method</computeroutput>. </para></listitem>
<listitem><para><computeroutput>filter</computeroutput> Specifies a filter to install into the sink. May be a string that represents a filter, or a filter lambda expression. </para></listitem>
<listitem><para><computeroutput>format</computeroutput> Specifies a formatter to install into the sink. May be a string that represents a formatter, or a formatter lambda expression (either streaming or Boost.Format-like notation). </para></listitem>
</itemizedlist>
</para></description></parameter><description><para>The function initializes the logging library to write logs to a file stream.</para><para>

</para></description><returns><para>Pointer to the constructed sink. </para></returns></function>






















































</namespace>
</namespace>
</header>
<header name="boost/log/utility/setup/filter_parser.hpp">
<para><para>Andrey Semashev </para>
<para>31.03.2008</para>
The header contains definition of a filter parser function. </para><namespace name="boost">
<namespace name="log">
<struct name="filter_factory"><template>
      <template-type-parameter name="CharT"/>
    </template><description><para>The interface class for all filter factories. </para></description><typedef name="char_type"><purpose>Character type. </purpose><type>CharT</type></typedef>
<typedef name="string_type"><purpose>String type. </purpose><type>std::basic_string&lt; char_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="on_exists_test" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><description><para>The callback for filter for the attribute existence test </para></description></method>
<method name="on_equality_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for equality relation filter </para></description></method>
<method name="on_inequality_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for inequality relation filter </para></description></method>
<method name="on_less_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for less relation filter </para></description></method>
<method name="on_greater_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for greater relation filter </para></description></method>
<method name="on_less_or_equal_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for less or equal relation filter </para></description></method>
<method name="on_greater_or_equal_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for greater or equal relation filter </para></description></method>
<method name="on_custom_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="rel"><paramtype>string_type const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for custom relation filter </para></description></method>
</method-group>
<constructor><description><para>Default constructor </para></description></constructor>
<destructor><description><para>Virtual destructor </para></description></destructor>
<constructor><parameter name=""><paramtype><classname>filter_factory</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>filter_factory</classname> &amp;</type><parameter name=""><paramtype><classname>filter_factory</classname> const &amp;</paramtype></parameter></copy-assignment>
</struct><class name="basic_filter_factory"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="AttributeValueT"/>
    </template><inherit access="public">boost::log::filter_factory&lt; CharT &gt;</inherit><description><para>The base class for filter factories. The class defines default implementations for most filter expressions. In order to be able to construct filters, the attribute value type must support reading from a stream. Also, the default filters will rely on relational operators for the type, so these operators must also be defined. </para></description><typedef name="value_type"><purpose>The type(s) of the attribute value expected. </purpose><type>AttributeValueT</type></typedef>
<typedef name="string_type"><purpose>String type. </purpose><type>base_type::string_type</type></typedef>
<method-group name="public member functions">
<method name="on_exists_test" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><description><para>The callback for filter for the attribute existence test </para></description></method>
<method name="on_equality_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for equality relation filter </para></description></method>
<method name="on_inequality_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for inequality relation filter </para></description></method>
<method name="on_less_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for less relation filter </para></description></method>
<method name="on_greater_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for greater relation filter </para></description></method>
<method name="on_less_or_equal_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for less or equal relation filter </para></description></method>
<method name="on_greater_or_equal_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for greater or equal relation filter </para></description></method>
<method name="on_custom_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="rel"><paramtype>string_type const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for custom relation filter </para></description></method>
<method name="parse_argument" specifiers="virtual"><type>value_type</type><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The function parses the argument value for a binary relation </para></description></method>
</method-group>
</class>















































<function name="register_filter_factory"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name to associate the factory with </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; <classname>filter_factory</classname>&lt; CharT &gt; &gt; const &amp;</paramtype><description><para>The filter factory </para></description></parameter><description><para>The function registers a filter factory object for the specified attribute name. The factory will be used to construct a filter during parsing the filter string.</para><para>

</para></description><requires><para><computeroutput>name != NULL &amp;&amp; factory != NULL</computeroutput>, <computeroutput>name</computeroutput> points to a zero-terminated string </para></requires></function>
<function name="register_filter_factory"><type>enable_if&lt; is_base_and_derived&lt; <classname>filter_factory</classname>&lt; typename FactoryT::char_type &gt;, FactoryT &gt;&gt;::type</type><template>
          <template-type-parameter name="FactoryT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name to associate the factory with </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; FactoryT &gt; const &amp;</paramtype><description><para>The filter factory </para></description></parameter><description><para>The function registers a filter factory object for the specified attribute name. The factory will be used to construct a filter during parsing the filter string.</para><para>

</para></description><requires><para><computeroutput>name != NULL &amp;&amp; factory != NULL</computeroutput>, <computeroutput>name</computeroutput> points to a zero-terminated string </para></requires></function>
<function name="register_simple_filter_factory"><type>void</type><template>
          <template-type-parameter name="AttributeValueT"/>
          <template-type-parameter name="CharT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name to associate the factory with </para></description></parameter><description><para>The function registers a simple filter factory object for the specified attribute name. The factory will support attribute values of type <computeroutput>AttributeValueT</computeroutput>, which must support all relation operations, such as equality comparison and less/greater ordering, and also extraction from stream.</para><para>

</para></description><requires><para><computeroutput>name != NULL</computeroutput>, <computeroutput>name</computeroutput> points to a zero-terminated string </para></requires></function>
<function name="register_simple_filter_factory"><type>void</type><template>
          <template-type-parameter name="AttributeValueT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name to associate the factory with </para></description></parameter><description><para>The function registers a simple filter factory object for the specified attribute name. The factory will support attribute values of type <computeroutput>AttributeValueT</computeroutput>, which must support all relation operations, such as equality comparison and less/greater ordering, and also extraction from stream.</para><para>

</para></description><requires><para><computeroutput>name != NULL</computeroutput>, <computeroutput>name</computeroutput> points to a zero-terminated string </para></requires></function>
<function name="register_simple_filter_factory"><type>void</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="DescriptorT"/>
          <template-nontype-parameter name="ActorT"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
        </template><parameter name="keyword"><paramtype>expressions::attribute_keyword&lt; DescriptorT, ActorT &gt; const &amp;</paramtype><description><para>Attribute keyword to associate the factory with </para></description></parameter><description><para>The function registers a simple filter factory object for the specified attribute keyword. The factory will support attribute values described by the keyword. The values must support all relation operations, such as equality comparison and less/greater ordering, and also extraction from stream.</para><para>

</para></description><requires><para><computeroutput>name != NULL</computeroutput>, <computeroutput>name</computeroutput> points to a zero-terminated string </para></requires></function>
<function name="parse_filter"><type>filter</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="begin"><paramtype>const CharT *</paramtype><description><para>Pointer to the first character of the sequence </para></description></parameter><parameter name="end"><paramtype>const CharT *</paramtype><description><para>Pointer to the after-the-last character of the sequence </para></description></parameter><description><para>The function parses a filter from the sequence of characters</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a filter cannot be recognized in the character sequence. </para></description><requires><para><computeroutput>begin &lt;= end</computeroutput>, both pointers must not be <computeroutput>NULL</computeroutput> </para></requires><returns><para>A function object that can be used as a filter.</para></returns></function>
<function name="parse_filter"><type>filter</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
          <template-type-parameter name="AllocatorT"/>
        </template><parameter name="str"><paramtype>std::basic_string&lt; CharT, TraitsT, AllocatorT &gt; const &amp;</paramtype><description><para>A string that contains filter description </para></description></parameter><description><para>The function parses a filter from the string</para><para>

<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a filter cannot be recognized in the character sequence. </para></description><returns><para>A function object that can be used as a filter.</para></returns></function>
<function name="parse_filter"><type>filter</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="str"><paramtype>const CharT *</paramtype><description><para>A string that contains filter description. </para></description></parameter><description><para>The function parses a filter from the string</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a filter cannot be recognized in the character sequence. </para></description><requires><para><computeroutput>str != NULL</computeroutput>, <computeroutput>str</computeroutput> points to a zero-terminated string. </para></requires><returns><para>A function object that can be used as a filter.</para></returns></function>









































</namespace>
</namespace>
</header>
<header name="boost/log/utility/setup/formatter_parser.hpp">
<para><para>Andrey Semashev </para>
<para>07.04.2008</para>
The header contains definition of a formatter parser function, along with facilities to add support for custom formatters. </para><namespace name="boost">
<namespace name="log">
<struct name="formatter_factory"><template>
      <template-type-parameter name="CharT"/>
    </template><description><para>Formatter factory base interface. </para></description><typedef name="char_type"><purpose>Character type. </purpose><type>CharT</type></typedef>
<typedef name="string_type"><purpose>String type. </purpose><type>std::basic_string&lt; char_type &gt;</type></typedef>
<typedef name="formatter_type"><purpose>The formatter function object. </purpose><type>basic_formatter&lt; char_type &gt;</type></typedef>
<typedef name="args_map"><description><para>Type of the map of formatter factory arguments [argument name -&gt; argument value]. This type of maps will be passed to formatter factories on attempt to create a formatter. </para></description><type>std::map&lt; string_type, string_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="create_formatter" cv="= 0" specifiers="virtual"><type>formatter_type</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name </para></description></parameter><parameter name="args"><paramtype>args_map const &amp;</paramtype><description><para>Formatter arguments </para></description></parameter><description><para>The function creates a formatter for the specified attribute.</para><para>
</para></description></method>
</method-group>
<constructor><description><para>Default constructor </para></description></constructor>
<destructor><description><para>Virtual destructor </para></description></destructor>
<constructor><parameter name=""><paramtype><classname>formatter_factory</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>formatter_factory</classname> &amp;</type><parameter name=""><paramtype><classname>formatter_factory</classname> const &amp;</paramtype></parameter></copy-assignment>
</struct><class name="basic_formatter_factory"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="AttributeValueT"/>
    </template><inherit access="public">boost::log::formatter_factory&lt; CharT &gt;</inherit><description><para>Base class for formatter factories. This class provides default implementation of formatter expressions for types supporting stream output. The factory does not take into account any additional parameters that may be specified. </para></description><typedef name="value_type"><purpose>Attribute value type. </purpose><type>AttributeValueT</type></typedef>
<typedef name="formatter_type"><purpose>The formatter function object. </purpose><type>base_type::formatter_type</type></typedef>
<typedef name="args_map"><description><para>Type of the map of formatter factory arguments [argument name -&gt; argument value]. This type of maps will be passed to formatter factories on attempt to create a formatter. </para></description><type>base_type::args_map</type></typedef>
<method-group name="public member functions">
<method name="create_formatter" specifiers="virtual"><type>formatter_type</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name </para></description></parameter><parameter name="args"><paramtype>args_map const &amp;</paramtype><description><para>Formatter arguments </para></description></parameter><description><para>The function creates a formatter for the specified attribute.</para><para>
</para></description></method>
</method-group>
</class>


























































<function name="register_formatter_factory"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="attr_name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; <classname>formatter_factory</classname>&lt; CharT &gt; &gt; const &amp;</paramtype><description><para>Pointer to the formatter factory </para></description></parameter><purpose>The function registers a user-defined formatter factory. </purpose><description><para>The function registers a user-defined formatter factory. The registered factory function will be called when the formatter parser detects the specified attribute name in the formatter string.</para><para>

</para></description><requires><para><computeroutput>!!attr_name &amp;&amp; !!factory</computeroutput>.</para></requires></function>
<function name="register_formatter_factory"><type>enable_if&lt; is_base_and_derived&lt; <classname>formatter_factory</classname>&lt; typename FactoryT::char_type &gt;, FactoryT &gt;&gt;::type</type><template>
          <template-type-parameter name="FactoryT"/>
        </template><parameter name="attr_name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; FactoryT &gt; const &amp;</paramtype><description><para>Pointer to the formatter factory </para></description></parameter><purpose>The function registers a user-defined formatter factory. </purpose><description><para>The function registers a user-defined formatter factory. The registered factory function will be called when the formatter parser detects the specified attribute name in the formatter string.</para><para>

</para></description><requires><para><computeroutput>!!attr_name &amp;&amp; !!factory</computeroutput>.</para></requires></function>
<function name="register_simple_formatter_factory"><type>void</type><template>
          <template-type-parameter name="AttributeValueT"/>
          <template-type-parameter name="CharT"/>
        </template><parameter name="attr_name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name </para></description></parameter><purpose>The function registers a simple formatter factory. </purpose><description><para>The function registers a simple formatter factory. The registered factory will generate formatters that will be equivalent to the <computeroutput>log::expressions::attr</computeroutput> formatter (i.e. that will use the native <computeroutput>operator&lt;&lt;</computeroutput> to format the attribute value). The factory does not use any arguments from the format string, if specified.</para><para>

</para></description><requires><para><computeroutput>!!attr_name</computeroutput>.</para></requires></function>
<function name="parse_formatter"><type>basic_formatter&lt; CharT &gt;</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="begin"><paramtype>const CharT *</paramtype><description><para>Pointer to the first character of the sequence </para></description></parameter><parameter name="end"><paramtype>const CharT *</paramtype><description><para>Pointer to the after-the-last character of the sequence </para></description></parameter><description><para>The function parses a formatter from the sequence of characters</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a formatter cannot be recognized in the character sequence. </para></description><requires><para><computeroutput>begin &lt;= end</computeroutput>, both pointers must not be NULL </para></requires><returns><para>The parsed formatter.</para></returns></function>
<function name="parse_formatter"><type>basic_formatter&lt; CharT &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
          <template-type-parameter name="AllocatorT"/>
        </template><parameter name="str"><paramtype>std::basic_string&lt; CharT, TraitsT, AllocatorT &gt; const &amp;</paramtype><description><para>A string that contains format description </para></description></parameter><description><para>The function parses a formatter from the string</para><para>

<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a formatter cannot be recognized in the character sequence. </para></description><returns><para>The parsed formatter.</para></returns></function>
<function name="parse_formatter"><type>basic_formatter&lt; CharT &gt;</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="str"><paramtype>const CharT *</paramtype><description><para>A string that contains format description. </para></description></parameter><description><para>The function parses a formatter from the string</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a formatter cannot be recognized in the character sequence. </para></description><requires><para><computeroutput>str != NULL</computeroutput>, <computeroutput>str</computeroutput> points to a zero-terminated string </para></requires><returns><para>The parsed formatter.</para></returns></function>
































</namespace>
</namespace>
</header>
<header name="boost/log/utility/setup/from_settings.hpp">
<para><para>Andrey Semashev </para>
<para>11.10.2009</para>
The header contains definition of facilities that allows to initialize the library from settings. </para><namespace name="boost">
<namespace name="log">
<struct name="sink_factory"><template>
      <template-type-parameter name="CharT"/>
    </template><description><para>Sink factory base interface </para></description><typedef name="char_type"><purpose>Character type. </purpose><type>CharT</type></typedef>
<typedef name="string_type"><purpose>String type. </purpose><type>std::basic_string&lt; char_type &gt;</type></typedef>
<typedef name="settings_section"><purpose>Settings section type. </purpose><type><classname>basic_settings_section</classname>&lt; char_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="create_sink" cv="= 0" specifiers="virtual"><type>shared_ptr&lt; sinks::sink &gt;</type><parameter name="settings"><paramtype>settings_section const &amp;</paramtype><description><para>Sink parameters </para></description></parameter><description><para>The function creates a formatter for the specified attribute.</para><para>
</para></description></method>
</method-group>
<constructor><description><para>Default constructor </para></description></constructor>
<destructor><description><para>Virtual destructor </para></description></destructor>
<constructor><parameter name=""><paramtype><classname>sink_factory</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>sink_factory</classname> &amp;</type><parameter name=""><paramtype><classname>sink_factory</classname> const &amp;</paramtype></parameter></copy-assignment>
</struct>










































<function name="init_from_settings"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="setts"><paramtype><classname>basic_settings_section</classname>&lt; CharT &gt; const &amp;</paramtype><description><para>Library settings container</para></description></parameter><description><para>The function initializes the logging library from a settings container</para><para>
<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if the provided settings are not valid. </para></description></function>
<function name="register_sink_factory"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="sink_name"><paramtype>const char *</paramtype><description><para>The custom sink name. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; <classname>sink_factory</classname>&lt; CharT &gt; &gt; const &amp;</paramtype><description><para>Pointer to the custom sink factory. Must not be NULL. </para></description></parameter><purpose>The function registers a factory for a custom sink. </purpose><description><para>The function registers a factory for a sink. The factory will be called to create sink instance when the parser discovers the specified sink type in the settings file. The factory must accept a map of parameters [parameter name -&gt; parameter value] that it may use to initialize the sink. The factory must return a non-NULL pointer to the constructed sink instance.</para><para>
</para></description></function>
<function name="register_sink_factory"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="sink_name"><paramtype>std::string const &amp;</paramtype><description><para>The custom sink name </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; <classname>sink_factory</classname>&lt; CharT &gt; &gt; const &amp;</paramtype><description><para>Pointer to the custom sink factory. Must not be NULL. </para></description></parameter><purpose>The function registers a factory for a custom sink. </purpose><description><para>The function registers a factory for a sink. The factory will be called to create sink instance when the parser discovers the specified sink type in the settings file. The factory must accept a map of parameters [parameter name -&gt; parameter value] that it may use to initialize the sink. The factory must return a non-NULL pointer to the constructed sink instance.</para><para>
</para></description></function>
<function name="register_sink_factory"><type>enable_if&lt; is_base_and_derived&lt; <classname>sink_factory</classname>&lt; typename FactoryT::char_type &gt;, FactoryT &gt;&gt;::type</type><template>
          <template-type-parameter name="FactoryT"/>
        </template><parameter name="sink_name"><paramtype>const char *</paramtype><description><para>The custom sink name. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; FactoryT &gt; const &amp;</paramtype><description><para>Pointer to the custom sink factory. Must not be NULL. </para></description></parameter><purpose>The function registers a factory for a custom sink. </purpose><description><para>The function registers a factory for a sink. The factory will be called to create sink instance when the parser discovers the specified sink type in the settings file. The factory must accept a map of parameters [parameter name -&gt; parameter value] that it may use to initialize the sink. The factory must return a non-NULL pointer to the constructed sink instance.</para><para>
</para></description></function>
<function name="register_sink_factory"><type>enable_if&lt; is_base_and_derived&lt; <classname>sink_factory</classname>&lt; typename FactoryT::char_type &gt;, FactoryT &gt;&gt;::type</type><template>
          <template-type-parameter name="FactoryT"/>
        </template><parameter name="sink_name"><paramtype>std::string const &amp;</paramtype><description><para>The custom sink name </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; FactoryT &gt; const &amp;</paramtype><description><para>Pointer to the custom sink factory. Must not be NULL. </para></description></parameter><purpose>The function registers a factory for a custom sink. </purpose><description><para>The function registers a factory for a sink. The factory will be called to create sink instance when the parser discovers the specified sink type in the settings file. The factory must accept a map of parameters [parameter name -&gt; parameter value] that it may use to initialize the sink. The factory must return a non-NULL pointer to the constructed sink instance.</para><para>
</para></description></function>

















































</namespace>
</namespace>
</header>
<header name="boost/log/utility/setup/from_stream.hpp">
<para><para>Andrey Semashev </para>
<para>22.03.2008</para>
The header contains definition of facilities that allows to initialize the library from a settings file. </para><namespace name="boost">
<namespace name="log">
























































<function name="init_from_stream"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="strm"><paramtype>std::basic_istream&lt; CharT &gt; &amp;</paramtype><description><para>Stream, that provides library settings</para></description></parameter><description><para>The function initializes the logging library from a stream containing logging settings</para><para>
<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if the read data cannot be interpreted as the library settings </para></description></function>








































</namespace>
</namespace>
</header>
<header name="boost/log/utility/setup/settings.hpp">
<para><para>Andrey Semashev </para>
<para>11.10.2009</para>
The header contains definition of the library settings container. </para><namespace name="boost">
<namespace name="log">
<class name="basic_settings_section"><template>
      <template-type-parameter name="CharT"/>
    </template><purpose>The class represents a reference to the settings container section. </purpose><description><para>The section refers to a sub-tree of the library settings container. It does not own the referred sub-tree but allows for convenient access to parameters within the subsection. </para></description><typedef name="char_type"><purpose>Character type. </purpose><type>CharT</type></typedef>
<typedef name="string_type"><purpose>String type. </purpose><type>std::basic_string&lt; char_type &gt;</type></typedef>
<typedef name="property_tree_type"><purpose>Property tree type. </purpose><type>property_tree::basic_ptree&lt; std::string, string_type &gt;</type></typedef>
<typedef name="path_type"><purpose>Property tree path type. </purpose><type>property_tree_type::path_type</type></typedef>
<typedef name="const_reference"><description><para>Constant reference to the parameter value </para></description><type>implementation_defined</type></typedef>
<typedef name="reference"><description><para>Mutable reference to the parameter value </para></description><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><description><para>Constant iterator over nested parameters and subsections </para></description><type>implementation_defined</type></typedef>
<typedef name="iterator"><description><para>Mutable iterator over nested parameters and subsections </para></description><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para>Checks if the section refers to the container. </para></description></method>
<method name="operator!" cv="const noexcept"><type>bool</type><description><para>Checks if the section refers to the container. </para></description></method>
<method name="begin"><type>iterator</type><description><para>Returns an iterator over the nested subsections and parameters. </para></description></method>
<method name="end"><type>iterator</type><description><para>Returns an iterator over the nested subsections and parameters. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para>Returns an iterator over the nested subsections and parameters. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para>Returns an iterator over the nested subsections and parameters. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para>Returns a reverse iterator over the nested subsections and parameters. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para>Returns a reverse iterator over the nested subsections and parameters. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para>Returns a reverse iterator over the nested subsections and parameters. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para>Returns a reverse iterator over the nested subsections and parameters. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para>Checks if the container is empty (i.e. contains no sections and parameters). </para></description></method>
<method name="operator[]"><type>reference</type><parameter name="section_name"><paramtype>std::string const &amp;</paramtype><description><para>The name of the section in which the parameter resides </para></description></parameter><description><para>Accessor to a single parameter. This operator should be used in conjunction with the subsequent subscript operator that designates the parameter name.</para><para>

</para></description><returns><para>An unspecified reference type that can be used for parameter name specifying </para></returns></method>
<method name="operator[]" cv="const"><type>const_reference</type><parameter name="section_name"><paramtype>std::string const &amp;</paramtype><description><para>The name of the section in which the parameter resides </para></description></parameter><description><para>Accessor to a single parameter. This operator should be used in conjunction with the subsequent subscript operator that designates the parameter name.</para><para>

</para></description><returns><para>An unspecified reference type that can be used for parameter name specifying </para></returns></method>
<method name="operator[]"><type>reference</type><parameter name="section_name"><paramtype>const char *</paramtype><description><para>The name of the section in which the parameter resides </para></description></parameter><description><para>Accessor to a single parameter. This operator should be used in conjunction with the subsequent subscript operator that designates the parameter name.</para><para>

</para></description><returns><para>An unspecified reference type that can be used for parameter name specifying </para></returns></method>
<method name="operator[]" cv="const"><type>const_reference</type><parameter name="section_name"><paramtype>const char *</paramtype><description><para>The name of the section in which the parameter resides </para></description></parameter><description><para>Accessor to a single parameter. This operator should be used in conjunction with the subsequent subscript operator that designates the parameter name.</para><para>

</para></description><returns><para>An unspecified reference type that can be used for parameter name specifying </para></returns></method>
<method name="property_tree" cv="const"><type>property_tree_type const &amp;</type><description><para>Accessor for the embedded property tree </para></description></method>
<method name="property_tree"><type>property_tree_type &amp;</type><description><para>Accessor for the embedded property tree </para></description></method>
<method name="has_section" cv="const"><type>bool</type><parameter name="section_name"><paramtype>string_type const &amp;</paramtype><description><para>The name of the section </para></description></parameter><description><para>Checks if the specified section is present in the container.</para><para>
</para></description></method>
<method name="has_parameter" cv="const"><type>bool</type><parameter name="section_name"><paramtype>string_type const &amp;</paramtype><description><para>The name of the section in which the parameter resides </para></description></parameter><parameter name="param_name"><paramtype>string_type const &amp;</paramtype><description><para>The name of the parameter </para></description></parameter><description><para>Checks if the specified parameter is present in the container.</para><para>
</para></description></method>
<method name="swap"><type>void</type><parameter name="that"><paramtype><classname>basic_settings_section</classname> &amp;</paramtype></parameter><description><para>Swaps two references to settings sections. </para></description></method>
</method-group>
<constructor><description><para>Default constructor. Creates an empty settings container. </para></description></constructor>
<constructor><parameter name="that"><paramtype><classname>basic_settings_section</classname> const &amp;</paramtype></parameter><description><para>Copy constructor. </para></description></constructor>
<method-group name="protected member functions">
</method-group>
<constructor specifiers="explicit"><parameter name="tree"><paramtype>property_tree_type *</paramtype></parameter></constructor>
</class><class name="basic_settings"><template>
      <template-type-parameter name="CharT"/>
    </template><inherit access="public">boost::log::basic_settings_section&lt; CharT &gt;</inherit><purpose>The class represents settings container. </purpose><description><para>All settings are presented as a number of named parameters divided into named sections. The parameters values are stored as strings. Individual parameters may be queried via subscript operators, like this:</para><para><computeroutput><programlisting>
 optional&lt; string &gt; param = settings["Section1"]["Param1"]; // reads parameter "Param1" in section "Section1"
                                                            // returns an empty value if no such parameter exists
 settings["Section2"]["Param2"] = 10; // sets the parameter "Param2" in section "Section2"
                                      // to value "10"
 </programlisting></computeroutput></para><para>There are also other methods to work with parameters. </para></description><typedef name="section"><purpose>Section type. </purpose><type><classname>basic_settings_section</classname>&lt; CharT &gt;</type></typedef>
<typedef name="property_tree_type"><purpose>Property tree type. </purpose><type>section::property_tree_type</type></typedef>
<method-group name="public member functions">
</method-group>
<constructor><description><para>Default constructor. Creates an empty settings container. </para></description></constructor>
<constructor><parameter name="that"><paramtype><classname>basic_settings</classname> const &amp;</paramtype></parameter><description><para>Copy constructor. </para></description></constructor>
<constructor><parameter name="that"><paramtype><classname>this_type</classname> &amp;&amp;</paramtype></parameter><description><para>Move constructor. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="tree"><paramtype>property_tree_type const &amp;</paramtype></parameter><description><para>Initializing constructor. Creates a settings container with the copy of the specified property tree. </para></description></constructor>
<destructor><description><para>Destructor </para></description></destructor>
<copy-assignment><type><classname>basic_settings</classname> &amp;</type><parameter name="that"><paramtype><classname>basic_settings</classname> const &amp;</paramtype></parameter><description><para>Copy assignment operator. </para></description></copy-assignment>
<copy-assignment><type><classname>basic_settings</classname> &amp;</type><parameter name="that"><paramtype><classname>basic_settings</classname> &amp;&amp;</paramtype></parameter><description><para>Move assignment operator. </para></description></copy-assignment>
</class><typedef name="settings"><purpose>Convenience typedef for narrow-character logging. </purpose><type><classname>basic_settings</classname>&lt; char &gt;</type></typedef>
<typedef name="settings_section"><purpose>Convenience typedef for narrow-character logging. </purpose><type><classname>basic_settings_section</classname>&lt; char &gt;</type></typedef>
<typedef name="wsettings"><purpose>Convenience typedef for wide-character logging. </purpose><type><classname>basic_settings</classname>&lt; wchar_t &gt;</type></typedef>
<typedef name="wsettings_section"><purpose>Convenience typedef for wide-character logging. </purpose><type><classname>basic_settings_section</classname>&lt; wchar_t &gt;</type></typedef>









































<function name="swap"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="left"><paramtype><classname>basic_settings_section</classname>&lt; CharT &gt; &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>basic_settings_section</classname>&lt; CharT &gt; &amp;</paramtype></parameter></function>























































</namespace>
</namespace>
</header>
<header name="boost/log/utility/setup/settings_parser.hpp">
<para><para>Andrey Semashev </para>
<para>20.07.2012</para>
The header contains definition of a settings parser function. </para><namespace name="boost">
<namespace name="log">


























































<function name="parse_settings"><type><classname>basic_settings</classname>&lt; CharT &gt;</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="strm"><paramtype>std::basic_istream&lt; CharT &gt; &amp;</paramtype><description><para>Stream, that provides library settings</para></description></parameter><description><para>The function parses library settings from an input stream</para><para>
<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if the read data cannot be interpreted as the library settings </para></description></function>






































</namespace>
</namespace>
</header>
<header name="boost/log/utility/strictest_lock.hpp">
<para><para>Andrey Semashev </para>
<para>30.05.2010</para>
The header contains definition of the <computeroutput>strictest_lock</computeroutput> metafunction that allows to select a lock with the strictest access requirements. </para><namespace name="boost">
<namespace name="log">
<struct-specialization name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>no_lock&lt; MutexT &gt;</template-arg></specialization></struct-specialization><struct-specialization name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>lock_guard&lt; MutexT &gt;</template-arg></specialization></struct-specialization><struct-specialization name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>unique_lock&lt; MutexT &gt;</template-arg></specialization></struct-specialization><struct-specialization name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>shared_lock&lt; MutexT &gt;</template-arg></specialization></struct-specialization><struct-specialization name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>upgrade_lock&lt; MutexT &gt;</template-arg></specialization></struct-specialization><struct-specialization name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>boost::log::aux::exclusive_lock_guard&lt; MutexT &gt;</template-arg></specialization></struct-specialization><struct-specialization name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>boost::log::aux::shared_lock_guard&lt; MutexT &gt;</template-arg></specialization></struct-specialization><struct name="strictest_lock"><template>
      <template-nontype-parameter name="LocksT"><type>typename...</type></template-nontype-parameter>
    </template><purpose>The metafunction selects the most strict lock type of the specified. </purpose><description><para>The template supports all lock types provided by the Boost.Thread library (except for <computeroutput>upgrade_to_unique_lock</computeroutput>), plus additional pseudo-lock <computeroutput>no_lock</computeroutput> that indicates no locking at all. Exclusive locks are considered the strictest, shared locks are weaker, and <computeroutput>no_lock</computeroutput> is the weakest. </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><enum name="lock_access_mode"><enumvalue name="unlocked_access"><purpose>A thread that owns this kind of lock doesn't restrict other threads in any way. </purpose></enumvalue><enumvalue name="shared_access"><purpose>A thread that owns this kind of lock requires that no other thread modify the locked data. </purpose></enumvalue><enumvalue name="exclusive_access"><purpose>A thread that owns this kind of lock requires that no other thread has access to the locked data. </purpose></enumvalue><purpose>Access modes for different types of locks. </purpose></enum>

































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/string_literal.hpp">
<para><para>Andrey Semashev </para>
<para>24.06.2007</para>
The header contains implementation of a constant string literal wrapper. </para><namespace name="boost">
<namespace name="log">
<class name="basic_string_literal"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="TraitsT"/>
    </template><purpose>String literal wrapper. </purpose><description><para>The <computeroutput><classname alt="boost::log::basic_string_literal">basic_string_literal</classname></computeroutput> is a thin wrapper around a constant string literal. It provides interface similar to STL strings, but because of read-only nature of string literals, lacks ability to modify string contents. However, <computeroutput><classname alt="boost::log::basic_string_literal">basic_string_literal</classname></computeroutput> objects can be assigned to and cleared.</para><para>The main advantage of this class comparing to other string classes is that it doesn't dynamically allocate memory and therefore is fast, thin and exception safe. </para></description><typedef name="value_type"><type>CharT</type></typedef>
<typedef name="traits_type"><type>TraitsT</type></typedef>
<typedef name="size_type"><type>std::size_t</type></typedef>
<typedef name="difference_type"><type>std::ptrdiff_t</type></typedef>
<typedef name="const_pointer"><type>const value_type *</type></typedef>
<typedef name="const_reference"><type>value_type const &amp;</type></typedef>
<typedef name="const_iterator"><type>const value_type *</type></typedef>
<typedef name="const_reverse_iterator"><type>std::reverse_iterator&lt; const_iterator &gt;</type></typedef>
<typedef name="string_type"><purpose>Corresponding STL string type. </purpose><type>std::basic_string&lt; value_type, traits_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="operator==" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (equality)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if the comparand string equals to this string, <computeroutput>false</computeroutput> otherwise </para></returns></method>
<method name="operator==" cv="const noexcept"><type>bool</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographical comparison (equality)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if the comparand string equals to this string, <computeroutput>false</computeroutput> otherwise </para></returns></method>
<method name="operator==" cv="const"><type>bool</type><parameter name="that"><paramtype>string_type const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (equality)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if the comparand string equals to this string, <computeroutput>false</computeroutput> otherwise </para></returns></method>
<method name="operator&lt;" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (less ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is less than the comparand, <computeroutput>false</computeroutput> otherwise </para></returns></method>
<method name="operator&lt;" cv="const noexcept"><type>bool</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographical comparison (less ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is less than the comparand, <computeroutput>false</computeroutput> otherwise </para></returns></method>
<method name="operator&lt;" cv="const"><type>bool</type><parameter name="that"><paramtype>string_type const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (less ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is less than the comparand, <computeroutput>false</computeroutput> otherwise </para></returns></method>
<method name="operator&gt;" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (greater ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is greater than the comparand, <computeroutput>false</computeroutput> otherwise </para></returns></method>
<method name="operator&gt;" cv="const noexcept"><type>bool</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographical comparison (greater ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is greater than the comparand, <computeroutput>false</computeroutput> otherwise </para></returns></method>
<method name="operator&gt;" cv="const"><type>bool</type><parameter name="that"><paramtype>string_type const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (greater ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is greater than the comparand, <computeroutput>false</computeroutput> otherwise </para></returns></method>
<method name="operator[]" cv="const noexcept"><type>const_reference</type><parameter name="i"><paramtype>size_type</paramtype><description><para>Requested character index </para></description></parameter><description><para>Subscript operator</para><para>


</para></description><requires><para><computeroutput>i &lt; size()</computeroutput> </para></requires><returns><para>Constant reference to the requested character </para></returns></method>
<method name="at" cv="const"><type>const_reference</type><parameter name="i"><paramtype>size_type</paramtype><description><para>Requested character index </para></description></parameter><description><para>Checked subscript</para><para>

<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if index <emphasis>i</emphasis> is out of string boundaries </para></description><returns><para>Constant reference to the requested character</para></returns></method>
<method name="c_str" cv="const noexcept"><type>const_pointer</type><description><para>
</para></description><returns><para>Pointer to the beginning of the literal </para></returns></method>
<method name="data" cv="const noexcept"><type>const_pointer</type><description><para>
</para></description><returns><para>Pointer to the beginning of the literal </para></returns></method>
<method name="size" cv="const noexcept"><type>size_type</type><description><para>
</para></description><returns><para>Length of the literal </para></returns></method>
<method name="length" cv="const noexcept"><type>size_type</type><description><para>
</para></description><returns><para>Length of the literal </para></returns></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para>
</para></description><returns><para><computeroutput>true</computeroutput> if the literal is an empty string, <computeroutput>false</computeroutput> otherwise </para></returns></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><description><para>
</para></description><returns><para>Iterator that points to the first character of the literal </para></returns></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para>
</para></description><returns><para>Iterator that points after the last character of the literal </para></returns></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para>
</para></description><returns><para>Reverse iterator that points to the last character of the literal </para></returns></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para>
</para></description><returns><para>Reverse iterator that points before the first character of the literal </para></returns></method>
<method name="str" cv="const"><type>string_type</type><description><para>
</para></description><returns><para>STL string constructed from the literal </para></returns></method>
<method name="clear" cv="noexcept"><type>void</type><description><para>The method clears the literal</para><para>
</para></description><postconditions><para><computeroutput>empty() == true</computeroutput> </para></postconditions></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="that"><paramtype><classname>this_type</classname> &amp;</paramtype></parameter><description><para>The method swaps two literals </para></description></method>
<method name="assign" cv="noexcept"><type><classname>this_type</classname> &amp;</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Source literal to copy string from </para></description></parameter><description><para>Assignment from another literal</para><para>

</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para></postconditions></method>
<method name="assign" cv="noexcept"><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="LenV"><type>size_type</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>T(&amp;)</paramtype><description><para>A zero-terminated constant sequence of characters </para></description></parameter><description><para>Assignment from another literal</para><para>

</para></description><postconditions><para><computeroutput>*this == p</computeroutput> </para></postconditions></method>
<method name="copy" cv="const"><type>size_type</type><parameter name="str"><paramtype>value_type *</paramtype><description><para>Pointer to the external buffer beginning. Must not be NULL. The buffer must have enough capacity to accommodate the requested number of characters. </para></description></parameter><parameter name="n"><paramtype>size_type</paramtype><description><para>Maximum number of characters to copy </para></description></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default><description><para>Starting position to start copying from </para></description></parameter><description><para>The method copies the literal or its portion to an external buffer</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if <emphasis>pos</emphasis> is out of range. </para></description><requires><para><computeroutput>pos &lt;= size()</computeroutput> </para></requires><returns><para>Number of characters copied</para></returns></method>
<method name="compare" cv="const"><type>int</type><parameter name="pos"><paramtype>size_type</paramtype><description><para>Starting position within this string to perform comparison to </para></description></parameter><parameter name="n"><paramtype>size_type</paramtype><description><para>Length of the substring of this string to perform comparison to </para></description></parameter><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a sequence of characters, must not be NULL. </para></description></parameter><parameter name="len"><paramtype>size_type</paramtype><description><para>Number of characters in the sequence <emphasis>str</emphasis>. </para></description></parameter><description><para>Lexicographically compares the argument string to a part of this string</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if <emphasis>pos</emphasis> is out of range. </para></description><requires><para><computeroutput>pos &lt;= size()</computeroutput> </para></requires><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand.</para></returns></method>
<method name="compare" cv="const noexcept"><type>int</type><parameter name="pos"><paramtype>size_type</paramtype><description><para>Starting position within this string to perform comparison to </para></description></parameter><parameter name="n"><paramtype>size_type</paramtype><description><para>Length of the substring of this string to perform comparison to </para></description></parameter><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographically compares the argument string to a part of this string</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if <emphasis>pos</emphasis> is out of range. </para></description><requires><para><computeroutput>pos &lt;= size()</computeroutput> </para></requires><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand.</para></returns></method>
<method name="compare" cv="const noexcept"><type>int</type><parameter name="pos"><paramtype>size_type</paramtype><description><para>Starting position within this string to perform comparison to </para></description></parameter><parameter name="n"><paramtype>size_type</paramtype><description><para>Length of the substring of this string to perform comparison to </para></description></parameter><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographically compares the argument string literal to a part of this string</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if <emphasis>pos</emphasis> is out of range. </para></description><requires><para><computeroutput>pos &lt;= size()</computeroutput> </para></requires><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand.</para></returns></method>
<method name="compare" cv="const noexcept"><type>int</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a sequence of characters, must not be NULL. </para></description></parameter><parameter name="len"><paramtype>size_type</paramtype><description><para>Number of characters in the sequence <emphasis>str</emphasis>. </para></description></parameter><description><para>Lexicographically compares the argument string to this string</para><para>

</para></description><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand. </para></returns></method>
<method name="compare" cv="const noexcept"><type>int</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographically compares the argument string to this string</para><para>

</para></description><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand. </para></returns></method>
<method name="compare" cv="const noexcept"><type>int</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographically compares the argument string to this string</para><para>

</para></description><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand. </para></returns></method>
</method-group>
<constructor cv="noexcept"><description><para>Constructor</para><para>
</para></description><postconditions><para><computeroutput>empty() == true</computeroutput> </para></postconditions></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="LenV"><type>size_type</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>T(&amp;)</paramtype><description><para>A zero-terminated constant sequence of characters </para></description></parameter><description><para>Constructor from a string literal</para><para>

</para></description><postconditions><para><computeroutput>*this == p</computeroutput> </para></postconditions></constructor>
<constructor cv="noexcept"><parameter name="that"><paramtype><classname>basic_string_literal</classname> const &amp;</paramtype><description><para>Source literal to copy string from </para></description></parameter><description><para>Copy constructor</para><para>

</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para></postconditions></constructor>
<copy-assignment cv="noexcept"><type><classname>this_type</classname> &amp;</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Source literal to copy string from </para></description></parameter><description><para>Assignment operator</para><para>

</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para></postconditions></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="LenV"><type>size_type</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>T(&amp;)</paramtype><description><para>A zero-terminated constant sequence of characters </para></description></parameter><description><para>Assignment from a string literal</para><para>

</para></description><postconditions><para><computeroutput>*this == p</computeroutput> </para></postconditions></copy-assignment>
</class>




























<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, StrmTraitsT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="StrmTraitsT"/>
          <template-type-parameter name="LitTraitsT"/>
        </template><parameter name="strm"><paramtype>std::basic_ostream&lt; CharT, StrmTraitsT &gt; &amp;</paramtype></parameter><parameter name="lit"><paramtype><classname>basic_string_literal</classname>&lt; CharT, LitTraitsT &gt; const &amp;</paramtype></parameter><purpose>Output operator. </purpose></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
        </template><parameter name="left"><paramtype><classname>basic_string_literal</classname>&lt; CharT, TraitsT &gt; &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>basic_string_literal</classname>&lt; CharT, TraitsT &gt; &amp;</paramtype></parameter><purpose>External swap. </purpose></function>
<function name="str_literal"><type><classname>basic_string_literal</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="LenV"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>T(&amp;)</paramtype></parameter><purpose>Creates a string literal wrapper from a constant string literal. </purpose></function>

































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/string_literal_fwd.hpp">
<para><para>Andrey Semashev </para>
<para>24.06.2007</para>
The header contains forward declaration of a constant string literal wrapper. </para><namespace name="boost">
<namespace name="log">
<typedef name="string_literal"><purpose>String literal type for narrow characters. </purpose><type><classname>basic_string_literal</classname>&lt; char &gt;</type></typedef>
<typedef name="wstring_literal"><purpose>String literal type for wide characters. </purpose><type><classname>basic_string_literal</classname>&lt; wchar_t &gt;</type></typedef>

































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/type_dispatch/date_time_types.hpp">
<para><para>Andrey Semashev </para>
<para>13.03.2008</para>
The header contains definition of date and time-related types supported by the library by default. </para><namespace name="boost">
<namespace name="log">
<typedef name="native_date_time_types"><description><para>An MPL-sequence of natively supported date and time types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="boost_date_time_types"><description><para>An MPL-sequence of Boost date and time types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="date_time_types"><description><para>An MPL-sequence with the complete list of the supported date and time types </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="native_date_types"><description><para>An MPL-sequence of natively supported date types of attributes </para></description><type>native_date_time_types</type></typedef>
<typedef name="boost_date_types"><description><para>An MPL-sequence of Boost date types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="date_types"><description><para>An MPL-sequence with the complete list of the supported date types </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="native_time_types"><description><para>An MPL-sequence of natively supported time types </para></description><type>native_date_time_types</type></typedef>
<typedef name="boost_time_types"><purpose>An MPL-sequence of Boost time types. </purpose><type>boost_date_time_types</type></typedef>
<typedef name="time_types"><description><para>An MPL-sequence with the complete list of the supported time types </para></description><type>date_time_types</type></typedef>
<typedef name="native_time_duration_types"><description><para>An MPL-sequence of natively supported time duration types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="boost_time_duration_types"><description><para>An MPL-sequence of Boost time duration types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="time_duration_types"><description><para>An MPL-sequence with the complete list of the supported time duration types </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="boost_time_period_types"><description><para>An MPL-sequence of Boost time duration types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="time_period_types"><description><para>An MPL-sequence with the complete list of the supported time period types </para></description><type>boost_time_period_types</type></typedef>

































































































</namespace>
</namespace>
<macro name="BOOST_LOG_NATIVE_DATE_TIME_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the standard C date/time types. </purpose></macro>
<macro name="BOOST_LOG_NATIVE_DATE_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the standard C date types. </purpose></macro>
<macro name="BOOST_LOG_BOOST_DATE_TIME_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the Boost date/time types. </purpose></macro>
<macro name="BOOST_LOG_DATE_TIME_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of date/time types. </purpose></macro>
<macro name="BOOST_LOG_BOOST_DATE_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the Boost date types. </purpose></macro>
<macro name="BOOST_LOG_DATE_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of date types. </purpose></macro>
<macro name="BOOST_LOG_NATIVE_TIME_DURATION_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the standard time duration types. </purpose></macro>
<macro name="BOOST_LOG_BOOST_TIME_DURATION_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the Boost time duration types. </purpose></macro>
<macro name="BOOST_LOG_TIME_DURATION_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of time duration types. </purpose></macro>
<macro name="BOOST_LOG_BOOST_TIME_PERIOD_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the Boost time period types. </purpose></macro>
<macro name="BOOST_LOG_TIME_PERIOD_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of time period types. </purpose></macro>
</header>
<header name="boost/log/utility/type_dispatch/dynamic_type_dispatcher.hpp">
<para><para>Andrey Semashev </para>
<para>15.04.2007</para>
The header contains implementation of the run-time type dispatcher. </para><namespace name="boost">
<namespace name="log">
<class name="dynamic_type_dispatcher"><inherit access="public">type_dispatcher</inherit><purpose>A dynamic type dispatcher. </purpose><description><para>The type dispatcher can be used to pass objects of arbitrary types from one component to another. With regard to the library, the type dispatcher can be used to extract attribute values.</para><para>The dynamic type dispatcher can be initialized in run time and, therefore, can support different types, depending on runtime conditions. Each supported type is associated with a functional object that will be called when an object of the type is dispatched. </para></description><method-group name="public member functions">
<method name="register_type"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VisitorT"/>
        </template><parameter name="visitor"><paramtype>VisitorT const &amp;</paramtype><description><para>Function object that will be associated with the type <computeroutput>T</computeroutput> </para></description></parameter><description><para>The method registers a new type</para><para>
</para></description></method>
<method name="registered_types_count" cv="const"><type>dispatching_map::size_type</type><description><para>The method returns the number of registered types </para></description></method>
</method-group>
<constructor><description><para>Default constructor </para></description></constructor>
<constructor><parameter name="that"><paramtype><classname>dynamic_type_dispatcher</classname> const &amp;</paramtype></parameter><description><para>Copy constructor </para></description></constructor>
<copy-assignment><type><classname>dynamic_type_dispatcher</classname> &amp;</type><parameter name="that"><paramtype><classname>dynamic_type_dispatcher</classname> const &amp;</paramtype></parameter><description><para>Copy assignment </para></description></copy-assignment>
</class>
































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/type_dispatch/standard_types.hpp">
<para><para>Andrey Semashev </para>
<para>19.05.2007</para>
The header contains definition of standard types supported by the library by default. </para><namespace name="boost">
<namespace name="log">
<typedef name="integral_types"><description><para>An MPL-sequence of integral types of attributes, supported by default </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="floating_point_types"><description><para>An MPL-sequence of FP types of attributes, supported by default </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="arithmetic_types"><description><para>An MPL-sequence of all numeric types of attributes, supported by default </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="numeric_types"><purpose>Deprecated alias. </purpose><type>arithmetic_types</type></typedef>
<typedef name="string_types"><description><para>An MPL-sequence of string types of attributes, supported by default </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef name="default_attribute_types"><purpose>Deprecated alias. </purpose><type>default_attribute_value_types</type></typedef>





































































<function name="BOOST_PP_CAT"><type>typedef</type><parameter name=""><paramtype>mpl::vector</paramtype></parameter><parameter name=""><paramtype>BOOST_PP_SEQ_SIZE((bool)(signed char)(unsigned char)(short)(unsigned short)(int)(unsigned int)(long)(unsigned long)(char)(wchar_t)(char16_t)(char32_t)(float)(double)(long double)(std::string)(<classname>boost::log::string_literal</classname>)(std::wstring)(<classname>boost::log::wstring_literal</classname>))</paramtype></parameter><description><para>An MPL-sequence of all attribute value types that are supported by the library by default. </para></description></function>



























</namespace>
</namespace>
<macro name="BOOST_LOG_AUX_STANDARD_TYPE_WCHAR_T" kind="functionlike"><macro-parameter name=""/></macro>
<macro name="BOOST_LOG_AUX_STANDARD_TYPE_CHAR16_T" kind="functionlike"><macro-parameter name=""/></macro>
<macro name="BOOST_LOG_AUX_STANDARD_TYPE_CHAR32_T" kind="functionlike"><macro-parameter name=""/></macro>
<macro name="BOOST_LOG_STANDARD_CHAR_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of character types. </purpose></macro>
<macro name="BOOST_LOG_AUX_STANDARD_LONG_LONG_TYPES" kind="functionlike"><macro-parameter name=""/></macro>
<macro name="BOOST_LOG_STANDARD_INTEGRAL_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of integral types. </purpose></macro>
<macro name="BOOST_LOG_STANDARD_FLOATING_POINT_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of floating point types. </purpose></macro>
<macro name="BOOST_LOG_STANDARD_ARITHMETIC_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of arithmetic types. </purpose></macro>
<macro name="BOOST_LOG_AUX_STANDARD_STRING_TYPES" kind="functionlike"><macro-parameter name=""/></macro>
<macro name="BOOST_LOG_AUX_STANDARD_WSTRING_TYPES" kind="functionlike"><macro-parameter name=""/></macro>
<macro name="BOOST_LOG_STANDARD_STRING_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of string types. </purpose></macro>
<macro name="BOOST_LOG_DEFAULT_ATTRIBUTE_VALUE_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the default attribute value types supported by the library. </purpose></macro>
</header>
<header name="boost/log/utility/type_dispatch/static_type_dispatcher.hpp">
<para><para>Andrey Semashev </para>
<para>15.04.2007</para>
The header contains implementation of a compile-time type dispatcher. </para><namespace name="boost">
<namespace name="log">
<class name="static_type_dispatcher"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A static type dispatcher class. </purpose><description><para>The type dispatcher can be used to pass objects of arbitrary types from one component to another. With regard to the library, the type dispatcher can be used to extract attribute values.</para><para>Static type dispatchers allow to specify one or several supported types at compile time. </para></description><method-group name="public member functions">
</method-group>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="ReceiverT"/>
        </template><parameter name="receiver"><paramtype>ReceiverT &amp;</paramtype><description><para>Unary function object that will be called on a dispatched value. The receiver must be callable with an argument of any of the supported types of the dispatcher. </para></description></parameter><description><para>Constructor. Initializes the dispatcher internals.</para><para>The <emphasis>receiver</emphasis> object is not copied inside the dispatcher, but references to it may be kept by the dispatcher after construction. The receiver object must remain valid until the dispatcher is destroyed.</para><para>
</para></description></constructor>
<constructor><parameter name=""><paramtype><classname>static_type_dispatcher</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>static_type_dispatcher</classname> &amp;</type><parameter name=""><paramtype><classname>static_type_dispatcher</classname> const &amp;</paramtype></parameter></copy-assignment>
</class>
































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/type_dispatch/type_dispatcher.hpp">
<para><para>Andrey Semashev </para>
<para>15.04.2007</para>
The header contains definition of generic type dispatcher interfaces. </para><namespace name="boost">
<namespace name="log">
<class name="type_dispatcher"><purpose>A type dispatcher interface. </purpose><description><para>All type dispatchers support this interface. It is used to acquire the visitor interface for the requested type. </para></description><class name="callback"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This interface is used by type dispatchers to consume the dispatched value. </para></description><method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><parameter name="value"><paramtype>T const &amp;</paramtype><description><para>The dispatched value </para></description></parameter><description><para>The operator invokes the visitor-specific logic with the given value</para><para>
</para></description></method>
<method name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para>The operator checks if the visitor is attached to a receiver </para></description></method>
<method name="operator!" cv="const noexcept"><type>bool</type><description><para>The operator checks if the visitor is not attached to a receiver </para></description></method>
</method-group>
</class><method-group name="protected member functions">
</method-group>
<constructor specifiers="explicit" cv="noexcept"><parameter name="get_callback_impl"><paramtype>get_callback_impl_type</paramtype></parameter><description><para>Initializing constructor </para></description></constructor>
<destructor/>
<constructor><parameter name="that"><paramtype><classname>type_dispatcher</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>type_dispatcher</classname> &amp;</type><parameter name="that"><paramtype><classname>type_dispatcher</classname> const &amp;</paramtype></parameter></copy-assignment>
<method-group name="public member functions">
<method name="get_callback"><type><classname>callback</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><description><para>The method requests a callback for the value of type <computeroutput>T</computeroutput> </para><para>
</para></description><returns><para>The type-specific callback or an empty value, if the type is not supported </para></returns></method>
</method-group>
</class>
































































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/type_info_wrapper.hpp">
<para><para>Andrey Semashev </para>
<para>15.04.2007</para>
The header contains implementation of a type information wrapper. </para><namespace name="boost">
<namespace name="log">
<class name="type_info_wrapper"><purpose>A simple <computeroutput>std::type_info</computeroutput> wrapper that implements value semantic for type information objects. </purpose><description><para>The type info wrapper is very useful for storing type information objects in containers, as a key or value. It also provides a number of useful features, such as default construction and assignment support, an empty state and extended support for human-friendly type names. </para></description><method-group name="public member functions">
<method name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para>
</para></description><returns><para><computeroutput>true</computeroutput> if the type info wrapper was initialized with a particular type, <computeroutput>false</computeroutput> if the wrapper was default-constructed and not yet initialized </para></returns></method>
<method name="get" cv="const noexcept"><type>std::type_info const &amp;</type><description><para>Stored type info getter</para><para>

</para></description><requires><para><computeroutput>!!*this</computeroutput> </para></requires><returns><para>Constant reference to the wrapped type info object </para></returns></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="that"><paramtype><classname>type_info_wrapper</classname> &amp;</paramtype></parameter><description><para>Swaps two instances of the wrapper </para></description></method>
<method name="pretty_name" cv="const"><type>std::string</type><description><para>The method returns the contained type name string in a possibly more readable format than <computeroutput>get().name()</computeroutput></para><para>

</para></description><requires><para><computeroutput>!!*this</computeroutput> </para></requires><returns><para>Type name string </para></returns></method>
<method name="operator!" cv="const noexcept"><type>bool</type><description><para>
</para></description><returns><para><computeroutput>false</computeroutput> if the type info wrapper was initialized with a particular type, <computeroutput>true</computeroutput> if the wrapper was default-constructed and not yet initialized </para></returns></method>
<method name="operator==" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Equality comparison</para><para>

</para></description><returns><para>If either this object or comparand is in empty state and the other is not, the result is <computeroutput>false</computeroutput>. If both arguments are empty, the result is <computeroutput>true</computeroutput>. If both arguments are not empty, the result is <computeroutput>true</computeroutput> if this object wraps the same type as the comparand and <computeroutput>false</computeroutput> otherwise. </para></returns></method>
<method name="operator&lt;" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Ordering operator</para><para>


<note><para>The results of this operator are only consistent within a single run of application. The result may change for the same types after rebuilding or even restarting the application. </para></note>
</para></description><requires><para><computeroutput>!!*this &amp;&amp; !!that</computeroutput> </para></requires><returns><para><computeroutput>true</computeroutput> if this object wraps type info object that is ordered before the type info object in the comparand, <computeroutput>false</computeroutput> otherwise </para></returns></method>
</method-group>
<constructor cv="noexcept"><description><para>Default constructor</para><para>
</para></description><postconditions><para><computeroutput>!*this == true</computeroutput> </para></postconditions></constructor>
<constructor cv="noexcept"><parameter name="that"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype><description><para>Source type info wrapper to copy from </para></description></parameter><description><para>Copy constructor</para><para>

</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para></postconditions></constructor>
<constructor cv="noexcept"><parameter name="that"><paramtype>std::type_info const &amp;</paramtype><description><para>Type info object to be wrapped </para></description></parameter><description><para>Conversion constructor</para><para>

</para></description><postconditions><para><computeroutput>*this == that &amp;&amp; !!*this</computeroutput> </para></postconditions></constructor>
</class><function name="operator!="><type>bool</type><parameter name="left"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype></parameter><purpose>Inequality operator. </purpose></function>
<function name="operator&lt;="><type>bool</type><parameter name="left"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype></parameter><purpose>Ordering operator. </purpose></function>
<function name="operator&gt;"><type>bool</type><parameter name="left"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype></parameter><purpose>Ordering operator. </purpose></function>
<function name="operator&gt;="><type>bool</type><parameter name="left"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype></parameter><purpose>Ordering operator. </purpose></function>
<function name="swap"><type>void</type><parameter name="left"><paramtype><classname>type_info_wrapper</classname> &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>type_info_wrapper</classname> &amp;</paramtype></parameter><purpose>Free swap for type info wrapper. </purpose></function>
<function name="to_string"><type>std::string</type><parameter name="ti"><paramtype><classname>type_info_wrapper</classname> const &amp;</paramtype></parameter><purpose>The function for exception serialization to string. </purpose></function>



























































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/unique_identifier_name.hpp">
<para><para>Andrey Semashev </para>
<para>30.04.2008</para>
The header contains <computeroutput>BOOST_LOG_UNIQUE_IDENTIFIER_NAME</computeroutput> macro definition. </para><macro name="BOOST_LOG_UNIQUE_IDENTIFIER_NAME" kind="functionlike"><macro-parameter name="prefix"/><description><para>Constructs a unique (in the current file scope) token that can be used as a variable name. The name will contain a prefix passed in the <emphasis>prefix</emphasis> argument. This allows to use the macro multiple times on a single line. </para></description></macro>
</header>
<header name="boost/log/utility/unused_variable.hpp">
<para><para>Andrey Semashev </para>
<para>10.05.2008</para>
The header contains definition of a macro to suppress compiler warnings about unused variables. </para><namespace name="boost">
<namespace name="log">

































































































</namespace>
</namespace>
<macro name="BOOST_LOG_UNUSED_VARIABLE" kind="functionlike"><macro-parameter name="type"/><macro-parameter name="var"/><macro-parameter name="initializer"/><purpose>The macro suppresses compiler warnings for <computeroutput>var</computeroutput> being unused. </purpose></macro>
</header>
<header name="boost/log/utility/value_ref.hpp">
<para><para>Andrey Semashev </para>
<para>27.07.2012</para>
The header contains implementation of a value reference wrapper. </para><namespace name="boost">
<namespace name="log">
<class name="value_ref"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="TagT"/>
    </template><purpose>Reference wrapper for a stored attribute value. </purpose><description><para>The <computeroutput><classname alt="boost::log::value_ref">value_ref</classname></computeroutput> class template provides access to the stored attribute value. It is not a traditional reference wrapper since it may be empty (i.e. refer to no value at all) and it can also refer to values of different types. Therefore its interface and behavior combines features of Boost.Ref, Boost.Optional and Boost.Variant, depending on the use case.</para><para>The template parameter <computeroutput>T</computeroutput> can be a single type or an MPL sequence of possible types being referred. The reference wrapper will act as either an optional reference or an optional variant of references to the specified types. In any case, the referred values will not be modifiable (i.e. <computeroutput><classname alt="boost::log::value_ref">value_ref</classname></computeroutput> always models a const reference).</para><para>Template parameter <computeroutput>TagT</computeroutput> is optional. It can be used for customizing the operations on this reference wrapper, such as putting the referred value to log. </para></description><method-group name="public member functions">
<method name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para>The operator verifies if the wrapper refers to a value. </para></description></method>
<method name="operator!" cv="const noexcept"><type>bool</type><description><para>The operator verifies if the wrapper does not refer to a value. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para>
</para></description><returns><para><computeroutput>true</computeroutput> if the wrapper does not refer to a value. </para></returns></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="that"><paramtype><classname>value_ref</classname> &amp;</paramtype></parameter><description><para>Swaps two reference wrappers </para></description></method>
</method-group>
<constructor><description><para>Default constructor. Creates a reference wrapper that does not refer to a value. </para></description></constructor>
<constructor><parameter name="that"><paramtype><classname>value_ref</classname> const &amp;</paramtype></parameter><description><para>Copy constructor. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><template>
          <template-type-parameter name="U"/>
        </template><parameter name="val"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>typename enable_if&lt; typename base_type::template is_compatible&lt; U &gt;, int &gt;::type</paramtype><default>0</default></parameter><description><para>Initializing constructor. Creates a reference wrapper that refers to the specified value. </para></description></constructor>
</class>





<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; &amp;</paramtype></parameter><purpose>Free swap function. </purpose></function>
<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="strm"><paramtype>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</paramtype></parameter><parameter name="val"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><purpose>Stream output operator. </purpose></function>
<function name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
          <template-type-parameter name="AllocatorT"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="strm"><paramtype><classname>basic_formatting_ostream</classname>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</paramtype></parameter><parameter name="val"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><purpose>Log formatting operator. </purpose></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>






































































</namespace>
</namespace>
</header>
<header name="boost/log/utility/value_ref_fwd.hpp">
<para><para>Andrey Semashev </para>
<para>27.07.2012</para>
The header contains forward declaration of a value reference wrapper. </para><namespace name="boost">
<namespace name="log">

































































































</namespace>
</namespace>
</header>
</library-reference>
