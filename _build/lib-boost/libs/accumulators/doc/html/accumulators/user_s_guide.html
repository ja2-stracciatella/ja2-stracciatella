<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>User's Guide</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Accumulators">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Accumulators">
<link rel="prev" href="../index.html" title="Chapter&#160;1.&#160;Boost.Accumulators">
<link rel="next" href="user_s_guide/the_statistical_accumulators_library.html" title="The Statistical Accumulators Library">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="user_s_guide/the_statistical_accumulators_library.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="accumulators.user_s_guide"></a><a class="link" href="user_s_guide.html" title="User's Guide">User's Guide</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework">The
      Accumulators Framework</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.using___accumulator_set___">Using
        <code class="literal">accumulator_set&lt;&gt;</code></a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extracting_results">Extracting
        Results</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.passing_optional_parameters">Passing
        Optional Parameters</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.weighted_samples">Weighted
        Samples</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.numeric_operators_sub_library">Numeric
        Operators Sub-Library</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework">Extending
        the Accumulators Framework</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator">Defining
          a New Accumulator</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_feature">Defining
          a New Feature</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_extractor">Defining
          a New Extractor</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.controlling_dependencies">Controlling
          Dependencies</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.operators_ex">Specializing
          Numeric Operators</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.concepts">Concepts</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html">The
      Statistical Accumulators Library</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.count">count</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.covariance">covariance</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.density">density</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.error_of_mean">error_of&lt;mean&gt;</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.extended_p_square">extended_p_square</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.extended_p_square_quantile">extended_p_square_quantile
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.kurtosis">kurtosis</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.max">max</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.mean">mean
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.median">median
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.min">min</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.moment">moment</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.p_square_cumulative_distribution">p_square_cumulative_distribution</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.p_square_quantile">p_square_quantile
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.peaks_over_threshold">peaks_over_threshold
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.pot_quantile">pot_quantile
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.pot_tail_mean">pot_tail_mean</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.rolling_count">rolling_count</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.rolling_sum">rolling_sum</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.rolling_mean">rolling_mean</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.rolling_moment">rolling_moment</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.rolling_variance">rolling_variance</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.skewness">skewness</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.sum">sum
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.tail">tail</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.coherent_tail_mean">coherent_tail_mean</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.non_coherent_tail_mean">non_coherent_tail_mean</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.tail_quantile">tail_quantile</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.tail_variate">tail_variate</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.tail_variate_means">tail_variate_means
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.variance">variance
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_covariance">weighted_covariance</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_density">weighted_density</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_extended_p_square">weighted_extended_p_square</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_kurtosis">weighted_kurtosis</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_mean">weighted_mean
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_median">weighted_median
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_moment">weighted_moment</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_p_square_cumulative_distribution">weighted_p_square_cumulative_distribution</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_p_square_quantile">weighted_p_square_quantile
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_peaks_over_threshold">weighted_peaks_over_threshold
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_skewness">weighted_skewness</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_sum">weighted_sum
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.non_coherent_weighted_tail_mean">non_coherent_weighted_tail_mean</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_tail_quantile">weighted_tail_quantile</a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_tail_variate_means">weighted_tail_variate_means
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
<dt><span class="section"><a href="user_s_guide/the_statistical_accumulators_library.html#accumulators.user_s_guide.the_statistical_accumulators_library.weighted_variance">weighted_variance
        <span class="emphasis"><em>and variants</em></span></a></span></dt>
</dl></dd>
</dl></div>
<p>
      This section describes how to use the Boost.Accumulators framework to create
      new accumulators and how to use the existing statistical accumulators to perform
      incremental statistical computation. For detailed information regarding specific
      components in Boost.Accumulators, check the <a class="link" href="reference.html#accumulators_framework_reference" title="Accumulators Framework Reference">Reference</a>
      section.
    </p>
<h3>
<a name="accumulators.user_s_guide.h0"></a>
      <span><a name="accumulators.user_s_guide.hello__world_"></a></span><a class="link" href="user_s_guide.html#accumulators.user_s_guide.hello__world_">Hello,
      World!</a>
    </h3>
<p>
      Below is a complete example of how to use the Accumulators Framework and the
      Statistical Accumulators to perform an incremental statistical calculation.
      It calculates the mean and 2nd moment of a sequence of doubles.
    </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">accumulators</span><span class="special">/</span><span class="identifier">accumulators</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">accumulators</span><span class="special">/</span><span class="identifier">statistics</span><span class="special">/</span><span class="identifier">stats</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">accumulators</span><span class="special">/</span><span class="identifier">statistics</span><span class="special">/</span><span class="identifier">mean</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">accumulators</span><span class="special">/</span><span class="identifier">statistics</span><span class="special">/</span><span class="identifier">moment</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">accumulators</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="comment">// Define an accumulator set for calculating the mean and the</span>
    <span class="comment">// 2nd moment ...</span>
    <span class="identifier">accumulator_set</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">,</span> <span class="identifier">stats</span><span class="special">&lt;</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">mean</span><span class="special">,</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">moment</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">;</span>

    <span class="comment">// push in some data ...</span>
    <span class="identifier">acc</span><span class="special">(</span><span class="number">1.2</span><span class="special">);</span>
    <span class="identifier">acc</span><span class="special">(</span><span class="number">2.3</span><span class="special">);</span>
    <span class="identifier">acc</span><span class="special">(</span><span class="number">3.4</span><span class="special">);</span>
    <span class="identifier">acc</span><span class="special">(</span><span class="number">4.5</span><span class="special">);</span>

    <span class="comment">// Display the results ...</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Mean:   "</span> <span class="special">&lt;&lt;</span> <span class="identifier">mean</span><span class="special">(</span><span class="identifier">acc</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Moment: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">accumulators</span><span class="special">::</span><span class="identifier">moment</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;(</span><span class="identifier">acc</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      This program displays the following:
    </p>
<pre class="programlisting">Mean:   2.85
Moment: 9.635
</pre>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework" title="The Accumulators Framework">The
      Accumulators Framework</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.using___accumulator_set___">Using
        <code class="literal">accumulator_set&lt;&gt;</code></a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extracting_results">Extracting
        Results</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.passing_optional_parameters">Passing
        Optional Parameters</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.weighted_samples">Weighted
        Samples</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.numeric_operators_sub_library">Numeric
        Operators Sub-Library</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework">Extending
        the Accumulators Framework</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator">Defining
          a New Accumulator</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_feature">Defining
          a New Feature</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_extractor">Defining
          a New Extractor</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.controlling_dependencies">Controlling
          Dependencies</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.operators_ex">Specializing
          Numeric Operators</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.concepts">Concepts</a></span></dt>
</dl></div>
<p>
        The Accumulators Framework is framework for performing incremental calculations.
        Usage of the framework follows the following pattern:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Users build a computational object, called an <span class="emphasis"><em><code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code></em></span>,
            by selecting the computations in which they are interested, or authoring
            their own computational primitives which fit within the framework.
          </li>
<li class="listitem">
            Users push data into the <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
            object one sample at a time.
          </li>
<li class="listitem">
            The <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
            computes the requested quantities in the most efficient method possible,
            resolving dependencies between requested calculations, possibly caching
            intermediate results.
          </li>
</ul></div>
<p>
        The Accumulators Framework defines the utilities needed for defining primitive
        computational elements, called <span class="emphasis"><em>accumulators</em></span>. It also
        provides the <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
        type, described above.
      </p>
<h3>
<a name="accumulators.user_s_guide.the_accumulators_framework.h0"></a>
        <span><a name="accumulators.user_s_guide.the_accumulators_framework.terminology"></a></span><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.terminology">Terminology</a>
      </h3>
<p>
        The following terms are used in the rest of the documentation.
      </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Sample</span></dt>
<dd><p>
              <a name="sample_type"></a>A datum that is pushed into an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>. The type of the
              sample is the <span class="emphasis"><em>sample type</em></span>.
            </p></dd>
<dt><span class="term">Weight</span></dt>
<dd><p>
              <a name="weight_type"></a>An optional scalar value passed along with
              the sample specifying the weight of the sample. Conceptually, each
              sample is multiplied with its weight. The type of the weight is the
              <span class="emphasis"><em>weight type</em></span>.
            </p></dd>
<dt><span class="term">Feature</span></dt>
<dd><p>
              An abstract primitive computational entity. When defining an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>, users specify
              the features in which they are interested, and the <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
              figures out which <span class="emphasis"><em>accumulators</em></span> would best provide
              those features. Features may depend on other features. If they do,
              the accumulator set figures out which accumulators to add to satisfy
              the dependencies.
            </p></dd>
<dt><span class="term">Accumulator</span></dt>
<dd><p>
              A concrete primitive computational entity. An accumulator is a concrete
              implementation of a feature. It satisfies exactly one abstract feature.
              Several different accumulators may provide the same feature, but may
              represent different implementation strategies.
            </p></dd>
<dt><span class="term">Accumulator Set</span></dt>
<dd><p>
              A collection of accumulators. An accumulator set is specified with
              a sample type and a list of features. The accumulator set uses this
              information to generate an ordered set of accumulators depending on
              the feature dependency graph. An accumulator set accepts samples one
              datum at a time, propagating them to each accumulator in order. At
              any point, results can be extracted from the accumulator set.
            </p></dd>
<dt><span class="term">Extractor</span></dt>
<dd><p>
              A function or function object that can be used to extract a result
              from an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>.
            </p></dd>
</dl>
</div>
<h3>
<a name="accumulators.user_s_guide.the_accumulators_framework.h1"></a>
        <span><a name="accumulators.user_s_guide.the_accumulators_framework.overview"></a></span><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.overview">Overview</a>
      </h3>
<p>
        Here is a list of the important types and functions in the Accumulator Framework
        and a brief description of each.
      </p>
<div class="table">
<a name="accumulators.user_s_guide.the_accumulators_framework.t0"></a><p class="title"><b>Table&#160;1.1.&#160;Accumulators Toolbox</b></p>
<div class="table-contents"><table class="table" summary="Accumulators Toolbox">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Tool
                </p>
              </th>
<th>
                <p>
                  Description
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
                </p>
              </td>
<td>
                <p>
                  This is the most important type in the Accumulators Framework.
                  It is a collection of accumulators. A datum pushed into an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code> is forwarded
                  to each accumulator, in an order determined by the dependency relationships
                  between the accumulators. Computational results can be extracted
                  from an accumulator at any time.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../boost/accumulators/depends_on.html" title="Struct template depends_on">depends_on&lt;&gt;</a></code>
                </p>
              </td>
<td>
                <p>
                  Used to specify which other features a feature depends on.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../boost/accumulators/feature_of.html" title="Struct template feature_of">feature_of&lt;&gt;</a></code>
                </p>
              </td>
<td>
                <p>
                  Trait used to tell the Accumulators Framework that, for the purpose
                  of feature-based dependency resolution, one feature should be treated
                  the same as another.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../boost/accumulators/as_feature.html" title="Struct template as_feature">as_feature&lt;&gt;</a></code>
                </p>
              </td>
<td>
                <p>
                  Used to create an alias for a feature. For example, if there are
                  two features, fast_X and accurate_X, they can be mapped to X(fast)
                  and X(accurate) with <code class="computeroutput"><a class="link" href="../boost/accumulators/as_feature.html" title="Struct template as_feature">as_feature&lt;&gt;</a></code>.
                  This is just syntactic sugar.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../boost/accumulators/features.html" title="Struct template features">features&lt;&gt;</a></code>
                </p>
              </td>
<td>
                <p>
                  An <a href="../../../libs/mpl/index.html" target="_top">MPL</a> sequence.
                  We can use <code class="computeroutput"><a class="link" href="../boost/accumulators/features.html" title="Struct template features">features&lt;&gt;</a></code>
                  as the second template parameter when declaring an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput">external&lt;&gt;</code>
                </p>
              </td>
<td>
                <p>
                  Used when declaring an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>.
                  If the weight type is specified with <code class="computeroutput">external&lt;&gt;</code>,
                  then the weight accumulators are assumed to reside in a separate
                  accumulator set which will be passed in with a named parameter.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput">extractor&lt;&gt;</code>
                </p>
              </td>
<td>
                <p>
                  A class template useful for creating an extractor function object.
                  It is parameterized on a feature, and it has member functions for
                  extracting from an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
                  the result corresponding to that feature.
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.using___accumulator_set___"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.using___accumulator_set___" title="Using accumulator_set&lt;&gt;">Using
        <code class="literal">accumulator_set&lt;&gt;</code></a>
</h4></div></div></div>
<p>
          Our tour of the <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
          class template begins with the forward declaration:
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Sample</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Features</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Weight</span> <span class="special">=</span> <span class="keyword">void</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">accumulator_set</span><span class="special">;</span>
</pre>
<p>
          The template parameters have the following meaning:
        </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term"><code class="computeroutput"><span class="identifier">Sample</span></code></span></dt>
<dd><p>
                The type of the data that will be accumulated.
              </p></dd>
<dt><span class="term"><code class="computeroutput"><span class="identifier">Features</span></code></span></dt>
<dd><p>
                An <a href="../../../libs/mpl/index.html" target="_top">MPL</a> sequence of
                features to be calculated.
              </p></dd>
<dt><span class="term"><code class="computeroutput"><span class="identifier">Weight</span></code></span></dt>
<dd><p>
                The type of the (optional) weight paramter.
              </p></dd>
</dl>
</div>
<p>
          For example, the following line declares an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
          that will accept a sequence of doubles one at a time and calculate the
          min and mean:
        </p>
<pre class="programlisting"><span class="identifier">accumulator_set</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">,</span> <span class="identifier">features</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">min</span><span class="special">,</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">mean</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">;</span>
</pre>
<p>
          Notice that we use the <code class="computeroutput"><a class="link" href="../boost/accumulators/features.html" title="Struct template features">features&lt;&gt;</a></code>
          template to specify a list of features to be calculated. <code class="computeroutput"><a class="link" href="../boost/accumulators/features.html" title="Struct template features">features&lt;&gt;</a></code>
          is an MPL sequence of features.
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            <code class="computeroutput"><a class="link" href="../boost/accumulators/features.html" title="Struct template features">features&lt;&gt;</a></code> is a synonym of
            <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code>.
            In fact, we could use <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code> or any MPL sequence if we prefer,
            and the meaning would be the same.
          </p></td></tr>
</table></div>
<p>
          Once we have defined an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>,
          we can then push data into it, and it will calculate the quantities you
          requested, as shown below.
        </p>
<pre class="programlisting"><span class="comment">// push some data into the accumulator_set ...</span>
<span class="identifier">acc</span><span class="special">(</span><span class="number">1.2</span><span class="special">);</span>
<span class="identifier">acc</span><span class="special">(</span><span class="number">2.3</span><span class="special">);</span>
<span class="identifier">acc</span><span class="special">(</span><span class="number">3.4</span><span class="special">);</span>
</pre>
<p>
          Since <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
          defines its accumulate function to be the function call operator, we might
          be tempted to use an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
          as a UnaryFunction to a standard algorithm such as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span></code>.
          That's fine as long as we keep in mind that the standard algorithms take
          UnaryFunction objects by value, which involves making a copy of the <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code> object. Consider the
          following:
        </p>
<pre class="programlisting"><span class="comment">// The data for which we wish to calculate statistical properties:</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="special">&gt;</span> <span class="identifier">data</span><span class="special">(</span> <span class="comment">/* stuff */</span> <span class="special">);</span>

<span class="comment">// The accumulator set which will calculate the properties for us:    </span>
<span class="identifier">accumulator_set</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">,</span> <span class="identifier">features</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">min</span><span class="special">,</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">mean</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">;</span>

<span class="comment">// Use std::for_each to accumulate the statistical properties:</span>
<span class="identifier">acc</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span> <span class="identifier">data</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">data</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">acc</span> <span class="special">);</span>
</pre>
<p>
          Notice how we must assign the return value of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span></code>
          back to the <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>.
          This works, but some accumulators are not cheap to copy. For example, the
          <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail.html" title="Struct template tail">tail</a></code>
          and <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail_variate.html" title="Struct template tail_variate">tail_variate&lt;&gt;</a></code>
          accumulators must store a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code>, so copying these accumulators
          involves a dynamic allocation. We might be better off in this case passing
          the accumulator by reference, with the help of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code>. See below:
        </p>
<pre class="programlisting"><span class="comment">// The data for which we wish to calculate statistical properties:</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="special">&gt;</span> <span class="identifier">data</span><span class="special">(</span> <span class="comment">/* stuff */</span> <span class="special">);</span>

<span class="comment">// The accumulator set which will calculate the properties for us:</span>
<span class="identifier">accumulator_set</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">,</span> <span class="identifier">features</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">tail</span><span class="special">&lt;</span><span class="identifier">left</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">(</span>
    <span class="identifier">tag</span><span class="special">::</span><span class="identifier">tail</span><span class="special">&lt;</span><span class="identifier">left</span><span class="special">&gt;::</span><span class="identifier">cache_size</span> <span class="special">=</span> <span class="number">4</span> <span class="special">);</span>

<span class="comment">// Use std::for_each to accumulate the statistical properties:</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span> <span class="identifier">data</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">data</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">bind</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;(</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">acc</span><span class="special">),</span> <span class="identifier">_1</span> <span class="special">)</span> <span class="special">);</span>
</pre>
<p>
          Notice now that we don't care about the return value of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">()</span></code> anymore because <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">()</span></code> is modifying <code class="computeroutput"><span class="identifier">acc</span></code>
          directly.
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            To use <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">()</span></code>
            and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code>,
            you must <code class="computeroutput"><span class="preprocessor">#include</span></code>
            <code class="literal">&lt;boost/bind.hpp&gt;</code> and <code class="literal">&lt;boost/ref.hpp&gt;</code>
          </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.extracting_results"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extracting_results" title="Extracting Results">Extracting
        Results</a>
</h4></div></div></div>
<p>
          Once we have declared an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
          and pushed data into it, we need to be able to extract results from it.
          For each feature we can add to an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>,
          there is a corresponding extractor for fetching its result. Usually, the
          extractor has the same name as the feature, but in a different namespace.
          For example, if we accumulate the <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">min</span></code>
          and <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">max</span></code> features, we can extract the results
          with the <code class="computeroutput"><span class="identifier">min</span></code> and <code class="computeroutput"><span class="identifier">max</span></code> extractors, as follows:
        </p>
<pre class="programlisting"><span class="comment">// Calculate the minimum and maximum for a sequence of integers.</span>
<span class="identifier">accumulator_set</span><span class="special">&lt;</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">features</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">min</span><span class="special">,</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">max</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">;</span>
<span class="identifier">acc</span><span class="special">(</span> <span class="number">2</span> <span class="special">);</span>
<span class="identifier">acc</span><span class="special">(</span> <span class="special">-</span><span class="number">1</span> <span class="special">);</span>
<span class="identifier">acc</span><span class="special">(</span> <span class="number">1</span> <span class="special">);</span>

<span class="comment">// This displays "(-1, 2)"</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'('</span> <span class="special">&lt;&lt;</span> <span class="identifier">min</span><span class="special">(</span> <span class="identifier">acc</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="identifier">max</span><span class="special">(</span> <span class="identifier">acc</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">")\n"</span><span class="special">;</span>
</pre>
<p>
          The extractors are all declared in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">accumulators</span><span class="special">::</span><span class="identifier">extract</span></code>
          namespace, but they are brought into the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">accumulators</span></code>
          namespace with a <code class="computeroutput"><span class="keyword">using</span></code> declaration.
        </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
            On the Windows platform, <code class="computeroutput"><span class="identifier">min</span></code>
            and <code class="computeroutput"><span class="identifier">max</span></code> are preprocessor
            macros defined in <code class="literal">WinDef.h</code>. To use the <code class="computeroutput"><span class="identifier">min</span></code> and <code class="computeroutput"><span class="identifier">max</span></code>
            extractors, you should either compile with <code class="computeroutput"><span class="identifier">NOMINMAX</span></code>
            defined, or you should invoke the extractors like: <code class="computeroutput"><span class="special">(</span><span class="identifier">min</span><span class="special">)(</span> <span class="identifier">acc</span> <span class="special">)</span></code>
            and <code class="computeroutput"><span class="special">(</span><span class="identifier">max</span><span class="special">)(</span> <span class="identifier">acc</span> <span class="special">)</span></code>. The parentheses keep the macro from
            being invoked.
          </p></td></tr>
</table></div>
<p>
          Another way to extract a result from an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
          is with the <code class="computeroutput"><span class="identifier">extract_result</span><span class="special">()</span></code> function. This can be more convenient
          if there isn't an extractor object handy for a certain feature. The line
          above which displays results could equally be written as:
        </p>
<pre class="programlisting"><span class="comment">// This displays "(-1, 2)"</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'('</span>  <span class="special">&lt;&lt;</span> <span class="identifier">extract_result</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">min</span> <span class="special">&gt;(</span> <span class="identifier">acc</span> <span class="special">)</span>
          <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="identifier">extract_result</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">max</span> <span class="special">&gt;(</span> <span class="identifier">acc</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">")\n"</span><span class="special">;</span>
</pre>
<p>
          Finally, we can define our own extractor using the <code class="computeroutput">extractor&lt;&gt;</code>
          class template. For instance, another way to avoid the <code class="computeroutput"><span class="identifier">min</span></code>
          / <code class="computeroutput"><span class="identifier">max</span></code> macro business would
          be to define extractors with names that don't conflict with the macros,
          like this:
        </p>
<pre class="programlisting"><span class="identifier">extractor</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">min</span> <span class="special">&gt;</span> <span class="identifier">min_</span><span class="special">;</span>
<span class="identifier">extractor</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">min</span> <span class="special">&gt;</span> <span class="identifier">max_</span><span class="special">;</span>

<span class="comment">// This displays "(-1, 2)"</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'('</span> <span class="special">&lt;&lt;</span> <span class="identifier">min_</span><span class="special">(</span> <span class="identifier">acc</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="identifier">max_</span><span class="special">(</span> <span class="identifier">acc</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">")\n"</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.passing_optional_parameters"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.passing_optional_parameters" title="Passing Optional Parameters">Passing
        Optional Parameters</a>
</h4></div></div></div>
<p>
          Some accumulators need initialization parameters. In addition, perhaps
          some auxiliary information needs to be passed into the <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
          along with each sample. Boost.Accumulators handles these cases with named
          parameters from the <a href="../../../libs/parameter/index.html" target="_top">Boost.Parameter</a>
          library.
        </p>
<p>
          For example, consider the <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail.html" title="Struct template tail">tail</a></code> and <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail_variate.html" title="Struct template tail_variate">tail_variate&lt;&gt;</a></code>
          features. <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail.html" title="Struct template tail">tail</a></code> keeps an ordered list
          of the largest <code class="literal"><span class="emphasis"><em>N</em></span></code> samples, where
          <code class="literal"><span class="emphasis"><em>N</em></span></code> can be specified at construction
          time. Also, the <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail_variate.html" title="Struct template tail_variate">tail_variate&lt;&gt;</a></code>
          feature, which depends on <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail.html" title="Struct template tail">tail</a></code>, keeps track of some
          data that is covariate with the <code class="literal"><span class="emphasis"><em>N</em></span></code>
          samples tracked by <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail.html" title="Struct template tail">tail</a></code>. The code below shows
          how this all works, and is described in more detail below.
        </p>
<pre class="programlisting"><span class="comment">// Define a feature for tracking covariate data</span>
<span class="keyword">typedef</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">tail_variate</span><span class="special">&lt;</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">covariate1</span><span class="special">,</span> <span class="identifier">left</span> <span class="special">&gt;</span> <span class="identifier">my_tail_variate_tag</span><span class="special">;</span>

<span class="comment">// This will calculate the left tail and my_tail_variate_tag for N == 2</span>
<span class="comment">// using the tag::tail&lt;left&gt;::cache_size named parameter</span>
<span class="identifier">accumulator_set</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">,</span> <span class="identifier">features</span><span class="special">&lt;</span> <span class="identifier">my_tail_variate_tag</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">(</span>
    <span class="identifier">tag</span><span class="special">::</span><span class="identifier">tail</span><span class="special">&lt;</span><span class="identifier">left</span><span class="special">&gt;::</span><span class="identifier">cache_size</span> <span class="special">=</span> <span class="number">2</span> <span class="special">);</span>

<span class="comment">// push in some samples and some covariates by using </span>
<span class="comment">// the covariate1 named parameter</span>
<span class="identifier">acc</span><span class="special">(</span> <span class="number">1.2</span><span class="special">,</span> <span class="identifier">covariate1</span> <span class="special">=</span>  <span class="number">12</span> <span class="special">);</span>
<span class="identifier">acc</span><span class="special">(</span> <span class="number">2.3</span><span class="special">,</span> <span class="identifier">covariate1</span> <span class="special">=</span> <span class="special">-</span><span class="number">23</span> <span class="special">);</span>
<span class="identifier">acc</span><span class="special">(</span> <span class="number">3.4</span><span class="special">,</span> <span class="identifier">covariate1</span> <span class="special">=</span>  <span class="number">34</span> <span class="special">);</span>
<span class="identifier">acc</span><span class="special">(</span> <span class="number">4.5</span><span class="special">,</span> <span class="identifier">covariate1</span> <span class="special">=</span> <span class="special">-</span><span class="number">45</span> <span class="special">);</span>

<span class="comment">// Define an extractor for the my_tail_variate_tag feature</span>
<span class="identifier">extractor</span><span class="special">&lt;</span> <span class="identifier">my_tail_variate_tag</span> <span class="special">&gt;</span> <span class="identifier">my_tail_variate</span><span class="special">;</span>

<span class="comment">// Write the tail statistic to std::cout. This will print "4.5, 3.4, "</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="special">&gt;</span> <span class="identifier">dout</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">", "</span> <span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span> <span class="identifier">tail</span><span class="special">(</span> <span class="identifier">acc</span> <span class="special">).</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">tail</span><span class="special">(</span> <span class="identifier">acc</span> <span class="special">).</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">dout</span> <span class="special">);</span>

<span class="comment">// Write the tail_variate statistic to std::cout. This will print "-45, 34, "</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">iout</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">", "</span> <span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span> <span class="identifier">my_tail_variate</span><span class="special">(</span> <span class="identifier">acc</span> <span class="special">).</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">my_tail_variate</span><span class="special">(</span> <span class="identifier">acc</span> <span class="special">).</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">iout</span> <span class="special">);</span>
</pre>
<p>
          There are several things to note about the code above. First, notice that
          we didn't have to request that the <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail.html" title="Struct template tail">tail</a></code> feature be calculated.
          That is implicit because the <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail_variate.html" title="Struct template tail_variate">tail_variate&lt;&gt;</a></code>
          feature depends on the <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail.html" title="Struct template tail">tail</a></code> feature. Next, notice
          how the <code class="computeroutput"><span class="identifier">acc</span></code> object is initialized:
          <code class="computeroutput"><span class="identifier">acc</span><span class="special">(</span>
          <span class="identifier">tag</span><span class="special">::</span><span class="identifier">tail</span><span class="special">&lt;</span><span class="identifier">left</span><span class="special">&gt;::</span><span class="identifier">cache_size</span> <span class="special">=</span>
          <span class="number">2</span> <span class="special">)</span></code>.
          Here, <code class="computeroutput"><span class="identifier">cache_size</span></code> is a named
          parameter. It is used to tell the <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail.html" title="Struct template tail">tail</a></code> and <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail_variate.html" title="Struct template tail_variate">tail_variate&lt;&gt;</a></code>
          accumulators how many samples and covariates to store. Conceptually, every
          construction parameter is made available to every accumulator in an accumulator
          set.
        </p>
<p>
          We also use a named parameter to pass covariate data into the accumulator
          set along with the samples. As with the constructor parameters, all parameters
          to the accumulate function are made available to all the accumulators in
          the set. In this case, only the accumulator for the <code class="computeroutput"><span class="identifier">my_tail_variate</span></code>
          feature would be interested in the value of the <code class="computeroutput"><span class="identifier">covariate1</span></code>
          named parameter.
        </p>
<p>
          We can make one final observation about the example above. Since <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail.html" title="Struct template tail">tail</a></code>
          and <code class="computeroutput"><a class="link" href="../boost/accumulators/tag/tail_variate.html" title="Struct template tail_variate">tail_variate&lt;&gt;</a></code>
          are multi-valued features, the result we extract for them is represented
          as an iterator range. That is why we can say <code class="computeroutput"><span class="identifier">tail</span><span class="special">(</span> <span class="identifier">acc</span> <span class="special">).</span><span class="identifier">begin</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">tail</span><span class="special">(</span> <span class="identifier">acc</span> <span class="special">).</span><span class="identifier">end</span><span class="special">()</span></code>.
        </p>
<p>
          Even the extractors can accept named parameters. In a bit, we'll see a
          situation where that is useful.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.weighted_samples"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.weighted_samples" title="Weighted Samples">Weighted
        Samples</a>
</h4></div></div></div>
<p>
          Some accumulators, statistical accumulators in particular, deal with data
          that are <span class="emphasis"><em>weighted</em></span>. Each sample pushed into the accumulator
          has an associated weight, by which the sample is conceptually multiplied.
          The Statistical Accumulators Library provides an assortment of these weighted
          statistical accumulators. And many unweighted statistical accumulators
          have weighted variants. For instance, the weighted variant of the <code class="computeroutput"><span class="identifier">sum</span></code> accumulator is called <code class="computeroutput"><span class="identifier">weighted_sum</span></code>, and is calculated by accumulating
          all the samples multiplied by their weights.
        </p>
<p>
          To declare an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
          that accepts weighted samples, you must specify the type of the weight
          parameter as the 3rd template parameter, as follows:
        </p>
<pre class="programlisting"><span class="comment">// 3rd template parameter 'int' means this is a weighted</span>
<span class="comment">// accumulator set where the weights have type 'int'</span>
<span class="identifier">accumulator_set</span><span class="special">&lt;</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">features</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">sum</span> <span class="special">&gt;,</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">;</span>
</pre>
<p>
          When you specify a weight, all the accumulators in the set are replaced
          with their weighted equivalents. For example, the above <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
          declaration is equivalent to the following:
        </p>
<pre class="programlisting"><span class="comment">// Since we specified a weight, tag::sum becomes tag::weighted_sum</span>
<span class="identifier">accumulator_set</span><span class="special">&lt;</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">features</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">weighted_sum</span> <span class="special">&gt;,</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">;</span>
</pre>
<p>
          When passing samples to the accumulator set, you must also specify the
          weight of each sample. You can do that with the <code class="computeroutput"><span class="identifier">weight</span></code>
          named parameter, as follows:
        </p>
<pre class="programlisting"><span class="identifier">acc</span><span class="special">(</span><span class="number">1</span><span class="special">,</span> <span class="identifier">weight</span> <span class="special">=</span> <span class="number">2</span><span class="special">);</span> <span class="comment">//   1 * 2</span>
<span class="identifier">acc</span><span class="special">(</span><span class="number">2</span><span class="special">,</span> <span class="identifier">weight</span> <span class="special">=</span> <span class="number">4</span><span class="special">);</span> <span class="comment">//   2 * 4</span>
<span class="identifier">acc</span><span class="special">(</span><span class="number">3</span><span class="special">,</span> <span class="identifier">weight</span> <span class="special">=</span> <span class="number">6</span><span class="special">);</span> <span class="comment">// + 3 * 6</span>
                    <span class="comment">// -------</span>
                    <span class="comment">// =    28</span>
</pre>
<p>
          You can then extract the result with the <code class="computeroutput"><span class="identifier">sum</span><span class="special">()</span></code> extractor, as follows:
        </p>
<pre class="programlisting"><span class="comment">// This prints "28"</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">sum</span><span class="special">(</span><span class="identifier">acc</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            When working with weighted statistical accumulators from the Statistical
            Accumulators Library, be sure to include the appropriate header. For
            instance, <code class="computeroutput"><span class="identifier">weighted_sum</span></code>
            is defined in <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">accumulators</span><span class="special">/</span><span class="identifier">statistics</span><span class="special">/</span><span class="identifier">weighted_sum</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>.
          </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.numeric_operators_sub_library"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.numeric_operators_sub_library" title="Numeric Operators Sub-Library">Numeric
        Operators Sub-Library</a>
</h4></div></div></div>
<p>
          This section describes the function objects in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span></code>
          namespace, which is a sub-library that provides function objects and meta-functions
          corresponding to the infix operators in C++.
        </p>
<p>
          In the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">operators</span></code> namespace are additional operator
          overloads for some useful operations not provided by the standard library,
          such as multiplication of a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;&gt;</span></code> with a scalar.
        </p>
<p>
          In the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">functional</span></code> namespace are function object
          equivalents of the infix operators. These function object types are heterogeneous,
          and so are more general than the standard ones found in the <code class="literal">&lt;functional&gt;</code>
          header. They use the Boost.Typeof library to deduce the return types of
          the infix expressions they evaluate. In addition, they look within the
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">operators</span></code> namespace to consider any additional
          overloads that might be defined there.
        </p>
<p>
          In the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span></code> namespace are global polymorphic
          function objects corresponding to the function object types defined in
          the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">functional</span></code> namespace. For example, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">plus</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span> <span class="identifier">b</span><span class="special">)</span></code> is equivalent to <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;()(</span><span class="identifier">a</span><span class="special">,</span> <span class="identifier">b</span><span class="special">)</span></code>, and both are equivalent to <code class="computeroutput"><span class="keyword">using</span> <span class="keyword">namespace</span>
          <span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">operators</span><span class="special">;</span>
          <span class="identifier">a</span> <span class="special">+</span>
          <span class="identifier">b</span><span class="special">;</span></code>.
        </p>
<p>
          The Numeric Operators Sub-Library also gives several ways to sub-class
          and a way to sub-class and specialize operations. One way uses tag dispatching
          on the types of the operands. The other way is based on the compile-time
          properties of the operands.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework" title="Extending the Accumulators Framework">Extending
        the Accumulators Framework</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator">Defining
          a New Accumulator</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_feature">Defining
          a New Feature</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_extractor">Defining
          a New Extractor</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.controlling_dependencies">Controlling
          Dependencies</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.operators_ex">Specializing
          Numeric Operators</a></span></dt>
</dl></div>
<p>
          This section describes how to extend the Accumulators Framework by defining
          new accumulators, features and extractors. Also covered are how to control
          the dependency resolution of features within an accumulator set.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator" title="Defining a New Accumulator">Defining
          a New Accumulator</a>
</h5></div></div></div>
<p>
            All new accumulators must satisfy the <a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.concepts.accumulator_concept">Accumulator
            Concept</a>. Below is a sample class that satisfies the accumulator
            concept, which simply sums the values of all samples passed into it.
          </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">accumulators</span><span class="special">/</span><span class="identifier">framework</span><span class="special">/</span><span class="identifier">accumulator_base</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">accumulators</span><span class="special">/</span><span class="identifier">framework</span><span class="special">/</span><span class="identifier">parameters</span><span class="special">/</span><span class="identifier">sample</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>                           <span class="comment">// Putting your accumulators in the</span>
<span class="keyword">namespace</span> <span class="identifier">accumulators</span> <span class="special">{</span>                    <span class="comment">// impl namespace has some</span>
<span class="keyword">namespace</span> <span class="identifier">impl</span> <span class="special">{</span>                            <span class="comment">// advantages. See below.</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Sample</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">sum_accumulator</span>                      <span class="comment">// All accumulators should inherit from</span>
  <span class="special">:</span> <span class="identifier">accumulator_base</span>                        <span class="comment">// accumulator_base.</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">Sample</span> <span class="identifier">result_type</span><span class="special">;</span>             <span class="comment">// The type returned by result() below.</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Args</span><span class="special">&gt;</span>                 <span class="comment">// The constructor takes an argument pack.</span>
    <span class="identifier">sum_accumulator</span><span class="special">(</span><span class="identifier">Args</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">args</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">sum</span><span class="special">(</span><span class="identifier">args</span><span class="special">[</span><span class="identifier">sample</span> <span class="special">|</span> <span class="identifier">Sample</span><span class="special">()])</span>        <span class="comment">// Maybe there is an initial value in the</span>
    <span class="special">{</span>                                       <span class="comment">// argument pack. ('sample' is defined in</span>
    <span class="special">}</span>                                       <span class="comment">// sample.hpp, included above.)</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Args</span><span class="special">&gt;</span>                 <span class="comment">// The accumulate function is the function</span>
    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="special">()(</span><span class="identifier">Args</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">args</span><span class="special">)</span>     <span class="comment">// call operator, and it also accepts an</span>
    <span class="special">{</span>                                       <span class="comment">// argument pack.</span>
        <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">sum</span> <span class="special">+=</span> <span class="identifier">args</span><span class="special">[</span><span class="identifier">sample</span><span class="special">];</span>
    <span class="special">}</span>

    <span class="identifier">result_type</span> <span class="identifier">result</span><span class="special">(</span><span class="identifier">dont_care</span><span class="special">)</span> <span class="keyword">const</span>     <span class="comment">// The result function will also be passed</span>
    <span class="special">{</span>                                       <span class="comment">// an argument pack, but we don't use it here,</span>
        <span class="keyword">return</span> <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">sum</span><span class="special">;</span>                   <span class="comment">// so we use "dont_care" as the argument type.</span>
    <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">Sample</span> <span class="identifier">sum</span><span class="special">;</span>
<span class="special">};</span>

<span class="special">}}}</span>
</pre>
<p>
            Much of the above should be pretty self-explanatory, except for the use
            of argument packs which may be confusing if you have never used the
            <a href="../../../libs/parameter/index.html" target="_top">Boost.Parameter</a>
            library before. An argument pack is a cluster of values, each of which
            can be accessed with a key. So <code class="computeroutput"><span class="identifier">args</span><span class="special">[</span><span class="identifier">sample</span><span class="special">]</span></code> extracts from the pack the value associated
            with the <code class="computeroutput"><span class="identifier">sample</span></code> key.
            And the cryptic <code class="computeroutput"><span class="identifier">args</span><span class="special">[</span><span class="identifier">sample</span> <span class="special">|</span> <span class="identifier">Sample</span><span class="special">()]</span></code> evaluates to the value associated
            with the <code class="computeroutput"><span class="identifier">sample</span></code> key if
            it exists, or a default-constructed <code class="computeroutput"><span class="identifier">Sample</span></code>
            if it doesn't.
          </p>
<p>
            The example above demonstrates the most common attributes of an accumulator.
            There are other optional member functions that have special meaning.
            In particular:
          </p>
<div class="variablelist">
<p class="title"><b>Optional Accumulator Member Functions</b></p>
<dl>
<dt><span class="term"><code class="literal">on_drop(Args)</code></span></dt>
<dd><p>
                  Defines an action to be taken when this accumulator is dropped.
                  See the section on <a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.droppable_accumulators">Droppable
                  Accumulators</a>.
                </p></dd>
</dl>
</div>
<h4>
<a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.h0"></a>
            <span><a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.accessing_other_accumulators_in_the_set"></a></span><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.accessing_other_accumulators_in_the_set">Accessing
            Other Accumulators in the Set</a>
          </h4>
<p>
            Some accumulators depend on other accumulators within the same accumulator
            set. In those cases, it is necessary to be able to access those other
            accumulators. To make this possible, the <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
            passes a reference to itself when invoking the member functions of its
            contained accumulators. It can be accessed by using the special <code class="computeroutput"><span class="identifier">accumulator</span></code> key with the argument pack.
            Consider how we might implement <code class="computeroutput"><span class="identifier">mean_accumulator</span></code>:
          </p>
<pre class="programlisting"><span class="comment">// Mean == (Sum / Count)</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Sample</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">mean_accumulator</span> <span class="special">:</span> <span class="identifier">accumulator_base</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">Sample</span> <span class="identifier">result_type</span><span class="special">;</span>
    <span class="identifier">mean_accumulator</span><span class="special">(</span><span class="identifier">dont_care</span><span class="special">)</span> <span class="special">{}</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Args</span><span class="special">&gt;</span>
    <span class="identifier">result_type</span> <span class="identifier">result</span><span class="special">(</span><span class="identifier">Args</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">args</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">sum</span><span class="special">(</span><span class="identifier">args</span><span class="special">[</span><span class="identifier">accumulator</span><span class="special">])</span> <span class="special">/</span> <span class="identifier">count</span><span class="special">(</span><span class="identifier">args</span><span class="special">[</span><span class="identifier">accumulator</span><span class="special">]);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            <code class="computeroutput"><span class="identifier">mean</span></code> depends on the
            <code class="computeroutput"><span class="identifier">sum</span></code> and <code class="computeroutput"><span class="identifier">count</span></code> accumulators. (We'll see in the
            next section how to specify these dependencies.) The result of the mean
            accumulator is merely the result of the sum accumulator divided by the
            result of the count accumulator. Consider how we write that: <code class="computeroutput"><span class="identifier">sum</span><span class="special">(</span><span class="identifier">args</span><span class="special">[</span><span class="identifier">accumulator</span><span class="special">])</span>
            <span class="special">/</span> <span class="identifier">count</span><span class="special">(</span><span class="identifier">args</span><span class="special">[</span><span class="identifier">accumulator</span><span class="special">])</span></code>. The expression <code class="computeroutput"><span class="identifier">args</span><span class="special">[</span><span class="identifier">accumulator</span><span class="special">]</span></code> evaluates to a reference to the <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code> that contains this
            <code class="computeroutput"><span class="identifier">mean_accumulator</span></code>. It
            also contains the <code class="computeroutput"><span class="identifier">sum</span></code>
            and <code class="computeroutput"><span class="identifier">count</span></code> accumulators,
            and we can access their results with the extractors defined for those
            features: <code class="computeroutput"><span class="identifier">sum</span></code> and <code class="computeroutput"><span class="identifier">count</span></code>.
          </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              Accumulators that inherit from <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_base.html" title="Struct accumulator_base">accumulator_base</a></code> get
              an empty <code class="computeroutput"><span class="keyword">operator</span> <span class="special">()</span></code>,
              so accumulators like <code class="computeroutput"><span class="identifier">mean_accumulator</span></code>
              above need not define one.
            </p></td></tr>
</table></div>
<p>
            All the member functions that accept an argument pack have access to
            the enclosing <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
            via the <code class="computeroutput"><span class="identifier">accumulator</span></code> key,
            including the constructor. The accumulators within the set are constructed
            in an order determined by their interdependencies. As a result, it is
            safe for an accumulator to access one on which it depends during construction.
          </p>
<h4>
<a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.h1"></a>
            <span><a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.infix_notation_and_the_numeric_operators_sub_library"></a></span><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.infix_notation_and_the_numeric_operators_sub_library">Infix
            Notation and the Numeric Operators Sub-Library</a>
          </h4>
<p>
            Although not necessary, it can be a good idea to put your accumulator
            implementations in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">accumulators</span><span class="special">::</span><span class="identifier">impl</span></code>
            namespace. This namespace pulls in any operators defined in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">operators</span></code> namespace with a using directive.
            The Numeric Operators Sub-Library defines some additional overloads that
            will make your accumulators work with all sorts of data types.
          </p>
<p>
            Consider <code class="computeroutput"><span class="identifier">mean_accumulator</span></code>
            defined above. It divides the sum of the samples by the count. The type
            of the count is <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span></code>. What if the sample type doesn't
            define division by <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span></code>?
            That's the case for <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;&gt;</span></code>. You might think that if the
            sample type is <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;&gt;</span></code>,
            the code would not work, but in fact it does. That's because Numeric
            Operators Sub-Library defines an overloaded <code class="computeroutput"><span class="keyword">operator</span><span class="special">/</span></code> for <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;&gt;</span></code> and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span></code>.
            This operator is defined in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">operators</span></code>
            namespace and will be found within the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">accumulators</span><span class="special">::</span><span class="identifier">impl</span></code>
            namespace. That's why it's a good idea to put your accumulators there.
          </p>
<h4>
<a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.h2"></a>
            <span><a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.droppable_accumulators"></a></span><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_accumulator.droppable_accumulators">Droppable
            Accumulators</a>
          </h4>
<p>
            The term "droppable" refers to an accumulator that can be removed
            from the <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>.
            You can request that an accumulator be made droppable by using the <code class="computeroutput">droppable&lt;&gt;</code> class template.
          </p>
<pre class="programlisting"><span class="comment">// calculate sum and count, make sum droppable:</span>
<span class="identifier">accumulator_set</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">,</span> <span class="identifier">features</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">count</span><span class="special">,</span> <span class="identifier">droppable</span><span class="special">&lt;</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">sum</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">;</span>

<span class="comment">// add some data</span>
<span class="identifier">acc</span><span class="special">(</span><span class="number">3.0</span><span class="special">);</span>
<span class="identifier">acc</span><span class="special">(</span><span class="number">2.0</span><span class="special">);</span>

<span class="comment">// drop the sum (sum is 5 here)</span>
<span class="identifier">acc</span><span class="special">.</span><span class="identifier">drop</span><span class="special">&lt;</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">sum</span><span class="special">&gt;();</span>

<span class="comment">// add more data</span>
<span class="identifier">acc</span><span class="special">(</span><span class="number">1.0</span><span class="special">);</span>

<span class="comment">// This will display "3" and "5"</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">count</span><span class="special">(</span><span class="identifier">acc</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="char">' '</span> <span class="special">&lt;&lt;</span> <span class="identifier">sum</span><span class="special">(</span><span class="identifier">acc</span><span class="special">);</span>
</pre>
<p>
            Any accumulators that get added to an accumulator set in order to satisfy
            dependencies on droppable accumulators are themselves droppable. Consider
            the following accumulator:
          </p>
<pre class="programlisting"><span class="comment">// Sum is not droppable. Mean is droppable. Count, brought in to </span>
<span class="comment">// satisfy mean's dependencies, is implicitly droppable, too.</span>
<span class="identifier">accumulator_set</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">,</span> <span class="identifier">features</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">sum</span><span class="special">,</span> <span class="identifier">droppable</span><span class="special">&lt;</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">mean</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">;</span>
</pre>
<p>
            <code class="computeroutput"><span class="identifier">mean</span></code> depends on <code class="computeroutput"><span class="identifier">sum</span></code> and <code class="computeroutput"><span class="identifier">count</span></code>.
            Since <code class="computeroutput"><span class="identifier">mean</span></code> is droppable,
            so too is <code class="computeroutput"><span class="identifier">count</span></code>. However,
            we have explicitly requested that <code class="computeroutput"><span class="identifier">sum</span></code>
            be not droppable, so it isn't. Had we left <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">sum</span></code>
            out of the above declaration, the <code class="computeroutput"><span class="identifier">sum</span></code>
            accumulator would have been implicitly droppable.
          </p>
<p>
            A droppable accumulator is reference counted, and is only really dropped
            after all the accumulators that depend on it have been dropped. This
            can lead to some surprising behavior in some situations.
          </p>
<pre class="programlisting"><span class="comment">// calculate sum and mean, make mean droppable. </span>
<span class="identifier">accumulator_set</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">,</span> <span class="identifier">features</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">sum</span><span class="special">,</span> <span class="identifier">droppable</span><span class="special">&lt;</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">mean</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">;</span>

<span class="comment">// add some data</span>
<span class="identifier">acc</span><span class="special">(</span><span class="number">1.0</span><span class="special">);</span>
<span class="identifier">acc</span><span class="special">(</span><span class="number">2.0</span><span class="special">);</span>

<span class="comment">// drop the mean. mean's reference count</span>
<span class="comment">// drops to 0, so it's really dropped. So</span>
<span class="comment">// too, count's reference count drops to 0</span>
<span class="comment">// and is really dropped.</span>
<span class="identifier">acc</span><span class="special">.</span><span class="identifier">drop</span><span class="special">&lt;</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">mean</span><span class="special">&gt;();</span>

<span class="comment">// add more data. Sum continues to accumulate!</span>
<span class="identifier">acc</span><span class="special">(</span><span class="number">3.0</span><span class="special">);</span>

<span class="comment">// This will display "6 2 3"</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">sum</span><span class="special">(</span><span class="identifier">acc</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="char">' '</span>
          <span class="special">&lt;&lt;</span> <span class="identifier">count</span><span class="special">(</span><span class="identifier">acc</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="char">' '</span>
          <span class="special">&lt;&lt;</span> <span class="identifier">mean</span><span class="special">(</span><span class="identifier">acc</span><span class="special">);</span>
</pre>
<p>
            Note that at the point at which <code class="computeroutput"><span class="identifier">mean</span></code>
            is dropped, <code class="computeroutput"><span class="identifier">sum</span></code> is 3,
            <code class="computeroutput"><span class="identifier">count</span></code> is 2, and therefore
            <code class="computeroutput"><span class="identifier">mean</span></code> is 1.5. But since
            <code class="computeroutput"><span class="identifier">sum</span></code> continues to accumulate
            even after <code class="computeroutput"><span class="identifier">mean</span></code> has been
            dropped, the value of <code class="computeroutput"><span class="identifier">mean</span></code>
            continues to change. If you want to remember the value of <code class="computeroutput"><span class="identifier">mean</span></code> at the point it is dropped, you
            should save its value into a local variable.
          </p>
<p>
            The following rules more precisely specify how droppable and non-droppable
            accumulators behave within an accumulator set.
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                There are two types of accumulators: droppable and non-droppable.
                The default is non-droppable.
              </li>
<li class="listitem">
                For any feature <code class="computeroutput"><span class="identifier">X</span></code>,
                both <code class="computeroutput"><span class="identifier">X</span></code> and <code class="computeroutput"><span class="identifier">droppable</span><span class="special">&lt;</span><span class="identifier">X</span><span class="special">&gt;</span></code>
                satisfy the <code class="computeroutput"><span class="identifier">X</span></code> dependency.
              </li>
<li class="listitem">
                If feature <code class="computeroutput"><span class="identifier">X</span></code> depends
                on <code class="computeroutput"><span class="identifier">Y</span></code> and <code class="computeroutput"><span class="identifier">Z</span></code>, then <code class="computeroutput"><span class="identifier">droppable</span><span class="special">&lt;</span><span class="identifier">X</span><span class="special">&gt;</span></code> depends on <code class="computeroutput"><span class="identifier">droppable</span><span class="special">&lt;</span><span class="identifier">Y</span><span class="special">&gt;</span></code> and <code class="computeroutput"><span class="identifier">droppable</span><span class="special">&lt;</span><span class="identifier">Z</span><span class="special">&gt;</span></code>.
              </li>
<li class="listitem">
                All accumulators have <code class="computeroutput"><span class="identifier">add_ref</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">drop</span><span class="special">()</span></code> member functions.
              </li>
<li class="listitem">
                For non-droppable accumulators, <code class="computeroutput"><span class="identifier">drop</span><span class="special">()</span></code> is a no-op, and <code class="computeroutput"><span class="identifier">add_ref</span><span class="special">()</span></code> invokes <code class="computeroutput"><span class="identifier">add_ref</span><span class="special">()</span></code> on all accumulators corresponding
                to the features upon which the current accumulator depends.
              </li>
<li class="listitem">
                Droppable accumulators have a reference count and define <code class="computeroutput"><span class="identifier">add_ref</span><span class="special">()</span></code>
                and <code class="computeroutput"><span class="identifier">drop</span><span class="special">()</span></code>
                to manipulate the reference count.
              </li>
<li class="listitem">
                For droppable accumulators, <code class="computeroutput"><span class="identifier">add_ref</span><span class="special">()</span></code> increments the accumulator's reference
                count, and also <code class="computeroutput"><span class="identifier">add_ref</span><span class="special">()</span></code>'s the accumulators corresponding
                to the features upon which the current accumulator depends.
              </li>
<li class="listitem">
                For droppable accumulators, <code class="computeroutput"><span class="identifier">drop</span><span class="special">()</span></code> decrements the accumulator's reference
                count, and also <code class="computeroutput"><span class="identifier">drop</span><span class="special">()</span></code>'s the accumulators corresponding
                to the features upon which the current accumulator depends.
              </li>
<li class="listitem">
                The accumulator_set constructor walks the list of <span class="bold"><strong>user-specified</strong></span>
                features and <code class="computeroutput"><span class="identifier">add_ref</span><span class="special">()</span></code>'s the accumulator that corresponds
                to each of them. (Note: that means that an accumulator that is not
                user-specified but in the set merely to satisfy a dependency will
                be dropped as soon as all its dependencies have been dropped. Ones
                that have been user specified are not dropped until their dependencies
                have been dropped <span class="bold"><strong>and</strong></span> the user has
                explicitly dropped the accumulator.)
              </li>
<li class="listitem">
                Droppable accumulators check their reference count in their accumulate
                member function. If the reference count is 0, the function is a no-op.
              </li>
<li class="listitem">
                Users are not allowed to drop a feature that is not user-specified
                and marked as droppable.
              </li>
</ul></div>
<p>
            And as an optimization:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                If the user specifies the non-droppable feature <code class="computeroutput"><span class="identifier">X</span></code>,
                which depends on <code class="computeroutput"><span class="identifier">Y</span></code>
                and <code class="computeroutput"><span class="identifier">Z</span></code>, then the accumulators
                for <code class="computeroutput"><span class="identifier">Y</span></code> and <code class="computeroutput"><span class="identifier">Z</span></code> can be safely made non-droppable,
                as well as any accumulators on which they depend.
              </li></ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_feature"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_feature" title="Defining a New Feature">Defining
          a New Feature</a>
</h5></div></div></div>
<p>
            Once we have implemented an accumulator, we must define a feature for
            it so that users can specify the feature when declaring an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>. We typically put
            the features into a nested namespace, so that later we can define an
            extractor of the same name. All features must satisfy the <a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.concepts.feature_concept">Feature
            Concept</a>. Using <code class="computeroutput"><a class="link" href="../boost/accumulators/depends_on.html" title="Struct template depends_on">depends_on&lt;&gt;</a></code>
            makes satisfying the concept simple. Below is an example of a feature
            definition.
          </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">accumulators</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">tag</span> <span class="special">{</span>

<span class="keyword">struct</span> <span class="identifier">mean</span>                         <span class="comment">// Features should inherit from</span>
  <span class="special">:</span> <span class="identifier">depends_on</span><span class="special">&lt;</span> <span class="identifier">count</span><span class="special">,</span> <span class="identifier">sum</span> <span class="special">&gt;</span>        <span class="comment">// depends_on&lt;&gt; to specify dependencies</span>
<span class="special">{</span>
    <span class="comment">// Define a nested typedef called 'impl' that specifies which</span>
    <span class="comment">// accumulator implements this feature. </span>
    <span class="keyword">typedef</span> <span class="identifier">accumulators</span><span class="special">::</span><span class="identifier">impl</span><span class="special">::</span><span class="identifier">mean_accumulator</span><span class="special">&lt;</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span> <span class="special">&gt;</span> <span class="identifier">impl</span><span class="special">;</span>
<span class="special">};</span>

<span class="special">}}}</span>
</pre>
<p>
            The only two things we must do to define the <code class="computeroutput"><span class="identifier">mean</span></code>
            feature is to specify the dependencies with <code class="computeroutput"><a class="link" href="../boost/accumulators/depends_on.html" title="Struct template depends_on">depends_on&lt;&gt;</a></code>
            and define the nested <code class="computeroutput"><span class="identifier">impl</span></code>
            typedef. Even features that have no dependencies should inherit from
            <code class="computeroutput"><a class="link" href="../boost/accumulators/depends_on.html" title="Struct template depends_on">depends_on&lt;&gt;</a></code>. The nested <code class="computeroutput"><span class="identifier">impl</span></code> type must be an <a href="../../../libs/mpl/doc/refmanual/lambda-expression.html" target="_top">MPL
            Lambda Expression</a>. The result of <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">apply</span><span class="special">&lt;</span> <span class="identifier">impl</span><span class="special">,</span> <em class="replaceable"><code>sample-type</code></em><span class="special">,</span> <em class="replaceable"><code>weight-type</code></em> <span class="special">&gt;::</span><span class="identifier">type</span></code> must be be the type of the accumulator
            that implements this feature. The use of <a href="../../../libs/mpl/index.html" target="_top">MPL</a>
            placeholders like <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span></code>
            make it especially easy to make a template such as <code class="computeroutput"><span class="identifier">mean_accumulator</span><span class="special">&lt;&gt;</span></code> an <a href="../../../libs/mpl/doc/refmanual/lambda-expression.html" target="_top">MPL
            Lambda Expression</a>. Here, <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_1</span></code>
            will be replaced with the sample type. Had we used <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">_2</span></code>,
            it would have been replaced with the weight type.
          </p>
<p>
            What about accumulator types that are not templates? If you have a <code class="computeroutput"><span class="identifier">foo_accumulator</span></code> which is a plain struct
            and not a template, you could turn it into an <a href="../../../libs/mpl/doc/refmanual/lambda-expression.html" target="_top">MPL
            Lambda Expression</a> using <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">always</span><span class="special">&lt;&gt;</span></code>, like this:
          </p>
<pre class="programlisting"><span class="comment">// An MPL lambda expression that always evaluates to</span>
<span class="comment">// foo_accumulator:</span>
<span class="keyword">typedef</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">always</span><span class="special">&lt;</span> <span class="identifier">foo_accumulator</span> <span class="special">&gt;</span> <span class="identifier">impl</span><span class="special">;</span>
</pre>
<p>
            If you are ever unsure, or if you are not comfortable with MPL lambda
            expressions, you could always define <code class="computeroutput"><span class="identifier">impl</span></code>
            explicitly:
          </p>
<pre class="programlisting"><span class="comment">// Same as 'typedef mpl::always&lt; foo_accumulator &gt; impl;'</span>
<span class="keyword">struct</span> <span class="identifier">impl</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Sample</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Weight</span> <span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">apply</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">foo_accumulator</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>
<span class="special">};</span>
</pre>
<p>
            Here, <code class="computeroutput"><span class="identifier">impl</span></code> is a binary
            <a href="../../../libs/mpl/doc/refmanual/metafunction-class.html" target="_top">MPL
            Metafunction Class</a>, which is a kind of <a href="../../../libs/mpl/doc/refmanual/lambda-expression.html" target="_top">MPL
            Lambda Expression</a>. The nested <code class="computeroutput"><span class="identifier">apply</span><span class="special">&lt;&gt;</span></code> template is part of the metafunction
            class protocol and tells MPL how to build the accumulator type given
            the sample and weight types.
          </p>
<p>
            All features must also provide a nested <code class="computeroutput"><span class="identifier">is_weight_accumulator</span></code>
            typedef. It must be either <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span></code>
            or <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span></code>. <code class="computeroutput"><a class="link" href="../boost/accumulators/depends_on.html" title="Struct template depends_on">depends_on&lt;&gt;</a></code>
            provides a default of <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span></code>
            for all features that inherit from it, but that can be overridden (or
            hidden, technically speaking) in the derived type. When the feature represents
            an accumulation of information about the weights instead of the samples,
            we can mark this feature as such with <code class="computeroutput"><span class="keyword">typedef</span>
            <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span> <span class="identifier">is_weight_accumulator</span><span class="special">;</span></code>. The weight accumulators are made external
            if the weight type is specified using the <code class="computeroutput">external&lt;&gt;</code>
            template.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_extractor"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_extractor" title="Defining a New Extractor">Defining
          a New Extractor</a>
</h5></div></div></div>
<p>
            Now that we have an accumulator and a feature, the only thing lacking
            is a way to get results from the accumulator set. The Accumulators Framework
            provides the <code class="computeroutput">extractor&lt;&gt;</code>
            class template to make it simple to define an extractor for your feature.
            Here's an extractor for the <code class="computeroutput"><span class="identifier">mean</span></code>
            feature we defined above:
          </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
<span class="keyword">namespace</span> <span class="identifier">accumulators</span> <span class="special">{</span>                <span class="comment">// By convention, we put extractors</span>
<span class="keyword">namespace</span> <span class="identifier">extract</span> <span class="special">{</span>                     <span class="comment">// in the 'extract' namespace</span>

<span class="identifier">extractor</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">mean</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">mean</span> <span class="special">=</span> <span class="special">{};</span> <span class="comment">// Simply define our extractor with</span>
                                        <span class="comment">// our feature tag, like this.</span>
<span class="special">}</span>
<span class="keyword">using</span> <span class="identifier">extract</span><span class="special">::</span><span class="identifier">mean</span><span class="special">;</span>                    <span class="comment">// Pull the extractor into the</span>
                                        <span class="comment">// enclosing namespace.</span>
<span class="special">}}</span>
</pre>
<p>
            Once defined, the <code class="computeroutput"><span class="identifier">mean</span></code>
            extractor can be used to extract the result of the <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">mean</span></code>
            feature from an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>.
          </p>
<p>
            Parameterized features complicate this simple picture. Consider the
            <code class="computeroutput"><span class="identifier">moment</span></code> feature, for calculating
            the <code class="literal"><span class="emphasis"><em>N</em></span></code>-th moment, where <code class="literal"><span class="emphasis"><em>N</em></span></code>
            is specified as a template parameter:
          </p>
<pre class="programlisting"><span class="comment">// An accumulator set for calculating the N-th moment, for N == 2 ...</span>
<span class="identifier">accumulator_set</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">,</span> <span class="identifier">features</span><span class="special">&lt;</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">moment</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">acc</span><span class="special">;</span>

<span class="comment">// ... add some data ...</span>

<span class="comment">// Display the 2nd moment ...</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"2nd moment is "</span> <span class="special">&lt;&lt;</span> <span class="identifier">accumulators</span><span class="special">::</span><span class="identifier">moment</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;(</span><span class="identifier">acc</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
            In the expression <code class="computeroutput"><span class="identifier">accumulators</span><span class="special">::</span><span class="identifier">moment</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;(</span><span class="identifier">acc</span><span class="special">)</span></code>,
            what is <code class="computeroutput"><span class="identifier">moment</span></code>? It cannot
            be an object -- the syntax of C++ will not allow it. Clearly, if we want
            to provide this syntax, we must make <code class="computeroutput"><span class="identifier">moment</span></code>
            a function template. Here's what the definition of the <code class="computeroutput"><span class="identifier">moment</span></code> extractor looks like:
          </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
<span class="keyword">namespace</span> <span class="identifier">accumulators</span> <span class="special">{</span>                <span class="comment">// By convention, we put extractors</span>
<span class="keyword">namespace</span> <span class="identifier">extract</span> <span class="special">{</span>                     <span class="comment">// in the 'extract' namespace</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">N</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">AccumulatorSet</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">apply</span><span class="special">&lt;</span><span class="identifier">AccumulatorSet</span><span class="special">,</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">moment</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">result_type</span>
<span class="identifier">moment</span><span class="special">(</span><span class="identifier">AccumulatorSet</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">acc</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">extract_result</span><span class="special">&lt;</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">moment</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">&gt;</span> <span class="special">&gt;(</span><span class="identifier">acc</span><span class="special">);</span>
<span class="special">}</span>

<span class="special">}</span>
<span class="keyword">using</span> <span class="identifier">extract</span><span class="special">::</span><span class="identifier">moment</span><span class="special">;</span>                  <span class="comment">// Pull the extractor into the</span>
                                        <span class="comment">// enclosing namespace.</span>
<span class="special">}}</span>
</pre>
<p>
            The return type deserves some explanation. Every <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
            type is actually a unary <a href="../../../libs/mpl/doc/refmanual/metafunction-class.html" target="_top">MPL
            Metafunction Class</a>. When you <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">apply</span><span class="special">&lt;&gt;</span></code> an <code class="computeroutput"><a class="link" href="../boost/accumulators/accumulator_set.html" title="Struct template accumulator_set">accumulator_set&lt;&gt;</a></code>
            and a feature, the result is the type of the accumulator within the set
            that implements that feature. And every accumulator provides a nested
            <code class="computeroutput"><span class="identifier">result_type</span></code> typedef that
            tells what its return type is. The extractor simply delegates its work
            to the <code class="computeroutput"><a class="link" href="reference.html#boost.accumulators.extract_result_idp15076672">extract_result()</a></code>
            function.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.controlling_dependencies"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.controlling_dependencies" title="Controlling Dependencies">Controlling
          Dependencies</a>
</h5></div></div></div>
<p>
            The feature-based dependency resolution of the Accumulators Framework
            is designed to allow multiple different implementation strategies for
            each feature. For instance, two different accumulators may calculate
            the same quantity with different rounding modes, or using different algorithms
            with different size/speed tradeoffs. Other accumulators that depend on
            that quantity shouldn't care how it's calculated. The Accumulators Framework
            handles this by allowing several different accumulators satisfy the same
            feature.
          </p>
<p>
            <span class="bold"><strong>Aliasing feature dependencies with <code class="literal">feature_of&lt;&gt;</code></strong></span>
          </p>
<p>
            Imagine that you would like to implement the hypothetical <span class="emphasis"><em>fubar</em></span>
            statistic, and that you know two ways to calculate fubar on a bunch of
            samples: an accurate but slow calculation and an approximate but fast
            calculation. You might opt to make the accurate calculation the default,
            so you implement two accumulators and call them <code class="computeroutput"><span class="identifier">impl</span><span class="special">::</span><span class="identifier">fubar_impl</span></code>
            and <code class="computeroutput"><span class="identifier">impl</span><span class="special">::</span><span class="identifier">fast_fubar_impl</span></code>. You would also define
            the <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fubar</span></code> and <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fast_fubar</span></code>
            features as described <a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.defining_a_new_feature" title="Defining a New Feature">above</a>.
            Now, you would like to inform the Accumulators Framework that these two
            features are the same from the point of view of dependency resolution.
            You can do that with <code class="computeroutput"><a class="link" href="../boost/accumulators/feature_of.html" title="Struct template feature_of">feature_of&lt;&gt;</a></code>,
            as follows:
          </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">accumulators</span>
<span class="special">{</span>
    <span class="comment">// For the purposes of feature-based dependency resolution,</span>
    <span class="comment">// fast_fubar provides the same feature as fubar</span>
    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">feature_of</span><span class="special">&lt;</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fast_fubar</span><span class="special">&gt;</span>
      <span class="special">:</span> <span class="identifier">feature_of</span><span class="special">&lt;</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fubar</span><span class="special">&gt;</span>
    <span class="special">{</span>
    <span class="special">};</span>
<span class="special">}}</span>
</pre>
<p>
            The above code instructs the Accumulators Framework that, if another
            accumulator in the set depends on the <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fubar</span></code>
            feature, the <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fast_fubar</span></code> feature is an acceptable
            substitute.
          </p>
<p>
            <span class="bold"><strong>Registering feature variants with <code class="literal">as_feature&lt;&gt;</code></strong></span>
          </p>
<p>
            You may have noticed that some feature variants in the Accumulators Framework
            can be specified with a nicer syntax. For instance, instead of <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">mean</span></code> and <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">immediate_mean</span></code>
            you can specify them with <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">mean</span><span class="special">(</span><span class="identifier">lazy</span><span class="special">)</span></code> and <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">mean</span><span class="special">(</span><span class="identifier">immediate</span><span class="special">)</span></code> respectively. These are merely aliases,
            but the syntax makes the relationship between the two clearer. You can
            create these feature aliases with the <code class="computeroutput"><a class="link" href="../boost/accumulators/as_feature.html" title="Struct template as_feature">as_feature&lt;&gt;</a></code>
            trait. Given the fubar example above, you might decide to alias <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fubar</span><span class="special">(</span><span class="identifier">accurate</span><span class="special">)</span></code>
            with <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fubar</span></code> and <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fubar</span><span class="special">(</span><span class="identifier">fast</span><span class="special">)</span></code> with <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fast_fubar</span></code>.
            You would do that as follows:
          </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">accumulators</span>
<span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">fast</span> <span class="special">{};</span>     <span class="comment">// OK to leave these tags empty</span>
    <span class="keyword">struct</span> <span class="identifier">accurate</span> <span class="special">{};</span>

    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">as_feature</span><span class="special">&lt;</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fubar</span><span class="special">(</span><span class="identifier">accurate</span><span class="special">)&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">fubar</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">as_feature</span><span class="special">&lt;</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fubar</span><span class="special">(</span><span class="identifier">fast</span><span class="special">)&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">tag</span><span class="special">::</span><span class="identifier">fast_fubar</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>
<span class="special">}}</span>
</pre>
<p>
            Once you have done this, users of your fubar accumulator can request
            the <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fubar</span><span class="special">(</span><span class="identifier">fast</span><span class="special">)</span></code>
            and <code class="computeroutput"><span class="identifier">tag</span><span class="special">::</span><span class="identifier">fubar</span><span class="special">(</span><span class="identifier">accurate</span><span class="special">)</span></code>
            features when defining their <code class="computeroutput"><span class="identifier">accumulator_set</span></code>s
            and get the correct accumulator.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.operators_ex"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.extending_the_accumulators_framework.operators_ex" title="Specializing Numeric Operators">Specializing
          Numeric Operators</a>
</h5></div></div></div>
<p>
            This section describes how to adapt third-party numeric types to work
            with the Accumulator Framework.
          </p>
<p>
            Rather than relying on the built-in operators, the Accumulators Framework
            relies on functions and operator overloads defined in the <a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.numeric_operators_sub_library" title="Numeric Operators Sub-Library">Numeric
            Operators Sub-Library</a> for many of its numeric operations. This
            is so that it is possible to assign non-standard meanings to arithmetic
            operations. For instance, when calculating an average by dividing two
            integers, the standard integer division behavior would be mathematically
            incorrect for most statistical quantities. So rather than use <code class="computeroutput"><span class="identifier">x</span> <span class="special">/</span> <span class="identifier">y</span></code>, the Accumulators Framework uses
            <code class="computeroutput"><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">fdiv</span><span class="special">(</span><span class="identifier">x</span><span class="special">,</span> <span class="identifier">y</span><span class="special">)</span></code>,
            which does floating-point division even if both <code class="computeroutput"><span class="identifier">x</span></code>
            and <code class="computeroutput"><span class="identifier">y</span></code> are integers.
          </p>
<p>
            Another example where the Numeric Operators Sub-Library is useful is
            when a type does not define the operator overloads required to use it
            for some statistical calculations. For instance, <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code> does not overload any arithmetic
            operators, yet it may be useful to use <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code> as a sample or variate type.
            The Numeric Operators Sub-Library defines the necessary operator overloads
            in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">operators</span></code> namespace, which is brought
            into scope by the Accumulators Framework with a using directive.
          </p>
<p>
            <span class="bold"><strong>Numeric Function Objects and Tag Dispatching</strong></span>
          </p>
<p>
            How are the numeric function object defined by the Numeric Operators
            Sub-Library made to work with types such as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code>? The free functions in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span></code> namespace are implemented in
            terms of the function objects in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">functional</span></code>
            namespace, so to make <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">fdiv</span><span class="special">()</span></code> do something sensible with a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;&gt;</span></code>,
            for instance, we'll need to partially specialize the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">fdiv</span><span class="special">&lt;&gt;</span></code> function object.
          </p>
<p>
            The functional objects make use of a technique known as <a href="http://www.boost.org/community/generic_programming.html#tag_dispatching" target="_top"><span class="emphasis"><em>tag
            dispatching</em></span></a> to select the proper implementation for
            the given operands. It works as follows:
          </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">numeric</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">functional</span>
<span class="special">{</span>
    <span class="comment">// Metafunction for looking up the tag associated with</span>
    <span class="comment">// a given numeric type T.</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">tag</span>
    <span class="special">{</span>
        <span class="comment">// by default, all types have void as a tag type</span>
        <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="comment">// Forward declaration looks up the tag types of each operand</span>
    <span class="keyword">template</span><span class="special">&lt;</span>
        <span class="keyword">typename</span> <span class="identifier">Left</span>
      <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Right</span>
      <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">LeftTag</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">Left</span><span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">RightTag</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">Right</span><span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">fdiv</span><span class="special">;</span>
<span class="special">}}}</span>
</pre>
<p>
            If you have some user-defined type <code class="computeroutput"><span class="identifier">MyDouble</span></code>
            for which you would like to customize the behavior of <code class="computeroutput"><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">fdiv</span><span class="special">()</span></code>, you would specialize <code class="computeroutput"><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">fdiv</span><span class="special">&lt;&gt;</span></code>
            by first defining a tag type, as shown below:
          </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">numeric</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">functional</span>
<span class="special">{</span>
    <span class="comment">// Tag type for MyDouble</span>
    <span class="keyword">struct</span> <span class="identifier">MyDoubleTag</span> <span class="special">{};</span>

    <span class="comment">// Specialize tag&lt;&gt; for MyDouble.</span>
    <span class="comment">// This only needs to be done once.</span>
    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">tag</span><span class="special">&lt;</span><span class="identifier">MyDouble</span><span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">MyDoubleTag</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="comment">// Specify how to divide a MyDouble by an integral count</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Left</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Right</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">fdiv</span><span class="special">&lt;</span><span class="identifier">Left</span><span class="special">,</span> <span class="identifier">Right</span><span class="special">,</span> <span class="identifier">MyDoubleTag</span><span class="special">,</span> <span class="keyword">void</span><span class="special">&gt;</span>
    <span class="special">{</span>
        <span class="comment">// Define the type of the result</span>
        <span class="keyword">typedef</span> <span class="special">...</span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Left</span> <span class="special">&amp;</span> <span class="identifier">left</span><span class="special">,</span> <span class="identifier">Right</span> <span class="special">&amp;</span> <span class="identifier">right</span><span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="special">...;</span>
        <span class="special">}</span>
    <span class="special">};</span>
<span class="special">}}}</span>
</pre>
<p>
            Once you have done this, <code class="computeroutput"><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">fdiv</span><span class="special">()</span></code> will use your specialization of <code class="computeroutput"><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">fdiv</span><span class="special">&lt;&gt;</span></code>
            when the first argument is a <code class="computeroutput"><span class="identifier">MyDouble</span></code>
            object. All of the function objects in the Numeric Operators Sub-Library
            can be customized in a similar fashion.
          </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="accumulators.user_s_guide.the_accumulators_framework.concepts"></a><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.concepts" title="Concepts">Concepts</a>
</h4></div></div></div>
<h3>
<a name="accumulators.user_s_guide.the_accumulators_framework.concepts.h0"></a>
          <span><a name="accumulators.user_s_guide.the_accumulators_framework.concepts.accumulator_concept"></a></span><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.concepts.accumulator_concept">Accumulator
          Concept</a>
        </h3>
<p>
          In the following table, <code class="computeroutput"><span class="identifier">Acc</span></code>
          is the type of an accumulator, <code class="computeroutput"><span class="identifier">acc</span></code>
          and <code class="computeroutput"><span class="identifier">acc2</span></code> are objects of
          type <code class="computeroutput"><span class="identifier">Acc</span></code>, and <code class="computeroutput"><span class="identifier">args</span></code> is the name of an argument pack
          from the <a href="../../../libs/parameter/index.html" target="_top">Boost.Parameter</a>
          library.
        </p>
<div class="table">
<a name="accumulators.user_s_guide.the_accumulators_framework.concepts.t0"></a><p class="title"><b>Table&#160;1.2.&#160;Accumulator Requirements</b></p>
<div class="table-contents"><table class="table" summary="Accumulator Requirements">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    <span class="bold"><strong>Expression</strong></span>
                  </p>
                </th>
<th>
                  <p>
                    <span class="bold"><strong>Return type</strong></span>
                  </p>
                </th>
<th>
                  <p>
                    <span class="bold"><strong>Assertion / Note / Pre- / Post-condition</strong></span>
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">Acc</span><span class="special">::</span><span class="identifier">result_type</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <span class="emphasis"><em>implementation defined</em></span>
                  </p>
                </td>
<td>
                  <p>
                    The type returned by <code class="computeroutput"><span class="identifier">Acc</span><span class="special">::</span><span class="identifier">result</span><span class="special">()</span></code>.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">Acc</span> <span class="identifier">acc</span><span class="special">(</span><span class="identifier">args</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    none
                  </p>
                </td>
<td>
                  <p>
                    Construct from an argument pack.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">Acc</span> <span class="identifier">acc</span><span class="special">(</span><span class="identifier">acc2</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    none
                  </p>
                </td>
<td>
                  <p>
                    Post: <code class="computeroutput"><span class="identifier">acc</span><span class="special">.</span><span class="identifier">result</span><span class="special">(</span><span class="identifier">args</span><span class="special">)</span></code>
                    is equivalent to <code class="computeroutput"><span class="identifier">acc2</span><span class="special">.</span><span class="identifier">result</span><span class="special">(</span><span class="identifier">args</span><span class="special">)</span></code>
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">acc</span><span class="special">(</span><span class="identifier">args</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <span class="emphasis"><em>unspecified</em></span>
                  </p>
                </td>
<td>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">acc</span><span class="special">.</span><span class="identifier">on_drop</span><span class="special">(</span><span class="identifier">args</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <span class="emphasis"><em>unspecified</em></span>
                  </p>
                </td>
<td>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">acc</span><span class="special">.</span><span class="identifier">result</span><span class="special">(</span><span class="identifier">args</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">Acc</span><span class="special">::</span><span class="identifier">result_type</span></code>
                  </p>
                </td>
<td>
                </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><h3>
<a name="accumulators.user_s_guide.the_accumulators_framework.concepts.h1"></a>
          <span><a name="accumulators.user_s_guide.the_accumulators_framework.concepts.feature_concept"></a></span><a class="link" href="user_s_guide.html#accumulators.user_s_guide.the_accumulators_framework.concepts.feature_concept">Feature
          Concept</a>
        </h3>
<p>
          In the following table, <code class="computeroutput"><span class="identifier">F</span></code>
          is the type of a feature and <code class="computeroutput"><span class="identifier">S</span></code>
          is some scalar type.
        </p>
<div class="table">
<a name="accumulators.user_s_guide.the_accumulators_framework.concepts.t1"></a><p class="title"><b>Table&#160;1.3.&#160;Feature Requirements</b></p>
<div class="table-contents"><table class="table" summary="Feature Requirements">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    <span class="bold"><strong>Expression</strong></span>
                  </p>
                </th>
<th>
                  <p>
                    <span class="bold"><strong>Return type</strong></span>
                  </p>
                </th>
<th>
                  <p>
                    <span class="bold"><strong>Assertion / Note / Pre- / Post-condition</strong></span>
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">F</span><span class="special">::</span><span class="identifier">dependencies</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <span class="emphasis"><em>unspecified</em></span>
                  </p>
                </td>
<td>
                  <p>
                    An MPL sequence of other features on which <code class="computeroutput"><span class="identifier">F</span></code>
                    depends.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">F</span><span class="special">::</span><span class="identifier">is_weight_accumulator</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span></code> or <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span></code> if the accumulator for
                    this feature should be made external when the weight type for
                    the accumulator set is <code class="computeroutput"><span class="identifier">external</span><span class="special">&lt;</span><span class="identifier">S</span><span class="special">&gt;</span></code>, <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span></code>
                    otherwise.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">F</span><span class="special">::</span><span class="identifier">impl</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <span class="emphasis"><em>unspecified</em></span>
                  </p>
                </td>
<td>
                  <p>
                    An <a href="../../../libs/mpl/doc/refmanual/lambda-expression.html" target="_top">MPL
                    Lambda Expression</a> that returns the type of the accumulator
                    that implements this feature when passed a sample type and a
                    weight type.
                  </p>
                </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2005, 2006 Eric Niebler<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="user_s_guide/the_statistical_accumulators_library.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
