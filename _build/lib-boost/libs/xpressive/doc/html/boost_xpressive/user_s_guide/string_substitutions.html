<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>String Substitutions</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Boost.Xpressive">
<link rel="up" href="../../xpressive/user_s_guide.html" title="User's Guide">
<link rel="prev" href="accessing_results.html" title="Accessing Results">
<link rel="next" href="string_splitting_and_tokenization.html" title="String Splitting and Tokenization">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="accessing_results.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../xpressive/user_s_guide.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="string_splitting_and_tokenization.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.string_substitutions"></a><a class="link" href="string_substitutions.html" title="String Substitutions">String
      Substitutions</a>
</h3></div></div></div>
<p>
        Regular expressions are not only good for searching text; they're good at
        <span class="emphasis"><em>manipulating</em></span> it. And one of the most common text manipulation
        tasks is search-and-replace. xpressive provides the <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        algorithm for searching and replacing.
      </p>
<h3>
<a name="boost_xpressive.user_s_guide.string_substitutions.h0"></a>
        <span><a name="boost_xpressive.user_s_guide.string_substitutions.regex_replace__"></a></span><a class="link" href="string_substitutions.html#boost_xpressive.user_s_guide.string_substitutions.regex_replace__">regex_replace()</a>
      </h3>
<p>
        Performing search-and-replace using <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        is simple. All you need is an input sequence, a regex object, and a format
        string or a formatter object. There are several versions of the <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        algorithm. Some accept the input sequence as a bidirectional container such
        as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> and returns the result in a new
        container of the same type. Others accept the input as a null terminated
        string and return a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>. Still others accept the input sequence
        as a pair of iterators and writes the result into an output iterator. The
        substitution may be specified as a string with format sequences or as a formatter
        object. Below are some simple examples of using string-based substitutions.
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"This is his face"</span><span class="special">);</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">as_xpr</span><span class="special">(</span><span class="string">"his"</span><span class="special">);</span>                <span class="comment">// find all occurrences of "his" ...</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">format</span><span class="special">(</span><span class="string">"her"</span><span class="special">);</span>                <span class="comment">// ... and replace them with "her"</span>

<span class="comment">// use the version of regex_replace() that operates on strings</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">output</span> <span class="special">=</span> <span class="identifier">regex_replace</span><span class="special">(</span> <span class="identifier">input</span><span class="special">,</span> <span class="identifier">re</span><span class="special">,</span> <span class="identifier">format</span> <span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">output</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>

<span class="comment">// use the version of regex_replace() that operates on iterators</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="special">&gt;</span> <span class="identifier">out_iter</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">);</span>
<span class="identifier">regex_replace</span><span class="special">(</span> <span class="identifier">out_iter</span><span class="special">,</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">re</span><span class="special">,</span> <span class="identifier">format</span> <span class="special">);</span>
</pre>
<p>
        The above program prints out the following:
      </p>
<pre class="programlisting">Ther is her face
Ther is her face
</pre>
<p>
        Notice that <span class="emphasis"><em>all</em></span> the occurrences of <code class="computeroutput"><span class="string">"his"</span></code>
        have been replaced with <code class="computeroutput"><span class="string">"her"</span></code>.
      </p>
<p>
        Click <a class="link" href="examples.html#boost_xpressive.user_s_guide.examples.replace_all_sub_strings_that_match_a_regex">here</a>
        to see a complete example program that shows how to use <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>.
        And check the <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        reference to see a complete list of the available overloads.
      </p>
<h3>
<a name="boost_xpressive.user_s_guide.string_substitutions.h1"></a>
        <span><a name="boost_xpressive.user_s_guide.string_substitutions.replace_options"></a></span><a class="link" href="string_substitutions.html#boost_xpressive.user_s_guide.string_substitutions.replace_options">Replace
        Options</a>
      </h3>
<p>
        The <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        algorithm takes an optional bitmask parameter to control the formatting.
        The possible values of the bitmask are:
      </p>
<div class="table">
<a name="boost_xpressive.user_s_guide.string_substitutions.t0"></a><p class="title"><b>Table&#160;1.7.&#160;Format Flags</b></p>
<div class="table-contents"><table class="table" summary="Format Flags">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Flag
                </p>
              </th>
<th>
                <p>
                  Meaning
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">format_default</span></code>
                </p>
              </td>
<td>
                <p>
                  Recognize the ECMA-262 format sequences (see below).
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">format_first_only</span></code>
                </p>
              </td>
<td>
                <p>
                  Only replace the first match, not all of them.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">format_no_copy</span></code>
                </p>
              </td>
<td>
                <p>
                  Don't copy the parts of the input sequence that didn't match the
                  regex to the output sequence.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">format_literal</span></code>
                </p>
              </td>
<td>
                <p>
                  Treat the format string as a literal; that is, don't recognize
                  any escape sequences.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">format_perl</span></code>
                </p>
              </td>
<td>
                <p>
                  Recognize the Perl format sequences (see below).
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">format_sed</span></code>
                </p>
              </td>
<td>
                <p>
                  Recognize the sed format sequences (see below).
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">format_all</span></code>
                </p>
              </td>
<td>
                <p>
                  In addition to the Perl format sequences, recognize some Boost-specific
                  format sequences.
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
        These flags live in the <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">regex_constants</span></code>
        namespace. If the substitution parameter is a function object instead of
        a string, the flags <code class="computeroutput"><span class="identifier">format_literal</span></code>,
        <code class="computeroutput"><span class="identifier">format_perl</span></code>, <code class="computeroutput"><span class="identifier">format_sed</span></code>, and <code class="computeroutput"><span class="identifier">format_all</span></code>
        are ignored.
      </p>
<h3>
<a name="boost_xpressive.user_s_guide.string_substitutions.h2"></a>
        <span><a name="boost_xpressive.user_s_guide.string_substitutions.the_ecma_262_format_sequences"></a></span><a class="link" href="string_substitutions.html#boost_xpressive.user_s_guide.string_substitutions.the_ecma_262_format_sequences">The
        ECMA-262 Format Sequences</a>
      </h3>
<p>
        When you haven't specified a substitution string dialect with one of the
        format flags above, you get the dialect defined by ECMA-262, the standard
        for ECMAScript. The table below shows the escape sequences recognized in
        ECMA-262 mode.
      </p>
<div class="table">
<a name="boost_xpressive.user_s_guide.string_substitutions.t1"></a><p class="title"><b>Table&#160;1.8.&#160;Format Escape Sequences</b></p>
<div class="table-contents"><table class="table" summary="Format Escape Sequences">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Escape Sequence
                </p>
              </th>
<th>
                <p>
                  Meaning
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="literal">$1</code>, <code class="literal">$2</code>, etc.
                </p>
              </td>
<td>
                <p>
                  the corresponding sub-match
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">$&amp;</code>
                </p>
              </td>
<td>
                <p>
                  the full match
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">$`</code>
                </p>
              </td>
<td>
                <p>
                  the match prefix
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">$'</code>
                </p>
              </td>
<td>
                <p>
                  the match suffix
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">$$</code>
                </p>
              </td>
<td>
                <p>
                  a literal <code class="computeroutput"><span class="char">'$'</span></code> character
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
        Any other sequence beginning with <code class="computeroutput"><span class="char">'$'</span></code>
        simply represents itself. For example, if the format string were <code class="computeroutput"><span class="string">"$a"</span></code> then <code class="computeroutput"><span class="string">"$a"</span></code>
        would be inserted into the output sequence.
      </p>
<h3>
<a name="boost_xpressive.user_s_guide.string_substitutions.h3"></a>
        <span><a name="boost_xpressive.user_s_guide.string_substitutions.the_sed_format_sequences"></a></span><a class="link" href="string_substitutions.html#boost_xpressive.user_s_guide.string_substitutions.the_sed_format_sequences">The
        Sed Format Sequences</a>
      </h3>
<p>
        When specifying the <code class="computeroutput"><span class="identifier">format_sed</span></code>
        flag to <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>,
        the following escape sequences are recognized:
      </p>
<div class="table">
<a name="boost_xpressive.user_s_guide.string_substitutions.t2"></a><p class="title"><b>Table&#160;1.9.&#160;Sed Format Escape Sequences</b></p>
<div class="table-contents"><table class="table" summary="Sed Format Escape Sequences">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Escape Sequence
                </p>
              </th>
<th>
                <p>
                  Meaning
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="literal">\1</code>, <code class="literal">\2</code>, etc.
                </p>
              </td>
<td>
                <p>
                  The corresponding sub-match
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">&amp;</code>
                </p>
              </td>
<td>
                <p>
                  the full match
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\a</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\a'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\e</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">27</span><span class="special">)</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\f</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\f'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\n</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\n'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\r</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\r'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\t</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\t'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\v</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\v'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\xFF</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFF</span><span class="special">)</span></code>, where <code class="literal"><span class="emphasis"><em>F</em></span></code>
                  is any hex digit
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\x{FFFF}</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFFFF</span><span class="special">)</span></code>, where <code class="literal"><span class="emphasis"><em>F</em></span></code>
                  is any hex digit
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\cX</code>
                </p>
              </td>
<td>
                <p>
                  The control character <code class="literal"><span class="emphasis"><em>X</em></span></code>
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><h3>
<a name="boost_xpressive.user_s_guide.string_substitutions.h4"></a>
        <span><a name="boost_xpressive.user_s_guide.string_substitutions.the_perl_format_sequences"></a></span><a class="link" href="string_substitutions.html#boost_xpressive.user_s_guide.string_substitutions.the_perl_format_sequences">The
        Perl Format Sequences</a>
      </h3>
<p>
        When specifying the <code class="computeroutput"><span class="identifier">format_perl</span></code>
        flag to <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>,
        the following escape sequences are recognized:
      </p>
<div class="table">
<a name="boost_xpressive.user_s_guide.string_substitutions.t3"></a><p class="title"><b>Table&#160;1.10.&#160;Perl Format Escape Sequences</b></p>
<div class="table-contents"><table class="table" summary="Perl Format Escape Sequences">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Escape Sequence
                </p>
              </th>
<th>
                <p>
                  Meaning
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="literal">$1</code>, <code class="literal">$2</code>, etc.
                </p>
              </td>
<td>
                <p>
                  the corresponding sub-match
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">$&amp;</code>
                </p>
              </td>
<td>
                <p>
                  the full match
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">$`</code>
                </p>
              </td>
<td>
                <p>
                  the match prefix
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">$'</code>
                </p>
              </td>
<td>
                <p>
                  the match suffix
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">$$</code>
                </p>
              </td>
<td>
                <p>
                  a literal <code class="computeroutput"><span class="char">'$'</span></code> character
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\a</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\a'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\e</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">27</span><span class="special">)</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\f</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\f'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\n</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\n'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\r</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\r'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\t</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\t'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\v</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="char">'\v'</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\xFF</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFF</span><span class="special">)</span></code>, where <code class="literal"><span class="emphasis"><em>F</em></span></code>
                  is any hex digit
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\x{FFFF}</code>
                </p>
              </td>
<td>
                <p>
                  A literal <code class="computeroutput"><span class="identifier">char_type</span><span class="special">(</span><span class="number">0xFFFF</span><span class="special">)</span></code>, where <code class="literal"><span class="emphasis"><em>F</em></span></code>
                  is any hex digit
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\cX</code>
                </p>
              </td>
<td>
                <p>
                  The control character <code class="literal"><span class="emphasis"><em>X</em></span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\l</code>
                </p>
              </td>
<td>
                <p>
                  Make the next character lowercase
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\L</code>
                </p>
              </td>
<td>
                <p>
                  Make the rest of the substitution lowercase until the next <code class="literal">\E</code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\u</code>
                </p>
              </td>
<td>
                <p>
                  Make the next character uppercase
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\U</code>
                </p>
              </td>
<td>
                <p>
                  Make the rest of the substitution uppercase until the next <code class="literal">\E</code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\E</code>
                </p>
              </td>
<td>
                <p>
                  Terminate <code class="literal">\L</code> or <code class="literal">\U</code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\1</code>, <code class="literal">\2</code>, etc.
                </p>
              </td>
<td>
                <p>
                  The corresponding sub-match
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="literal">\g&lt;name&gt;</code>
                </p>
              </td>
<td>
                <p>
                  The named backref <span class="emphasis"><em>name</em></span>
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><h3>
<a name="boost_xpressive.user_s_guide.string_substitutions.h5"></a>
        <span><a name="boost_xpressive.user_s_guide.string_substitutions.the_boost_specific_format_sequences"></a></span><a class="link" href="string_substitutions.html#boost_xpressive.user_s_guide.string_substitutions.the_boost_specific_format_sequences">The
        Boost-Specific Format Sequences</a>
      </h3>
<p>
        When specifying the <code class="computeroutput"><span class="identifier">format_all</span></code>
        flag to <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>,
        the escape sequences recognized are the same as those above for <code class="computeroutput"><span class="identifier">format_perl</span></code>. In addition, conditional expressions
        of the following form are recognized:
      </p>
<pre class="programlisting">?Ntrue-expression:false-expression
</pre>
<p>
        where <span class="emphasis"><em>N</em></span> is a decimal digit representing a sub-match.
        If the corresponding sub-match participated in the full match, then the substitution
        is <span class="emphasis"><em>true-expression</em></span>. Otherwise, it is <span class="emphasis"><em>false-expression</em></span>.
        In this mode, you can use parens <code class="literal">()</code> for grouping. If you
        want a literal paren, you must escape it as <code class="literal">\(</code>.
      </p>
<h3>
<a name="boost_xpressive.user_s_guide.string_substitutions.h6"></a>
        <span><a name="boost_xpressive.user_s_guide.string_substitutions.formatter_objects"></a></span><a class="link" href="string_substitutions.html#boost_xpressive.user_s_guide.string_substitutions.formatter_objects">Formatter
        Objects</a>
      </h3>
<p>
        Format strings are not always expressive enough for all your text substitution
        needs. Consider the simple example of wanting to map input strings to output
        strings, as you may want to do with environment variables. Rather than a
        format <span class="emphasis"><em>string</em></span>, for this you would use a formatter <span class="emphasis"><em>object</em></span>.
        Consider the following code, which finds embedded environment variables of
        the form <code class="computeroutput"><span class="string">"$(XYZ)"</span></code> and
        computes the substitution string by looking up the environment variable in
        a map.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">map</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">xpressive</span><span class="special">;</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">env</span><span class="special">;</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">format_fun</span><span class="special">(</span><span class="identifier">smatch</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">what</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">env</span><span class="special">[</span><span class="identifier">what</span><span class="special">[</span><span class="number">1</span><span class="special">].</span><span class="identifier">str</span><span class="special">()];</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">env</span><span class="special">[</span><span class="string">"X"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"this"</span><span class="special">;</span>
    <span class="identifier">env</span><span class="special">[</span><span class="string">"Y"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"that"</span><span class="special">;</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"\"$(X)\" has the value \"$(Y)\""</span><span class="special">);</span>

    <span class="comment">// replace strings like "$(XYZ)" with the result of env["XYZ"]</span>
    <span class="identifier">sregex</span> <span class="identifier">envar</span> <span class="special">=</span> <span class="string">"$("</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s1</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">output</span> <span class="special">=</span> <span class="identifier">regex_replace</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">envar</span><span class="special">,</span> <span class="identifier">format_fun</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">output</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        In this case, we use a function, <code class="computeroutput"><span class="identifier">format_fun</span><span class="special">()</span></code> to compute the substitution string on the
        fly. It accepts a <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object which contains the results of the current match. <code class="computeroutput"><span class="identifier">format_fun</span><span class="special">()</span></code> uses the first submatch as a key into the
        global <code class="computeroutput"><span class="identifier">env</span></code> map. The above
        code displays:
      </p>
<pre class="programlisting">"this" has the value "that"
</pre>
<p>
        The formatter need not be an ordinary function. It may be an object of class
        type. And rather than return a string, it may accept an output iterator into
        which it writes the substitution. Consider the following, which is functionally
        equivalent to the above.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">map</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">xpressive</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">formatter</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">env_map</span><span class="special">;</span>
    <span class="identifier">env_map</span> <span class="identifier">env</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Out</span><span class="special">&gt;</span>
    <span class="identifier">Out</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">smatch</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">what</span><span class="special">,</span> <span class="identifier">Out</span> <span class="identifier">out</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">env_map</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">where</span> <span class="special">=</span> <span class="identifier">env</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">1</span><span class="special">]);</span>
        <span class="keyword">if</span><span class="special">(</span><span class="identifier">where</span> <span class="special">!=</span> <span class="identifier">env</span><span class="special">.</span><span class="identifier">end</span><span class="special">())</span>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">sub</span> <span class="special">=</span> <span class="identifier">where</span><span class="special">-&gt;</span><span class="identifier">second</span><span class="special">;</span>
            <span class="identifier">out</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">sub</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">out</span><span class="special">);</span>
        <span class="special">}</span>
        <span class="keyword">return</span> <span class="identifier">out</span><span class="special">;</span>
    <span class="special">}</span>

<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">formatter</span> <span class="identifier">fmt</span><span class="special">;</span>
    <span class="identifier">fmt</span><span class="special">.</span><span class="identifier">env</span><span class="special">[</span><span class="string">"X"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"this"</span><span class="special">;</span>
    <span class="identifier">fmt</span><span class="special">.</span><span class="identifier">env</span><span class="special">[</span><span class="string">"Y"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"that"</span><span class="special">;</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"\"$(X)\" has the value \"$(Y)\""</span><span class="special">);</span>

    <span class="identifier">sregex</span> <span class="identifier">envar</span> <span class="special">=</span> <span class="string">"$("</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s1</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">output</span> <span class="special">=</span> <span class="identifier">regex_replace</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">envar</span><span class="special">,</span> <span class="identifier">fmt</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">output</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        The formatter must be a callable object -- a function or a function object
        -- that has one of three possible signatures, detailed in the table below.
        For the table, <code class="computeroutput"><span class="identifier">fmt</span></code> is a function
        pointer or function object, <code class="computeroutput"><span class="identifier">what</span></code>
        is a <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object, <code class="computeroutput"><span class="identifier">out</span></code> is an OutputIterator,
        and <code class="computeroutput"><span class="identifier">flags</span></code> is a value of
        <code class="computeroutput"><span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">match_flag_type</span></code>:
      </p>
<div class="table">
<a name="boost_xpressive.user_s_guide.string_substitutions.t4"></a><p class="title"><b>Table&#160;1.11.&#160;Formatter Signatures</b></p>
<div class="table-contents"><table class="table" summary="Formatter Signatures">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Formatter Invocation
                </p>
              </th>
<th>
                <p>
                  Return Type
                </p>
              </th>
<th>
                <p>
                  Semantics
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">fmt</span><span class="special">(</span><span class="identifier">what</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Range of characters (e.g. <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>)
                  or null-terminated string
                </p>
              </td>
<td>
                <p>
                  The string matched by the regex is replaced with the string returned
                  by the formatter.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">fmt</span><span class="special">(</span><span class="identifier">what</span><span class="special">,</span>
                  <span class="identifier">out</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  OutputIterator
                </p>
              </td>
<td>
                <p>
                  The formatter writes the replacement string into <code class="computeroutput"><span class="identifier">out</span></code> and returns <code class="computeroutput"><span class="identifier">out</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">fmt</span><span class="special">(</span><span class="identifier">what</span><span class="special">,</span>
                  <span class="identifier">out</span><span class="special">,</span>
                  <span class="identifier">flags</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  OutputIterator
                </p>
              </td>
<td>
                <p>
                  The formatter writes the replacement string into <code class="computeroutput"><span class="identifier">out</span></code> and returns <code class="computeroutput"><span class="identifier">out</span></code>. The <code class="computeroutput"><span class="identifier">flags</span></code>
                  parameter is the value of the match flags passed to the <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
                  algorithm.
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><h3>
<a name="boost_xpressive.user_s_guide.string_substitutions.h7"></a>
        <span><a name="boost_xpressive.user_s_guide.string_substitutions.formatter_expressions"></a></span><a class="link" href="string_substitutions.html#boost_xpressive.user_s_guide.string_substitutions.formatter_expressions">Formatter
        Expressions</a>
      </h3>
<p>
        In addition to format <span class="emphasis"><em>strings</em></span> and formatter <span class="emphasis"><em>objects</em></span>,
        <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        also accepts formatter <span class="emphasis"><em>expressions</em></span>. A formatter expression
        is a lambda expression that generates a string. It uses the same syntax as
        that for <a class="link" href="semantic_actions_and_user_defined_assertions.html" title="Semantic Actions and User-Defined Assertions">Semantic
        Actions</a>, which are covered later. The above example, which uses <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        to substitute strings for environment variables, is repeated here using a
        formatter expression.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">map</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">regex_actions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">env</span><span class="special">;</span>
    <span class="identifier">env</span><span class="special">[</span><span class="string">"X"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"this"</span><span class="special">;</span>
    <span class="identifier">env</span><span class="special">[</span><span class="string">"Y"</span><span class="special">]</span> <span class="special">=</span> <span class="string">"that"</span><span class="special">;</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"\"$(X)\" has the value \"$(Y)\""</span><span class="special">);</span>

    <span class="identifier">sregex</span> <span class="identifier">envar</span> <span class="special">=</span> <span class="string">"$("</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s1</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">output</span> <span class="special">=</span> <span class="identifier">regex_replace</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">envar</span><span class="special">,</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">env</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">output</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        In the above, the formatter expression is <code class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">env</span><span class="special">)[</span><span class="identifier">s1</span><span class="special">]</span></code>. This
        means to use the value of the first submatch, <code class="computeroutput"><span class="identifier">s1</span></code>,
        as a key into the <code class="computeroutput"><span class="identifier">env</span></code> map.
        The purpose of <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code>
        here is to make the reference to the <code class="computeroutput"><span class="identifier">env</span></code>
        local variable <span class="emphasis"><em>lazy</em></span> so that the index operation is deferred
        until we know what to replace <code class="computeroutput"><span class="identifier">s1</span></code>
        with.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2007 Eric Niebler<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="accessing_results.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../xpressive/user_s_guide.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="string_splitting_and_tokenization.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
