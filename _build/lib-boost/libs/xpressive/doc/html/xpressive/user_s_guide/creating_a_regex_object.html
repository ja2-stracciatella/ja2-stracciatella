<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Creating a Regex Object</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Boost.Xpressive">
<link rel="up" href="../user_s_guide.html" title="User's Guide">
<link rel="prev" href="../../boost_xpressive/user_s_guide/quick_start.html" title="Quick Start">
<link rel="next" href="../../boost_xpressive/user_s_guide/creating_a_regex_object/dynamic_regexes.html" title="Dynamic Regexes">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../../boost_xpressive/user_s_guide/quick_start.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../user_s_guide.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../../boost_xpressive/user_s_guide/creating_a_regex_object/dynamic_regexes.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="xpressive.user_s_guide.creating_a_regex_object"></a><a class="link" href="creating_a_regex_object.html" title="Creating a Regex Object">Creating
      a Regex Object</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="creating_a_regex_object.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes">Static
        Regexes</a></span></dt>
<dt><span class="section"><a href="../../boost_xpressive/user_s_guide/creating_a_regex_object/dynamic_regexes.html">Dynamic
        Regexes</a></span></dt>
</dl></div>
<p>
        When using xpressive, the first thing you'll do is create a <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
        object. This section goes over the nuts and bolts of building a regular expression
        in the two dialects xpressive supports: static and dynamic.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes"></a><a class="link" href="creating_a_regex_object.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes" title="Static Regexes">Static
        Regexes</a>
</h4></div></div></div>
<h3>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.h0"></a>
          <span><a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.overview"></a></span><a class="link" href="creating_a_regex_object.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.overview">Overview</a>
        </h3>
<p>
          The feature that really sets xpressive apart from other C/C++ regular expression
          libraries is the ability to author a regular expression using C++ expressions.
          xpressive achieves this through operator overloading, using a technique
          called <span class="emphasis"><em>expression templates</em></span> to embed a mini-language
          dedicated to pattern matching within C++. These "static regexes"
          have many advantages over their string-based brethren. In particular, static
          regexes:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              are syntax-checked at compile-time; they will never fail at run-time
              due to a syntax error.
            </li>
<li class="listitem">
              can naturally refer to other C++ data and code, including other regexes,
              making it simple to build grammars out of regular expressions and bind
              user-defined actions that execute when parts of your regex match.
            </li>
<li class="listitem">
              are statically bound for better inlining and optimization. Static regexes
              require no state tables, virtual functions, byte-code or calls through
              function pointers that cannot be resolved at compile time.
            </li>
<li class="listitem">
              are not limited to searching for patterns in strings. You can declare
              a static regex that finds patterns in an array of integers, for instance.
            </li>
</ul></div>
<p>
          Since we compose static regexes using C++ expressions, we are constrained
          by the rules for legal C++ expressions. Unfortunately, that means that
          "classic" regular expression syntax cannot always be mapped cleanly
          into C++. Rather, we map the regex <span class="emphasis"><em>constructs</em></span>, picking
          new syntax that is legal C++.
        </p>
<h3>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.h1"></a>
          <span><a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.construction_and_assignment"></a></span><a class="link" href="creating_a_regex_object.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.construction_and_assignment">Construction
          and Assignment</a>
        </h3>
<p>
          You create a static regex by assigning one to an object of type <code class="literal"><code class="computeroutput"><a class="link" href="../../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>.
          For instance, the following defines a regex that can be used to find patterns
          in objects of type <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>:
        </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="char">'$'</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="char">'.'</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span><span class="special">;</span>
</pre>
<p>
          Assignment works similarly.
        </p>
<h3>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.h2"></a>
          <span><a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.character_and_string_literals"></a></span><a class="link" href="creating_a_regex_object.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.character_and_string_literals">Character
          and String Literals</a>
        </h3>
<p>
          In static regexes, character and string literals match themselves. For
          instance, in the regex above, <code class="computeroutput"><span class="char">'$'</span></code>
          and <code class="computeroutput"><span class="char">'.'</span></code> match the characters
          <code class="computeroutput"><span class="char">'$'</span></code> and <code class="computeroutput"><span class="char">'.'</span></code>
          respectively. Don't be confused by the fact that <code class="literal">$</code> and
          <code class="literal">.</code> are meta-characters in Perl. In xpressive, literals
          always represent themselves.
        </p>
<p>
          When using literals in static regexes, you must take care that at least
          one operand is not a literal. For instance, the following are <span class="emphasis"><em>not</em></span>
          valid regexes:
        </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">re1</span> <span class="special">=</span> <span class="char">'a'</span> <span class="special">&gt;&gt;</span> <span class="char">'b'</span><span class="special">;</span>         <span class="comment">// ERROR!</span>
<span class="identifier">sregex</span> <span class="identifier">re2</span> <span class="special">=</span> <span class="special">+</span><span class="char">'a'</span><span class="special">;</span>               <span class="comment">// ERROR!</span>
</pre>
<p>
          The two operands to the binary <code class="computeroutput"><span class="special">&gt;&gt;</span></code>
          operator are both literals, and the operand of the unary <code class="computeroutput"><span class="special">+</span></code> operator is also a literal, so these statements
          will call the native C++ binary right-shift and unary plus operators, respectively.
          That's not what we want. To get operator overloading to kick in, at least
          one operand must be a user-defined type. We can use xpressive's <code class="computeroutput"><span class="identifier">as_xpr</span><span class="special">()</span></code>
          helper function to "taint" an expression with regex-ness, forcing
          operator overloading to find the correct operators. The two regexes above
          should be written as:
        </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">re1</span> <span class="special">=</span> <span class="identifier">as_xpr</span><span class="special">(</span><span class="char">'a'</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'b'</span><span class="special">;</span> <span class="comment">// OK</span>
<span class="identifier">sregex</span> <span class="identifier">re2</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">as_xpr</span><span class="special">(</span><span class="char">'a'</span><span class="special">);</span>       <span class="comment">// OK</span>
</pre>
<h3>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.h3"></a>
          <span><a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.sequencing_and_alternation"></a></span><a class="link" href="creating_a_regex_object.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.sequencing_and_alternation">Sequencing
          and Alternation</a>
        </h3>
<p>
          As you've probably already noticed, sub-expressions in static regexes must
          be separated by the sequencing operator, <code class="computeroutput"><span class="special">&gt;&gt;</span></code>.
          You can read this operator as "followed by".
        </p>
<pre class="programlisting"><span class="comment">// Match an 'a' followed by a digit</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="char">'a'</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span><span class="special">;</span>
</pre>
<p>
          Alternation works just as it does in Perl with the <code class="computeroutput"><span class="special">|</span></code>
          operator. You can read this operator as "or". For example:
        </p>
<pre class="programlisting"><span class="comment">// match a digit character or a word character one or more times</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">|</span> <span class="identifier">_w</span> <span class="special">);</span>
</pre>
<h3>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.h4"></a>
          <span><a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.grouping_and_captures"></a></span><a class="link" href="creating_a_regex_object.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.grouping_and_captures">Grouping
          and Captures</a>
        </h3>
<p>
          In Perl, parentheses <code class="computeroutput"><span class="special">()</span></code> have
          special meaning. They group, but as a side-effect they also create back-references
          like <code class="literal">$1</code> and <code class="literal">$2</code>. In C++, parentheses
          only group -- there is no way to give them side-effects. To get the same
          effect, we use the special <code class="computeroutput"><span class="identifier">s1</span></code>,
          <code class="computeroutput"><span class="identifier">s2</span></code>, etc. tokens. Assigning
          to one creates a back-reference. You can then use the back-reference later
          in your expression, like using <code class="literal">\1</code> and <code class="literal">\2</code>
          in Perl. For example, consider the following regex, which finds matching
          HTML tags:
        </p>
<pre class="programlisting"><span class="string">"&lt;(\\w+)&gt;.*?&lt;/\\1&gt;"</span>
</pre>
<p>
          In static xpressive, this would be:
        </p>
<pre class="programlisting"><span class="char">'&lt;'</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'&gt;'</span> <span class="special">&gt;&gt;</span> <span class="special">-*</span><span class="identifier">_</span> <span class="special">&gt;&gt;</span> <span class="string">"&lt;/"</span> <span class="special">&gt;&gt;</span> <span class="identifier">s1</span> <span class="special">&gt;&gt;</span> <span class="char">'&gt;'</span>
</pre>
<p>
          Notice how you capture a back-reference by assigning to <code class="computeroutput"><span class="identifier">s1</span></code>,
          and then you use <code class="computeroutput"><span class="identifier">s1</span></code> later
          in the pattern to find the matching end tag.
        </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
            <span class="bold"><strong>Grouping without capturing a back-reference</strong></span>
            <br> <br> In xpressive, if you just want grouping without capturing
            a back-reference, you can just use <code class="computeroutput"><span class="special">()</span></code>
            without <code class="computeroutput"><span class="identifier">s1</span></code>. That is the
            equivalent of Perl's <code class="literal">(?:)</code> non-capturing grouping construct.
          </p></td></tr>
</table></div>
<h3>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.h5"></a>
          <span><a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.case_insensitivity_and_internationalization"></a></span><a class="link" href="creating_a_regex_object.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.case_insensitivity_and_internationalization">Case-Insensitivity
          and Internationalization</a>
        </h3>
<p>
          Perl lets you make part of your regular expression case-insensitive by
          using the <code class="literal">(?i:)</code> pattern modifier. xpressive also has
          a case-insensitivity pattern modifier, called <code class="computeroutput"><span class="identifier">icase</span></code>.
          You can use it as follows:
        </p>
<pre class="programlisting"><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="string">"this"</span> <span class="special">&gt;&gt;</span> <span class="identifier">icase</span><span class="special">(</span> <span class="string">"that"</span> <span class="special">);</span>
</pre>
<p>
          In this regular expression, <code class="computeroutput"><span class="string">"this"</span></code>
          will be matched exactly, but <code class="computeroutput"><span class="string">"that"</span></code>
          will be matched irrespective of case.
        </p>
<p>
          Case-insensitive regular expressions raise the issue of internationalization:
          how should case-insensitive character comparisons be evaluated? Also, many
          character classes are locale-specific. Which characters are matched by
          <code class="computeroutput"><span class="identifier">digit</span></code> and which are matched
          by <code class="computeroutput"><span class="identifier">alpha</span></code>? The answer depends
          on the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code> object the regular expression
          object is using. By default, all regular expression objects use the global
          locale. You can override the default by using the <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code> pattern modifier, as follows:
        </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span> <span class="identifier">my_locale</span> <span class="special">=</span> <span class="comment">/* initialize a std::locale object */</span><span class="special">;</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">imbue</span><span class="special">(</span> <span class="identifier">my_locale</span> <span class="special">)(</span> <span class="special">+</span><span class="identifier">alpha</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">digit</span> <span class="special">);</span>
</pre>
<p>
          This regular expression will evaluate <code class="computeroutput"><span class="identifier">alpha</span></code>
          and <code class="computeroutput"><span class="identifier">digit</span></code> according to
          <code class="computeroutput"><span class="identifier">my_locale</span></code>. See the section
          on <a class="link" href="../../boost_xpressive/user_s_guide/localization_and_regex_traits.html" title="Localization and Regex Traits">Localization
          and Regex Traits</a> for more information about how to customize the
          behavior of your regexes.
        </p>
<h3>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.h6"></a>
          <span><a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.static_xpressive_syntax_cheat_sheet"></a></span><a class="link" href="creating_a_regex_object.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.static_xpressive_syntax_cheat_sheet">Static
          xpressive Syntax Cheat Sheet</a>
        </h3>
<p>
          The table below lists the familiar regex constructs and their equivalents
          in static xpressive.
        </p>
<div class="table">
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.t0"></a><p class="title"><b>Table&#160;1.4.&#160;Perl syntax vs. Static xpressive syntax</b></p>
<div class="table-contents"><table class="table" summary="Perl syntax vs. Static xpressive syntax">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Perl
                  </p>
                </th>
<th>
                  <p>
                    Static xpressive
                  </p>
                </th>
<th>
                  <p>
                    Meaning
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    <code class="literal">.</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/_.html" title="Global _">_</a></code>
                  </p>
                </td>
<td>
                  <p>
                    any character (assuming Perl's /s modifier).
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">ab</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">a</span> <span class="special">&gt;&gt;</span>
                    <span class="identifier">b</span></code>
                  </p>
                </td>
<td>
                  <p>
                    sequencing of <code class="literal">a</code> and <code class="literal">b</code> sub-expressions.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">a|b</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">a</span> <span class="special">|</span>
                    <span class="identifier">b</span></code>
                  </p>
                </td>
<td>
                  <p>
                    alternation of <code class="literal">a</code> and <code class="literal">b</code>
                    sub-expressions.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">(a)</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">(</span><a class="link" href="../../boost/xpressive/s1.html" title="Global s1">s1</a><span class="special">=</span> <span class="identifier">a</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    group and capture a back-reference.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">(?:a)</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">(</span><span class="identifier">a</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    group and do not capture a back-reference.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">\1</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/s1.html" title="Global s1">s1</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a previously captured back-reference.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">a*</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">*</span><span class="identifier">a</span></code>
                  </p>
                </td>
<td>
                  <p>
                    zero or more times, greedy.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">a+</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">+</span><span class="identifier">a</span></code>
                  </p>
                </td>
<td>
                  <p>
                    one or more times, greedy.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">a?</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">!</span><span class="identifier">a</span></code>
                  </p>
                </td>
<td>
                  <p>
                    zero or one time, greedy.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">a{n,m}</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/repeat_idp13572976.html" title="Function template repeat">repeat</a><span class="special">&lt;</span><span class="identifier">n</span><span class="special">,</span><span class="identifier">m</span><span class="special">&gt;(</span><span class="identifier">a</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    between <code class="literal">n</code> and <code class="literal">m</code> times,
                    greedy.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">a*?</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">-*</span><span class="identifier">a</span></code>
                  </p>
                </td>
<td>
                  <p>
                    zero or more times, non-greedy.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">a+?</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">-+</span><span class="identifier">a</span></code>
                  </p>
                </td>
<td>
                  <p>
                    one or more times, non-greedy.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">a??</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">-!</span><span class="identifier">a</span></code>
                  </p>
                </td>
<td>
                  <p>
                    zero or one time, non-greedy.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">a{n,m}?</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">-</span><a class="link" href="../../boost/xpressive/repeat_idp13572976.html" title="Function template repeat">repeat</a><span class="special">&lt;</span><span class="identifier">n</span><span class="special">,</span><span class="identifier">m</span><span class="special">&gt;(</span><span class="identifier">a</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    between <code class="literal">n</code> and <code class="literal">m</code> times,
                    non-greedy.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">^</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/bos.html" title="Global bos">bos</a></code>
                  </p>
                </td>
<td>
                  <p>
                    beginning of sequence assertion.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">$</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/eos.html" title="Global eos">eos</a></code>
                  </p>
                </td>
<td>
                  <p>
                    end of sequence assertion.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">\b</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/_b.html" title="Global _b">_b</a></code>
                  </p>
                </td>
<td>
                  <p>
                    word boundary assertion.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">\B</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">~</span><a class="link" href="../../boost/xpressive/_b.html" title="Global _b">_b</a></code>
                  </p>
                </td>
<td>
                  <p>
                    not word boundary assertion.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">\n</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/_n.html" title="Global _n">_n</a></code>
                  </p>
                </td>
<td>
                  <p>
                    literal newline.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">.</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">~</span><a class="link" href="../../boost/xpressive/_n.html" title="Global _n">_n</a></code>
                  </p>
                </td>
<td>
                  <p>
                    any character except a literal newline (without Perl's /s modifier).
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">\r?\n|\r</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/_ln.html" title="Global _ln">_ln</a></code>
                  </p>
                </td>
<td>
                  <p>
                    logical newline.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[^\r\n]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">~</span><a class="link" href="../../boost/xpressive/_ln.html" title="Global _ln">_ln</a></code>
                  </p>
                </td>
<td>
                  <p>
                    any single character not a logical newline.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">\w</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/_w.html" title="Global _w">_w</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a word character, equivalent to set[alnum | '_'].
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">\W</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">~</span><a class="link" href="../../boost/xpressive/_w.html" title="Global _w">_w</a></code>
                  </p>
                </td>
<td>
                  <p>
                    not a word character, equivalent to ~set[alnum | '_'].
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">\d</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/_d.html" title="Global _d">_d</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a digit character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">\D</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">~</span><a class="link" href="../../boost/xpressive/_d.html" title="Global _d">_d</a></code>
                  </p>
                </td>
<td>
                  <p>
                    not a digit character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">\s</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/_s.html" title="Global _s">_s</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a space character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">\S</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">~</span><a class="link" href="../../boost/xpressive/_s.html" title="Global _s">_s</a></code>
                  </p>
                </td>
<td>
                  <p>
                    not a space character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:alnum:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/alnum.html" title="Global alnum">alnum</a></code>
                  </p>
                </td>
<td>
                  <p>
                    an alpha-numeric character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:alpha:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/alpha.html" title="Global alpha">alpha</a></code>
                  </p>
                </td>
<td>
                  <p>
                    an alphabetic character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:blank:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/blank.html" title="Global blank">blank</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a horizontal white-space character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:cntrl:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/cntrl.html" title="Global cntrl">cntrl</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a control character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:digit:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/digit.html" title="Global digit">digit</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a digit character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:graph:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/graph.html" title="Global graph">graph</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a graphable character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:lower:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/lower.html" title="Global lower">lower</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a lower-case character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:print:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/print.html" title="Global print">print</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a printing character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:punct:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/punct.html" title="Global punct">punct</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a punctuation character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:space:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/space.html" title="Global space">space</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a white-space character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:upper:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/upper.html" title="Global upper">upper</a></code>
                  </p>
                </td>
<td>
                  <p>
                    an upper-case character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[:xdigit:]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/xdigit.html" title="Global xdigit">xdigit</a></code>
                  </p>
                </td>
<td>
                  <p>
                    a hexadecimal digit character.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[0-9]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/range.html" title="Function template range">range</a><span class="special">(</span><span class="char">'0'</span><span class="special">,</span><span class="char">'9'</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    characters in range <code class="computeroutput"><span class="char">'0'</span></code>
                    through <code class="computeroutput"><span class="char">'9'</span></code>.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[abc]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">as_xpr</span><span class="special">(</span><span class="char">'a'</span><span class="special">)</span> <span class="special">|</span> <span class="char">'b'</span> <span class="special">|</span><span class="char">'c'</span></code>
                  </p>
                </td>
<td>
                  <p>
                    characters <code class="computeroutput"><span class="char">'a'</span></code>, <code class="computeroutput"><span class="char">'b'</span></code>, or <code class="computeroutput"><span class="char">'c'</span></code>.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[abc]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">(</span><a class="link" href="../../boost/xpressive/set.html" title="Global set">set</a><span class="special">=</span> <span class="char">'a'</span><span class="special">,</span><span class="char">'b'</span><span class="special">,</span><span class="char">'c'</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <span class="emphasis"><em>same as above</em></span>
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[0-9abc]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/set.html" title="Global set">set</a><span class="special">[</span> <a class="link" href="../../boost/xpressive/range.html" title="Function template range">range</a><span class="special">(</span><span class="char">'0'</span><span class="special">,</span><span class="char">'9'</span><span class="special">)</span> <span class="special">|</span>
                    <span class="char">'a'</span> <span class="special">|</span>
                    <span class="char">'b'</span> <span class="special">|</span>
                    <span class="char">'c'</span> <span class="special">]</span></code>
                  </p>
                </td>
<td>
                  <p>
                    characters <code class="computeroutput"><span class="char">'a'</span></code>, <code class="computeroutput"><span class="char">'b'</span></code>, <code class="computeroutput"><span class="char">'c'</span></code>
                    or in range <code class="computeroutput"><span class="char">'0'</span></code> through
                    <code class="computeroutput"><span class="char">'9'</span></code>.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[0-9abc]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/set.html" title="Global set">set</a><span class="special">[</span> <a class="link" href="../../boost/xpressive/range.html" title="Function template range">range</a><span class="special">(</span><span class="char">'0'</span><span class="special">,</span><span class="char">'9'</span><span class="special">)</span> <span class="special">|</span>
                    <span class="special">(</span><a class="link" href="../../boost/xpressive/set.html" title="Global set">set</a><span class="special">=</span> <span class="char">'a'</span><span class="special">,</span><span class="char">'b'</span><span class="special">,</span><span class="char">'c'</span><span class="special">)</span> <span class="special">]</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <span class="emphasis"><em>same as above</em></span>
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">[^abc]</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">~(</span><a class="link" href="../../boost/xpressive/set.html" title="Global set">set</a><span class="special">=</span> <span class="char">'a'</span><span class="special">,</span><span class="char">'b'</span><span class="special">,</span><span class="char">'c'</span><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    not characters <code class="computeroutput"><span class="char">'a'</span></code>,
                    <code class="computeroutput"><span class="char">'b'</span></code>, or <code class="computeroutput"><span class="char">'c'</span></code>.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">(?i:<span class="emphasis"><em>stuff</em></span>)</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/icase.html" title="Function template icase">icase</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    match <span class="emphasis"><em>stuff</em></span> disregarding case.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">(?&gt;<span class="emphasis"><em>stuff</em></span>)</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/keep.html" title="Function template keep">keep</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    independent sub-expression, match <span class="emphasis"><em>stuff</em></span>
                    and turn off backtracking.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">(?=<span class="emphasis"><em>stuff</em></span>)</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/before.html" title="Function template before">before</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    positive look-ahead assertion, match if before <span class="emphasis"><em>stuff</em></span>
                    but don't include <span class="emphasis"><em>stuff</em></span> in the match.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">(?!<span class="emphasis"><em>stuff</em></span>)</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">~</span><a class="link" href="../../boost/xpressive/before.html" title="Function template before">before</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    negative look-ahead assertion, match if not before <span class="emphasis"><em>stuff</em></span>.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">(?&lt;=<span class="emphasis"><em>stuff</em></span>)</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><a class="link" href="../../boost/xpressive/after.html" title="Function template after">after</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    positive look-behind assertion, match if after <span class="emphasis"><em>stuff</em></span>
                    but don't include <span class="emphasis"><em>stuff</em></span> in the match. (<span class="emphasis"><em>stuff</em></span>
                    must be constant-width.)
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">(?&lt;!<span class="emphasis"><em>stuff</em></span>)</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="special">~</span><a class="link" href="../../boost/xpressive/after.html" title="Function template after">after</a><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    negative look-behind assertion, match if not after <span class="emphasis"><em>stuff</em></span>.
                    (<span class="emphasis"><em>stuff</em></span> must be constant-width.)
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">(?P&lt;<span class="emphasis"><em>name</em></span>&gt;<span class="emphasis"><em>stuff</em></span>)</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><code class="literal"><a class="link" href="../../boost/xpressive/mark_tag.html" title="Struct mark_tag">mark_tag</a></code>
                    </code><code class="literal"><span class="emphasis"><em>name</em></span></code><code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>n</em></span><code class="computeroutput"><span class="special">);</span></code><br> ...<br> <code class="computeroutput"><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>name</em></span></code><code class="computeroutput"><span class="special">=</span> </code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    Create a named capture.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    <code class="literal">(?P=<span class="emphasis"><em>name</em></span>)</code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><code class="literal"><a class="link" href="../../boost/xpressive/mark_tag.html" title="Struct mark_tag">mark_tag</a></code>
                    </code><code class="literal"><span class="emphasis"><em>name</em></span></code><code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>n</em></span><code class="computeroutput"><span class="special">);</span></code><br> ...<br> <code class="literal"><span class="emphasis"><em>name</em></span></code>
                  </p>
                </td>
<td>
                  <p>
                    Refer back to a previously created named capture.
                  </p>
                </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
          <br>
        </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2007 Eric Niebler<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../../boost_xpressive/user_s_guide/quick_start.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../user_s_guide.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../../boost_xpressive/user_s_guide/creating_a_regex_object/dynamic_regexes.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
