<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Tutorial</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Thread 4.7.0">
<link rel="up" href="../synchronization.html" title="Synchronization">
<link rel="prev" href="../synchronization.html" title="Synchronization">
<link rel="next" href="mutex_concepts.html" title="Mutex Concepts">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../synchronization.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../synchronization.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="mutex_concepts.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.tutorial"></a><a class="link" href="tutorial.html" title="Tutorial">Tutorial</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.internal_locking">Internal
        Locking</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.internal_locking.concurrent_threads_of_execution">Concurrent
          threads of execution</a></span></dt>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.internal_locking.internal_locking">Internal
          locking</a></span></dt>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.internal_locking.internal_and_external_locking">Internal
          and external locking</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes">External
        Locking -- <code class="computeroutput"><span class="identifier">strict_lock</span></code> and
        <code class="computeroutput"><span class="identifier">externally_locked</span></code> classes</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.locks_as_permits">Locks
          as permits</a></span></dt>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.improving_external_locking">Improving
          External Locking</a></span></dt>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.allowing_other_strict_locks">Allowing
          other strict locks</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.with">Executing Around
        a Function</a></span></dt>
</dl></div>
<p>
        <a href="http://web.archive.org/web/20140531071228/http://home.roadrunner.com/~hinnant/mutexes/locking.html" target="_top">Handling
        mutexes in C++</a> is an excellent tutorial. You need just replace std
        and ting by boost.
      </p>
<p>
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html" target="_top">Mutex,
        Lock, Condition Variable Rationale</a> adds rationale for the design
        decisions made for mutexes, locks and condition variables.
      </p>
<p>
        In addition to the C++11 standard locks, Boost.Thread provides other locks
        and some utilities that help the user to make their code thread-safe.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.tutorial.internal_locking"></a><a class="link" href="tutorial.html#thread.synchronization.tutorial.internal_locking" title="Internal Locking">Internal
        Locking</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.internal_locking.concurrent_threads_of_execution">Concurrent
          threads of execution</a></span></dt>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.internal_locking.internal_locking">Internal
          locking</a></span></dt>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.internal_locking.internal_and_external_locking">Internal
          and external locking</a></span></dt>
</dl></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            This tutorial is an adaptation of chapter Concurrency of the Object-Oriented
            Programming in the BETA Programming Language and of the paper of Andrei
            Alexandrescu "Multithreading and the C++ Type System" to the
            Boost library.
          </p></td></tr>
</table></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.internal_locking.concurrent_threads_of_execution"></a><a class="link" href="tutorial.html#thread.synchronization.tutorial.internal_locking.concurrent_threads_of_execution" title="Concurrent threads of execution">Concurrent
          threads of execution</a>
</h5></div></div></div>
<p>
            Consider, for example, modeling a bank account class that supports simultaneous
            deposits and withdrawals from multiple locations (arguably the "Hello,
            World" of multithreaded programming).
          </p>
<p>
            From here a component is a model of the <code class="computeroutput"><span class="identifier">Callable</span></code>
            concept.
          </p>
<p>
            I C++11 (Boost) concurrent execution of a component is obtained by means
            of the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">thread</span></code>(<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code>):
          </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread1</span><span class="special">(</span><span class="identifier">S</span><span class="special">);</span>
</pre>
<p>
            where <code class="computeroutput"><span class="identifier">S</span></code> is a model of
            <code class="computeroutput"><span class="identifier">Callable</span></code>. The meaning
            of this expression is that execution of <code class="computeroutput"><span class="identifier">S</span><span class="special">()</span></code> will take place concurrently with the
            current thread of execution executing the expression.
          </p>
<p>
            The following example includes a bank account of a person (Joe) and two
            components, one corresponding to a bank agent depositing money in Joe's
            account, and one representing Joe. Joe will only be withdrawing money
            from the account:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span><span class="special">;</span>

<span class="identifier">BankAccount</span> <span class="identifier">JoesAccount</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">bankAgent</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span><span class="number">10</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&gt;</span><span class="number">0</span><span class="special">;</span> <span class="special">--</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">//...</span>
        <span class="identifier">JoesAccount</span><span class="special">.</span><span class="identifier">Deposit</span><span class="special">(</span><span class="number">500</span><span class="special">);</span>
        <span class="comment">//...</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">Joe</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span><span class="number">10</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&gt;</span><span class="number">0</span><span class="special">;</span> <span class="special">--</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">//...</span>
        <span class="keyword">int</span> <span class="identifier">myPocket</span> <span class="special">=</span> <span class="identifier">JoesAccount</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">100</span><span class="special">);</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">myPocket</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="comment">//...</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">//...</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread1</span><span class="special">(</span><span class="identifier">bankAgent</span><span class="special">);</span> <span class="comment">// start concurrent execution of bankAgent</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread2</span><span class="special">(</span><span class="identifier">Joe</span><span class="special">);</span> <span class="comment">// start concurrent execution of Joe</span>
    <span class="identifier">thread1</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
    <span class="identifier">thread2</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
            From time to time, the <code class="computeroutput"><span class="identifier">bankAgent</span></code>
            will deposit $500 in <code class="computeroutput"><span class="identifier">JoesAccount</span></code>.
            <code class="computeroutput"><span class="identifier">Joe</span></code> will similarly withdraw
            $100 from his account. These sentences describe that the <code class="computeroutput"><span class="identifier">bankAgent</span></code> and <code class="computeroutput"><span class="identifier">Joe</span></code>
            are executed concurrently.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.internal_locking.internal_locking"></a><a class="link" href="tutorial.html#thread.synchronization.tutorial.internal_locking.internal_locking" title="Internal locking">Internal
          locking</a>
</h5></div></div></div>
<p>
            The above example works well as long as the components <code class="computeroutput"><span class="identifier">bankAgent</span></code> and <code class="computeroutput"><span class="identifier">Joe</span></code>
            doesn't access <code class="computeroutput"><span class="identifier">JoesAccount</span></code>
            at the same time. There is, however, no guarantee that this will not
            happen. We may use a mutex to guarantee exclusive access to each bank.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="keyword">int</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">balance_</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
        <span class="keyword">return</span> <span class="identifier">b</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Execution of the <code class="computeroutput"><span class="identifier">Deposit</span></code>
            and <code class="computeroutput"><span class="identifier">Withdraw</span></code> operations
            will no longer be able to make simultaneous access to balance.
          </p>
<p>
            A mutex is a simple and basic mechanism for obtaining synchronization.
            In the above example it is relatively easy to be convinced that the synchronization
            works correctly (in the absence of exception). In a system with several
            concurrent objects and several shared objects, it may be difficult to
            describe synchronization by means of mutexes. Programs that make heavy
            use of mutexes may be difficult to read and write. Instead, we shall
            introduce a number of generic classes for handling more complicated forms
            of synchronization and communication.
          </p>
<p>
            With the RAII idiom we can simplify a lot this using the scoped locks.
            In the code below, guard's constructor locks the passed-in object <code class="computeroutput"><span class="identifier">mtx_</span></code>, and guard's destructor unlocks
            <code class="computeroutput"><span class="identifier">mtx_</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span> <span class="comment">// explicit mutex declaration </span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">balance_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            The object-level locking idiom doesn't cover the entire richness of a
            threading model. For example, the model above is quite deadlock-prone
            when you try to coordinate multi-object transactions. Nonetheless, object-level
            locking is useful in many cases, and in combination with other mechanisms
            can provide a satisfactory solution to many threaded access problems
            in object-oriented programs.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.internal_locking.internal_and_external_locking"></a><a class="link" href="tutorial.html#thread.synchronization.tutorial.internal_locking.internal_and_external_locking" title="Internal and external locking">Internal
          and external locking</a>
</h5></div></div></div>
<p>
            The BankAccount class above uses internal locking. Basically, a class
            that uses internal locking guarantees that any concurrent calls to its
            public member functions don't corrupt an instance of that class. This
            is typically ensured by having each public member function acquire a
            lock on the object upon entry. This way, for any given object of that
            class, there can be only one member function call active at any moment,
            so the operations are nicely serialized.
          </p>
<p>
            This approach is reasonably easy to implement and has an attractive simplicity.
            Unfortunately, "simple" might sometimes morph into "simplistic."
          </p>
<p>
            Internal locking is insufficient for many real-world synchronization
            tasks. Imagine that you want to implement an ATM withdrawal transaction
            with the BankAccount class. The requirements are simple. The ATM transaction
            consists of two withdrawals-one for the actual money and one for the
            $2 commission. The two withdrawals must appear in strict sequence; that
            is, no other transaction can exist between them.
          </p>
<p>
            The obvious implementation is erratic:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="comment">// preemption possible</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            The problem is that between the two calls above, another thread can perform
            another operation on the account, thus breaking the second design requirement.
          </p>
<p>
            In an attempt to solve this problem, let's lock the account from the
            outside during the two operations:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">.</span><span class="identifier">mtx_</span><span class="special">);</span> <span class="number">1</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            Notice that the code above doesn't compile, the <code class="computeroutput"><span class="identifier">mtx_</span></code>
            field is private. We have two possibilities:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                make <code class="computeroutput"><span class="identifier">mtx_</span></code> public
                which seems odd
              </li>
<li class="listitem">
                make the <code class="computeroutput"><span class="identifier">BankAccount</span></code>
                lockable by adding the lock/unlock functions
              </li>
</ul></div>
<p>
            We can add these functions explicitly
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            or inheriting from a class which add these lockable functions.
          </p>
<p>
            The <code class="computeroutput"><span class="identifier">basic_lockable_adapter</span></code>
            class helps to define the <code class="computeroutput"><span class="identifier">BankAccount</span></code>
            class as
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">balance_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            and the code that doesn't compiles becomes
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            Notice that now acct is being locked by Withdraw after it has already
            been locked by guard. When running such code, one of two things happens.
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                Your mutex implementation might support the so-called recursive mutex
                semantics. This means that the same thread can lock the same mutex
                several times successfully. In this case, the implementation works
                but has a performance overhead due to unnecessary locking. (The locking/unlocking
                sequence in the two Withdraw calls is not needed but performed anyway-and
                that costs time.)
              </li>
<li class="listitem">
                Your mutex implementation might not support recursive locking, which
                means that as soon as you try to acquire it the second time, it blocks-so
                the ATMWithdrawal function enters the dreaded deadlock.
              </li>
</ul></div>
<p>
            As <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code> is not recursive, we need to
            use its recursive version <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">recursive_mutex</span><span class="special">&gt;</span>
<span class="special">{</span>

    <span class="comment">// ...</span>
<span class="special">};</span>
</pre>
<p>
            The caller-ensured locking approach is more flexible and the most efficient,
            but very dangerous. In an implementation using caller-ensured locking,
            BankAccount still holds a mutex, but its member functions don't manipulate
            it at all. Deposit and Withdraw are not thread-safe anymore. Instead,
            the client code is responsible for locking BankAccount properly.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
    <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">:</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Obviously, the caller-ensured locking approach has a safety problem.
            BankAccount's implementation code is finite, and easy to reach and maintain,
            but there's an unbounded amount of client code that manipulates BankAccount
            objects. In designing applications, it's important to differentiate between
            requirements imposed on bounded code and unbounded code. If your class
            makes undue requirements on unbounded code, that's usually a sign that
            encapsulation is out the window.
          </p>
<p>
            To conclude, if in designing a multi-threaded class you settle on internal
            locking, you expose yourself to inefficiency or deadlocks. On the other
            hand, if you rely on caller-provided locking, you make your class error-prone
            and difficult to use. Finally, external locking completely avoids the
            issue by leaving it all to the client code.
          </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes"></a><a class="link" href="tutorial.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes" title="External Locking -- strict_lock and externally_locked classes">External
        Locking -- <code class="computeroutput"><span class="identifier">strict_lock</span></code> and
        <code class="computeroutput"><span class="identifier">externally_locked</span></code> classes</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.locks_as_permits">Locks
          as permits</a></span></dt>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.improving_external_locking">Improving
          External Locking</a></span></dt>
<dt><span class="section"><a href="tutorial.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.allowing_other_strict_locks">Allowing
          other strict locks</a></span></dt>
</dl></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            This tutorial is an adaptation of the paper by Andrei Alexandrescu "Multithreading
            and the C++ Type System" to the Boost library.
          </p></td></tr>
</table></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.locks_as_permits"></a><a class="link" href="tutorial.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.locks_as_permits" title="Locks as permits">Locks
          as permits</a>
</h5></div></div></div>
<p>
            So what to do? Ideally, the BankAccount class should do the following:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                Support both locking models (internal and external).
              </li>
<li class="listitem">
                Be efficient; that is, use no unnecessary locking.
              </li>
<li class="listitem">
                Be safe; that is, BankAccount objects cannot be manipulated without
                appropriate locking.
              </li>
</ul></div>
<p>
            Let's make a worthwhile observation: Whenever you lock a BankAccount,
            you do so by using a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object. Turning this statement around,
            wherever there's a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>, there's also a locked <code class="computeroutput"><span class="identifier">BankAccount</span></code> somewhere. Thus, you can
            think of-and use-a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object as a permit. Owning a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            gives you rights to do certain things. The <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object should not be copied or aliased
            (it's not a transmissible permit).
          </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                As long as a permit is still alive, the <code class="computeroutput"><span class="identifier">BankAccount</span></code>
                object stays locked.
              </li>
<li class="listitem">
                When the <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> is destroyed, the <code class="computeroutput"><span class="identifier">BankAccount</span></code>'s mutex is released.
              </li>
</ol></div>
<p>
            The net effect is that at any point in your code, having access to a
            <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            object guarantees that a <code class="computeroutput"><span class="identifier">BankAccount</span></code>
            is locked. (You don't know exactly which <code class="computeroutput"><span class="identifier">BankAccount</span></code>
            is locked, however-an issue that we'll address soon.)
          </p>
<p>
            For now, let's make a couple of enhancements to the <code class="computeroutput"><span class="identifier">lock_guard</span></code>
            class template defined in Boost.Thread. We'll call the enhanced version
            <code class="computeroutput"><span class="identifier">strict_lock</span></code>. Essentially,
            a <code class="computeroutput"><span class="identifier">strict_lock</span></code>'s role
            is only to live on the stack as an automatic variable. <code class="computeroutput"><span class="identifier">strict_lock</span></code> must adhere to a non-copy
            and non-alias policy. <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            disables copying by making the copy constructor and the assignment operator
            private.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">strict_lock</span>  <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">lockable_type</span><span class="special">;</span>


    <span class="keyword">explicit</span> <span class="identifier">strict_lock</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">obj_</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">obj</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span> <span class="comment">// locks on construction</span>
    <span class="special">}</span>
    <span class="identifier">strict_lock</span><span class="special">()</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">strict_lock</span><span class="special">(</span><span class="identifier">strict_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">strict_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">strict_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="special">~</span><span class="identifier">strict_lock</span><span class="special">()</span> <span class="special">{</span> <span class="identifier">obj_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span> <span class="special">}</span> <span class="comment">//  unlocks on destruction </span>

    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">mutex_type</span> <span class="keyword">const</span><span class="special">*</span> <span class="identifier">l</span><span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="comment">// strict lockers specific function </span>
    <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">l</span> <span class="special">==</span> <span class="special">&amp;</span><span class="identifier">obj_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">obj_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            Silence can be sometimes louder than words-what's forbidden to do with
            a <code class="computeroutput"><span class="identifier">strict_lock</span></code> is as important
            as what you can do. Let's see what you can and what you cannot do with
            a <code class="computeroutput"><span class="identifier">strict_lock</span></code> instantiation:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                You can create a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> only starting from a valid T
                object. Notice that there is no other way you can create a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>.
              </li></ul></div>
<pre class="programlisting"><span class="identifier">BankAccount</span> <span class="identifier">myAccount</span><span class="special">(</span><span class="string">"John Doe"</span><span class="special">,</span> <span class="string">"123-45-6789"</span><span class="special">);</span>
<span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">myLock</span><span class="special">(</span><span class="identifier">myAccount</span><span class="special">);</span> <span class="comment">// ok</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                You cannot copy <code class="computeroutput"><span class="identifier">strict_lock</span></code>s
                to one another. In particular, you cannot pass <code class="computeroutput"><span class="identifier">strict_lock</span></code>s
                by value to functions or have them returned by functions:
              </li></ul></div>
<pre class="programlisting"><span class="keyword">extern</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">Foo</span><span class="special">();</span> <span class="comment">// compile-time error</span>
<span class="keyword">extern</span> <span class="keyword">void</span> <span class="identifier">Bar</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;);</span> <span class="comment">// compile-time error</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                However, you still can pass <code class="computeroutput"><span class="identifier">strict_lock</span></code>s
                by reference to and from functions:
              </li></ul></div>
<pre class="programlisting"><span class="comment">// ok, Foo returns a reference to strict_lock&lt;BankAccount&gt;</span>
<span class="keyword">extern</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;</span> <span class="identifier">Foo</span><span class="special">();</span>
<span class="comment">// ok, Bar takes a reference to strict_lock&lt;BankAccount&gt;</span>
<span class="keyword">extern</span> <span class="keyword">void</span> <span class="identifier">Bar</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;);</span>
</pre>
<p>
            All these rules were put in place with one purpose-enforcing that owning
            a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
            is a reasonably strong guarantee that
          </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                you locked a T object, and
              </li>
<li class="listitem">
                that object will be unlocked at a later point.
              </li>
</ol></div>
<p>
            Now that we have such a strict <code class="computeroutput"><span class="identifier">strict_lock</span></code>,
            how do we harness its power in defining a safe, flexible interface for
            BankAccount? The idea is as follows:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                Each of BankAccount's interface functions (in our case, Deposit and
                Withdraw) comes in two overloaded variants.
              </li>
<li class="listitem">
                One version keeps the same signature as before, and the other takes
                an additional argument of type <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>. The first version is internally
                locked; the second one requires external locking. External locking
                is enforced at compile time by requiring client code to create a
                <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
                object.
              </li>
<li class="listitem">
                BankAccount avoids code bloating by having the internal locked functions
                forward to the external locked functions, which do the actual job.
              </li>
</ul></div>
<p>
            A little code is worth 1,000 words, a (hacked into) saying goes, so here's
            the new BankAccount class:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span> <span class="special">{</span>
        <span class="comment">// Externally locked</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span> <span class="comment">// Internally locked</span>
        <span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span> <span class="special">{</span>
        <span class="comment">// Externally locked</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span> <span class="comment">// Internally locked</span>
        <span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Now, if you want the benefit of internal locking, you simply call <code class="computeroutput"><span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span></code> and
            <code class="computeroutput"><span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span></code>.
            If you want to use external locking, you lock the object by constructing
            a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            and then you call <code class="computeroutput"><span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span>
            <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>
            and <code class="computeroutput"><span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>.
            For example, here's the <code class="computeroutput"><span class="identifier">ATMWithdrawal</span></code>
            function implemented correctly:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            This function has the best of both worlds-it's reasonably safe and efficient
            at the same time.
          </p>
<p>
            It's worth noting that <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            being a template gives extra safety compared to a straight polymorphic
            approach. In such a design, BankAccount would derive from a Lockable
            interface. <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            would manipulate Lockable references so there's no need for templates.
            This approach is sound; however, it provides fewer compile-time guarantees.
            Having a <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            object would only tell that some object derived from Lockable is currently
            locked. In the templated approach, having a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> gives a stronger guarantee-it's a
            <code class="computeroutput"><span class="identifier">BankAccount</span></code> that stays
            locked.
          </p>
<p>
            There's a weasel word in there-I mentioned that ATMWithdrawal is reasonably
            safe. It's not really safe because there's no enforcement that the <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            object locks the appropriate BankAccount object. The type system only
            ensures that some BankAccount object is locked. For example, consider
            the following phony implementation of ATMWithdrawal:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">BankAccount</span> <span class="identifier">fakeAcct</span><span class="special">(</span><span class="string">"John Doe"</span><span class="special">,</span> <span class="string">"123-45-6789"</span><span class="special">);</span>
    <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">fakeAcct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            This code compiles warning-free but obviously doesn't do the right thing-it
            locks one account and uses another.
          </p>
<p>
            It's important to understand what can be enforced within the realm of
            the C++ type system and what needs to be enforced at runtime. The mechanism
            we've put in place so far ensures that some BankAccount object is locked
            during the call to <code class="computeroutput"><span class="identifier">BankAccount</span><span class="special">::</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span>
            <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>.
            We must enforce at runtime exactly what object is locked.
          </p>
<p>
            If our scheme still needs runtime checks, how is it useful? An unwary
            or malicious programmer can easily lock the wrong object and manipulate
            any BankAccount without actually locking it.
          </p>
<p>
            First, let's get the malice issue out of the way. C is a language that
            requires a lot of attention and discipline from the programmer. C++ made
            some progress by asking a little less of those, while still fundamentally
            trusting the programmer. These languages are not concerned with malice
            (as Java is, for example). After all, you can break any C/C++ design
            simply by using casts "appropriately" (if appropriately is
            an, er, appropriate word in this context).
          </p>
<p>
            The scheme is useful because the likelihood of a programmer forgetting
            about any locking whatsoever is much greater than the likelihood of a
            programmer who does remember about locking, but locks the wrong object.
          </p>
<p>
            Using <code class="computeroutput"><span class="identifier">strict_lock</span></code> permits
            compile-time checking of the most common source of errors, and runtime
            checking of the less frequent problem.
          </p>
<p>
            Let's see how to enforce that the appropriate BankAccount object is locked.
            First, we need to add a member function to the <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            class template. The <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">*)</span></code>
            function returns a reference to the locked object.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="keyword">class</span> <span class="identifier">strict_lock</span> <span class="special">{</span>
    <span class="special">...</span> <span class="identifier">as</span> <span class="identifier">before</span> <span class="special">...</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mtx</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">mtx</span><span class="special">==&amp;</span><span class="identifier">obj_</span><span class="special">;</span> <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Second, BankAccount needs to use this function compare the locked object
            against this:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;</span> <span class="identifier">guard</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Externally locked</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">guard</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(*</span><span class="keyword">this</span><span class="special">))</span>
            <span class="keyword">throw</span> <span class="string">"Locking Error: Wrong Object Locked"</span><span class="special">;</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
<span class="comment">// ...</span>
<span class="special">};</span>
</pre>
<p>
            The overhead incurred by the test above is much lower than locking a
            recursive mutex for the second time.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.improving_external_locking"></a><a class="link" href="tutorial.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.improving_external_locking" title="Improving External Locking">Improving
          External Locking</a>
</h5></div></div></div>
<p>
            Now let's assume that BankAccount doesn't use its own locking at all,
            and has only a thread-neutral implementation:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Now you can use BankAccount in single-threaded and multi-threaded applications
            alike, but you need to provide your own synchronization in the latter
            case.
          </p>
<p>
            Say we have an AccountManager class that holds and manipulates a BankAccount
            object:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">AccountManager</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">BankAccount</span> <span class="identifier">checkingAcct_</span><span class="special">;</span>
    <span class="identifier">BankAccount</span> <span class="identifier">savingsAcct_</span><span class="special">;</span>
    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
            Let's also assume that, by design, AccountManager must stay locked while
            accessing its BankAccount members. The question is, how can we express
            this design constraint using the C++ type system? How can we state "You
            have access to this BankAccount object only after locking its parent
            AccountManager object"?
          </p>
<p>
            The solution is to use a little bridge template <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            that controls access to a BankAccount.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span>  <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked</span> <span class="special">{</span>
    <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">LockableConcept</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;));</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">obj_</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span>
        <span class="special">,</span> <span class="identifier">lockable_</span><span class="special">(</span><span class="identifier">lockable</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">obj_</span><span class="special">()</span>
        <span class="special">,</span> <span class="identifier">lockable_</span><span class="special">(</span><span class="identifier">lockable</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span> <span class="special">{</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">lock</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(&amp;</span><span class="identifier">lockable_</span><span class="special">))</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span> <span class="comment">//run time check throw if not locks the same</span>
<span class="preprocessor">#endif</span>
        <span class="keyword">return</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">obj_</span> <span class="special">=</span> <span class="identifier">obj</span><span class="special">;</span>
        <span class="identifier">lockable_</span><span class="special">=</span><span class="identifier">lockable</span><span class="special">;</span>
    <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">T</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            <code class="computeroutput"><span class="identifier">externally_locked</span></code> cloaks
            an object of type T, and actually provides full access to that object
            through the get and set member functions, provided you pass a reference
            to a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Owner</span><span class="special">&gt;</span></code>
            object.
          </p>
<p>
            Instead of making <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>
            and <code class="computeroutput"><span class="identifier">savingsAcct_</span></code> of type
            <code class="computeroutput"><span class="identifier">BankAccount</span></code>, <code class="computeroutput"><span class="identifier">AccountManager</span></code> holds objects of type
            <code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span>
            <span class="identifier">AccountManager</span><span class="special">&gt;</span></code>:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">AccountManager</span>
    <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lockable_base_type</span><span class="special">;</span>
    <span class="identifier">AccountManager</span><span class="special">()</span>
        <span class="special">:</span> <span class="identifier">checkingAcct_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span>
        <span class="special">,</span> <span class="identifier">savingsAcct_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span>
    <span class="special">{}</span>
    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="identifier">Checking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">);</span>
    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">);</span>
<span class="keyword">private</span><span class="special">:</span>

    <span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span> <span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">checkingAcct_</span><span class="special">;</span>
    <span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span> <span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">savingsAcct_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            The pattern is the same as before - to access the BankAccount object
            cloaked by <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>,
            you need to call <code class="computeroutput"><span class="identifier">get</span></code>.
            To call <code class="computeroutput"><span class="identifier">get</span></code>, you need
            to pass it a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span></code>. The one thing you have to take care
            of is to not hold pointers or references you obtained by calling <code class="computeroutput"><span class="identifier">get</span></code>. If you do that, make sure that
            you don't use them after the strict_lock has been destroyed. That is,
            if you alias the cloaked objects, you're back from "the compiler
            takes care of that" mode to "you must pay attention" mode.
          </p>
<p>
            Typically, you use <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            as shown below. Suppose you want to execute an atomic transfer from your
            checking account to your savings account:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">Checking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
    <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            We achieved two important goals. First, the declaration of <code class="computeroutput"><span class="identifier">checkingAcct_</span></code> and <code class="computeroutput"><span class="identifier">savingsAcct_</span></code>
            makes it clear to the code reader that that variable is protected by
            a lock on an AccountManager. Second, the design makes it impossible to
            manipulate the two accounts without actually locking a BankAccount.
            <code class="computeroutput"><span class="identifier">externally_locked</span></code> is
            what could be called active documentation.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.allowing_other_strict_locks"></a><a class="link" href="tutorial.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.allowing_other_strict_locks" title="Allowing other strict locks">Allowing
          other strict locks</a>
</h5></div></div></div>
<p>
            Now imagine that the AccountManager function needs to take a <code class="computeroutput"><span class="identifier">unique_lock</span></code> in order to reduce the
            critical regions. And at some time it needs to access to the <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>. As <code class="computeroutput"><span class="identifier">unique_lock</span></code>
            is not a strict lock the following code doesn't compile:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">defer_lock</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span> <span class="comment">// COMPILE ERROR</span>
    <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>  <span class="comment">// COMPILE ERROR</span>
    <span class="identifier">do_something_else</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
            We need a way to transfer the ownership from the <code class="computeroutput"><span class="identifier">unique_lock</span></code>
            to a <code class="computeroutput"><span class="identifier">strict_lock</span></code> during
            the time we are working with <code class="computeroutput"><span class="identifier">savingsAcct_</span></code>
            and then restore the ownership on <code class="computeroutput"><span class="identifier">unique_lock</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard1</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">defer_lock</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="special">{</span>
        <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">guard1</span><span class="special">);</span>
        <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
        <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
            In order to make this code compilable we need to store either a Lockable
            or a <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span></code>
            reference depending on the constructor. We also need to store which kind
            of reference we have stored, and in the destructor call either to the
            Lockable <code class="computeroutput"><span class="identifier">unlock</span></code> or restore
            the ownership.
          </p>
<p>
            This seems too complicated to me. Another possibility is to define a
            nested strict lock class. The drawback is that instead of having only
            one strict lock we have two and we need either to duplicate every function
            taking a <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            or make these function templates. The problem with template functions
            is that we don't profit anymore of the C++ type system. We must add some
            static metafunction that checks that the Locker parameter is a strict
            lock. The problem is that we can not really check this or can we?. The
            <code class="computeroutput"><span class="identifier">is_strict_lock</span></code> metafunction
            must be specialized by the strict lock developer. We need to believe
            it "sur parole". The advantage is that now we can manage with
            more than two strict locks without changing our code. This is really
            nice.
          </p>
<p>
            Now we need to state that both classes are <code class="computeroutput"><span class="identifier">strict_lock</span></code>s.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_lock</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span> <span class="special">{};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_lock</span><span class="special">&lt;</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span> <span class="special">{}</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_lock</span><span class="special">&lt;</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span> <span class="special">{}</span>
</pre>
<p>
            Well let me show what this <code class="computeroutput"><span class="identifier">nested_strict_lock</span></code>
            class looks like and the impacts on the <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            class and the <code class="computeroutput"><span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedFunction</span></code>
            function.
          </p>
<p>
            First <code class="computeroutput"><span class="identifier">nested_strict_lock</span></code>
            class will store on a temporary lock the <code class="computeroutput"><span class="identifier">Locker</span></code>,
            and transfer the lock ownership on the constructor. On destruction it
            will restore the ownership. Note the use of <code class="computeroutput"><span class="identifier">lock_traits</span></code>
            and that the <code class="computeroutput"><span class="identifier">Locker</span></code> needs
            to have a reference to the mutex otherwise an exception is thrown.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">nested_strict_lock</span>
    <span class="special">{</span>
      <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">MovableLockerConcept</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;));</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_type</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">lockable_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">syntactic_lock_traits</span><span class="special">&lt;</span><span class="identifier">lockable_type</span><span class="special">&gt;::</span><span class="identifier">lock_error</span> <span class="identifier">lock_error</span><span class="special">;</span>

    <span class="identifier">nested_strict_lock</span><span class="special">(</span><span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">lock_</span><span class="special">(</span><span class="identifier">lock</span><span class="special">)</span>  <span class="comment">// Store reference to locker</span>
        <span class="special">,</span> <span class="identifier">tmp_lock_</span><span class="special">(</span><span class="identifier">lock</span><span class="special">.</span><span class="identifier">move</span><span class="special">())</span> <span class="comment">// Move ownership to temporary locker </span>
    <span class="special">{</span>
        <span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()==</span><span class="number">0</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">lock_</span><span class="special">=</span><span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">move</span><span class="special">();</span> <span class="comment">// Rollback for coherency purposes </span>
            <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span>
        <span class="special">}</span>
        <span class="preprocessor">#endif</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">tmp_lock_</span><span class="special">)</span> <span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span> <span class="comment">// ensures it is locked </span>
    <span class="special">}</span>
    <span class="special">~</span><span class="identifier">nested_strict_lock</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">lock_</span><span class="special">=</span><span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">move</span><span class="special">();</span> <span class="comment">// Move ownership to nesting locker </span>
    <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span> <span class="special">}</span>
    <span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">();</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">l</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">l</span><span class="special">==</span><span class="identifier">mutex</span><span class="special">();</span> <span class="special">}</span>


<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">lock_</span><span class="special">;</span>
    <span class="identifier">Locker</span> <span class="identifier">tmp_lock_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            The <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            get function is now a template function taking a Locker as parameters
            instead of a <code class="computeroutput"><span class="identifier">strict_lock</span></code>.
            We can add test in debug mode that ensure that the Lockable object is
            locked.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span>  <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// ...</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">StrictLockerConcept</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;));</span>

        <span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span><span class="identifier">is_strict_lock</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">));</span> <span class="comment">// locker is a strict locker "sur parole" </span>
        <span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">,</span>
                <span class="keyword">typename</span> <span class="identifier">lockable_type</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">));</span> <span class="comment">// that locks the same type </span>
<span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_THREAD_EXTERNALLY_LOCKED_DONT_CHECK_OWNERSHIP</span>  <span class="comment">// define BOOST_THREAD_EXTERNALLY_LOCKED_NO_CHECK_OWNERSHIP if you don't want to check locker ownership</span>
        <span class="keyword">if</span> <span class="special">(!</span> <span class="identifier">lock</span> <span class="special">)</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span> <span class="comment">// run time check throw if no locked </span>
<span class="preprocessor">#endif</span>
<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">lock</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(&amp;</span><span class="identifier">lockable_</span><span class="special">))</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span>
<span class="preprocessor">#endif</span>
        <span class="keyword">return</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            The <code class="computeroutput"><span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedFunction</span></code> function needs
            only to replace the <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            by a <code class="computeroutput"><span class="identifier">nested_strict_lock</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard1</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="special">{</span>
        <span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">guard1</span><span class="special">);</span>
        <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
        <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="special">}</span>
</pre>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.tutorial.with"></a><a class="link" href="tutorial.html#thread.synchronization.tutorial.with" title="Executing Around a Function">Executing Around
        a Function</a>
</h4></div></div></div>
<p>
          In particular, the library provides a way to lock around the execution
          of a function.
        </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lockable</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Function</span><span class="special">,</span> <span class="keyword">class</span><span class="special">...</span> <span class="identifier">Args</span><span class="special">&gt;</span>
<span class="keyword">auto</span> <span class="identifier">with_lock_guard</span><span class="special">(</span>
    <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span>
    <span class="identifier">Function</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">,</span>
    <span class="identifier">Args</span><span class="special">&amp;&amp;...</span> <span class="identifier">args</span>
<span class="special">)</span> <span class="special">-&gt;</span> <span class="keyword">decltype</span><span class="special">(</span><span class="identifier">func</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">)...))</span> <span class="special">{</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">m</span><span class="special">);</span>
  <span class="keyword">return</span> <span class="identifier">func</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">)...);</span>
<span class="special">}</span>
</pre>
<p>
          that can be used with regular functions:
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">func</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&amp;);</span>
<span class="comment">//...</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">m</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">a</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">with_lock_guard</span><span class="special">(</span><span class="identifier">m</span><span class="special">,</span> <span class="identifier">func</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">a</span><span class="special">));</span>
</pre>
<p>
          with boost::bind:
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">with_lock_guard</span><span class="special">(</span>
    <span class="identifier">m</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">func</span><span class="special">,</span> <span class="number">2</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">a</span><span class="special">))</span>
<span class="special">);</span>
</pre>
<p>
          or with lambda expression:
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">a</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">with_lock_guard</span><span class="special">(</span>
    <span class="identifier">m</span><span class="special">,</span>
    <span class="special">[&amp;</span><span class="identifier">a</span><span class="special">](</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">{</span>
      <span class="comment">// this scope is protected by mutex m</span>
      <span class="identifier">a</span> <span class="special">=</span> <span class="number">3</span><span class="special">;</span>
      <span class="keyword">return</span> <span class="identifier">x</span> <span class="special">+</span> <span class="number">4</span><span class="special">;</span>
    <span class="special">},</span>
    <span class="number">5</span>
<span class="special">);</span>
</pre>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2007 -11 Anthony Williams<br>Copyright &#169; 2011 -15 Vicente J. Botet Escriba<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../synchronization.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../synchronization.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="mutex_concepts.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
