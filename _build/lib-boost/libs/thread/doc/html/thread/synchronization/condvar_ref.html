<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Condition Variables</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Thread 4.7.0">
<link rel="up" href="../synchronization.html" title="Synchronization">
<link rel="prev" href="mutex_types.html" title="Mutex Types">
<link rel="next" href="once.html" title="One-time Initialization">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="mutex_types.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../synchronization.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="once.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.condvar_ref"></a><a class="link" href="condvar_ref.html" title="Condition Variables">Condition Variables</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable">Class
        <code class="computeroutput"><span class="identifier">condition_variable</span></code></a></span></dt>
<dd><dl>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.constructor"><code class="computeroutput"><span class="identifier">condition_variable</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.notify_one"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.notify_all"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.timed_wait"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_rel"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_until"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_for"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_until_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_for_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
</dl></dd>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any">Class
        <code class="computeroutput"><span class="identifier">condition_variable_any</span></code></a></span></dt>
<dd><dl>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.constructor"><code class="computeroutput"><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.notify_one"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.notify_all"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
</dl></dd>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition">Typedef
        <code class="computeroutput"><span class="identifier">condition</span></code> DEPRECATED V3</a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.notify_all_at_thread_exit">Non-member
        Function <code class="computeroutput"><span class="identifier">notify_all_at_thread_exit</span></code>()</a></span></dt>
</dl></div>
<h5>
<a name="thread.synchronization.condvar_ref.h0"></a>
        <span><a name="thread.synchronization.condvar_ref.synopsis"></a></span><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.synopsis">Synopsis</a>
      </h5>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">cv_status</span><span class="special">;</span>
  <span class="special">{</span>
    <span class="identifier">no_timeout</span><span class="special">,</span>
    <span class="identifier">timeout</span>
  <span class="special">};</span>
  <span class="keyword">class</span> <span class="identifier">condition_variable</span><span class="special">;</span>
  <span class="keyword">class</span> <span class="identifier">condition_variable_any</span><span class="special">;</span>
  <span class="keyword">void</span> <span class="identifier">notify_all_at_thread_exit</span><span class="special">(</span><span class="identifier">condition_variable</span><span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">,</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        The classes <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        and <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>
        provide a mechanism for one thread to wait for notification from another
        thread that a particular condition has become true. The general usage pattern
        is that one thread locks a mutex and then calls <code class="computeroutput"><span class="identifier">wait</span></code>
        on an instance of <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        or <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>.
        When the thread is woken from the wait, then it checks to see if the appropriate
        condition is now true, and continues if so. If the condition is not true,
        then the thread then calls <code class="computeroutput"><span class="identifier">wait</span></code>
        again to resume waiting. In the simplest case, this condition is just a boolean
        variable:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable</span> <span class="identifier">cond</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mut</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">data_ready</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">process_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">wait_for_data_to_process</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mut</span><span class="special">);</span>
    <span class="keyword">while</span><span class="special">(!</span><span class="identifier">data_ready</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">cond</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">process_data</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Notice that the <code class="computeroutput"><span class="identifier">lock</span></code> is passed
        to <code class="computeroutput"><span class="identifier">wait</span></code>: <code class="computeroutput"><span class="identifier">wait</span></code>
        will atomically add the thread to the set of threads waiting on the condition
        variable, and unlock the mutex. When the thread is woken, the mutex will
        be locked again before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
        returns. This allows other threads to acquire the mutex in order to update
        the shared data, and ensures that the data associated with the condition
        is correctly synchronized.
      </p>
<p>
        In the mean time, another thread sets the condition to <code class="computeroutput"><span class="keyword">true</span></code>,
        and then calls either <code class="computeroutput"><span class="identifier">notify_one</span></code>
        or <code class="computeroutput"><span class="identifier">notify_all</span></code> on the condition
        variable to wake one waiting thread or all the waiting threads respectively.
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">retrieve_data</span><span class="special">();</span>
<span class="keyword">void</span> <span class="identifier">prepare_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">prepare_data_for_processing</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">retrieve_data</span><span class="special">();</span>
    <span class="identifier">prepare_data</span><span class="special">();</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mut</span><span class="special">);</span>
        <span class="identifier">data_ready</span><span class="special">=</span><span class="keyword">true</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">cond</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Note that the same mutex is locked before the shared data is updated, but
        that the mutex does not have to be locked across the call to <code class="computeroutput"><span class="identifier">notify_one</span></code>.
      </p>
<p>
        This example uses an object of type <code class="computeroutput"><span class="identifier">condition_variable</span></code>,
        but would work just as well with an object of type <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>:
        <code class="computeroutput"><span class="identifier">condition_variable_any</span></code> is
        more general, and will work with any kind of lock or mutex, whereas <code class="computeroutput"><span class="identifier">condition_variable</span></code> requires that the lock
        passed to <code class="computeroutput"><span class="identifier">wait</span></code> is an instance
        of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span></code>.
        This enables <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        to make optimizations in some cases, based on the knowledge of the mutex
        type; <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>
        typically has a more complex implementation than <code class="computeroutput"><span class="identifier">condition_variable</span></code>.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable" title="Class condition_variable">Class
        <code class="computeroutput"><span class="identifier">condition_variable</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.constructor"><code class="computeroutput"><span class="identifier">condition_variable</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.notify_one"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.notify_all"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.timed_wait"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_rel"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_until"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_for"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_until_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_for_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/condition_variable.hpp&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
    <span class="keyword">class</span> <span class="identifier">condition_variable</span>
    <span class="special">{</span>
    <span class="keyword">public</span><span class="special">:</span>
        <span class="identifier">condition_variable</span><span class="special">();</span>
        <span class="special">~</span><span class="identifier">condition_variable</span><span class="special">();</span>

        <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
        <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
        <span class="keyword">typename</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">type</span>
        <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span>
        <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
        <span class="keyword">typename</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">type</span>
        <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span>
        <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>

    <span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_USES_DATETIME</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
    <span class="preprocessor">#endif</span>

    <span class="special">};</span>
<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.constructor"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.constructor" title="condition_variable()"><code class="computeroutput"><span class="identifier">condition_variable</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of class <code class="computeroutput"><span class="identifier">condition_variable</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.destructor"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.destructor" title="~condition_variable()"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  All threads waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call
                  to <code class="computeroutput"><span class="identifier">notify_one</span></code> or
                  <code class="computeroutput"><span class="identifier">notify_all</span></code> (though
                  the respective calls to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code> need
                  not have returned).
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Destroys the object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.notify_one"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.notify_one" title="void notify_one()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks one of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.notify_all"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.notify_all" title="void notify_all()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks all of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait" title="void wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock)"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="../thread_management/thread.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="../thread_management/thread.html" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_predicate"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_predicate" title="template&lt;typename predicate_type&gt; void wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.timed_wait" title="bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock,boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="keyword">true</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="../thread_management/thread.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="../thread_management/thread.html" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait_rel"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_rel" title="template&lt;typename duration_type&gt; bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock,duration_type const&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time period specified by <code class="computeroutput"><span class="identifier">rel_time</span></code> has elapsed, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="../thread_management/thread.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="../thread_management/thread.html" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate" title="template&lt;typename predicate_type&gt; bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, boost::system_time const&amp; abs_time, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_until"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_until" title="template &lt;class Clock, class Duration&gt; cv_status wait_until(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code> in all the threads
                  currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">Clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code> if the call is returning
                  because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="../thread_management/thread.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="../thread_management/thread.html" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_for"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_for" title="template &lt;class Rep, class Period&gt; cv_status wait_for(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">wait_until</span></code> or
                  <code class="computeroutput"><span class="identifier">wait_for</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span> </code> if the call is returning
                  because the time period specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  has elapsed, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span>
                  </code> otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="../thread_management/thread.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="../thread_management/thread.html" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_until_predicate"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_until_predicate" title="template &lt;class Clock, class Duration, class Predicate&gt; bool wait_until(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_for_predicate"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable.wait_for_predicate" title="template &lt;class Rep, class Period, class Predicate&gt; bool wait_for(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">return</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">d</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">pred</span><span class="special">));</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any" title="Class condition_variable_any">Class
        <code class="computeroutput"><span class="identifier">condition_variable_any</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.constructor"><code class="computeroutput"><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.notify_one"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.notify_all"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/condition_variable.hpp&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
    <span class="keyword">class</span> <span class="identifier">condition_variable_any</span>
    <span class="special">{</span>
    <span class="keyword">public</span><span class="special">:</span>
        <span class="identifier">condition_variable_any</span><span class="special">();</span>
        <span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">();</span>

        <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">();</span>
        <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">();</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
        <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>


        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
        <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>

    <span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_USES_DATETIME</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
    <span class="preprocessor">#endif</span>
    <span class="special">};</span>
<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.constructor"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.constructor" title="condition_variable_any()"><code class="computeroutput"><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of class <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.destructor"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.destructor" title="~condition_variable_any()"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  All threads waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call
                  to <code class="computeroutput"><span class="identifier">notify_one</span></code> or
                  <code class="computeroutput"><span class="identifier">notify_all</span></code> (though
                  the respective calls to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code> need
                  not have returned).
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Destroys the object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.notify_one"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.notify_one" title="void notify_one()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks one of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.notify_all"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.notify_all" title="void notify_all()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks all of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait" title="template&lt;typename lock_type&gt; void wait(lock_type&amp; lock)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="../thread_management/thread.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="../thread_management/thread.html" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_predicate"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_predicate" title="template&lt;typename lock_type,typename predicate_type&gt; void wait(lock_type&amp; lock, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait" title="template&lt;typename lock_type&gt; bool timed_wait(lock_type&amp; lock,boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="keyword">true</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="../thread_management/thread.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="../thread_management/thread.html" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel" title="template&lt;typename lock_type,typename duration_type&gt; bool timed_wait(lock_type&amp; lock,duration_type const&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time period specified by <code class="computeroutput"><span class="identifier">rel_time</span></code> has elapsed, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="../thread_management/thread.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="../thread_management/thread.html" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate" title="template&lt;typename lock_type,typename predicate_type&gt; bool timed_wait(lock_type&amp; lock, boost::system_time const&amp; abs_time, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_until"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until" title="template &lt;class lock_type, class Clock, class Duration&gt; cv_status wait_until(lock_type&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">Clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code> if the call is returning
                  because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="../thread_management/thread.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="../thread_management/thread.html" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_for"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for" title="template &lt;class lock_type, class Rep, class Period&gt; cv_status wait_for(lock_type&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code> if the call is returning
                  because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="../thread_management/thread.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="../thread_management/thread.html" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_until_predicate"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until_predicate" title="template &lt;class lock_type, class Clock, class Duration, class Predicate&gt; bool wait_until(lock_type&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until" title="template &lt;class lock_type, class Clock, class Duration&gt; cv_status wait_until(lock_type&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="identifier">wait_until</span></code></a><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_for_predicate"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for_predicate" title="template &lt;class lock_type, class Rep, class Period, class Predicate&gt; bool wait_for(lock_type&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">return</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">d</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">pred</span><span class="special">));</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.condition" title="Typedef condition DEPRECATED V3">Typedef
        <code class="computeroutput"><span class="identifier">condition</span></code> DEPRECATED V3</a>
</h4></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/condition.hpp&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">typedef</span> <span class="identifier">condition_variable_any</span> <span class="identifier">condition</span><span class="special">;</span>

<span class="special">}</span>
</pre>
<p>
          The typedef <code class="computeroutput"><span class="identifier">condition</span></code> is
          provided for backwards compatibility with previous boost releases.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.notify_all_at_thread_exit"></a><a class="link" href="condvar_ref.html#thread.synchronization.condvar_ref.notify_all_at_thread_exit" title="Non-member Function notify_all_at_thread_exit()">Non-member
        Function <code class="computeroutput"><span class="identifier">notify_all_at_thread_exit</span></code>()</a>
</h4></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/condition_variable.hpp&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">void</span> <span class="identifier">notify_all_at_thread_exit</span><span class="special">(</span><span class="identifier">condition_variable</span><span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">,</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
                calling thread and either no other thread is waiting on <code class="computeroutput"><span class="identifier">cond</span></code>, or <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()</span></code> returns the same value for each
                of the lock arguments supplied by all concurrently waiting (via
                <code class="computeroutput"><span class="identifier">wait</span></code>, <code class="computeroutput"><span class="identifier">wait_for</span></code>, or <code class="computeroutput"><span class="identifier">wait_until</span></code>)
                threads.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                transfers ownership of the lock associated with <code class="computeroutput"><span class="identifier">lk</span></code>
                into internal storage and schedules <code class="computeroutput"><span class="identifier">cond</span></code>
                to be notified when the current thread exits, after all objects of
                thread storage duration associated with the current thread have been
                destroyed. This notification shall be as if
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="identifier">cond</span><span class="special">.</span><span class="identifier">notify_all</span><span class="special">();</span>
</pre>
<p>
              </p>
</dd>
</dl>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2007 -11 Anthony Williams<br>Copyright &#169; 2011 -15 Vicente J. Botet Escriba<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="mutex_types.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../synchronization.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="once.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
